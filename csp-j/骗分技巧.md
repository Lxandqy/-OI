# 1

要纠正一种错误的观念，“**时间复杂度越低越好** ”。有时为了降低一道题目的复杂度，

耽误了其他题目解决的时间，得不偿失；这时不如放弃这道题目的进一步优化，争取得到

50-60 分，再去解决其他题目。这种策略尤其对于难题、高档次考试有效。另外，复杂度记

号中的常数因子也是不可忽略的。例如搜索中剪枝本身的代价超过被剪掉的搜索代价，就不

如不剪。这也提醒我们，养成良好的编程习惯，降低常数复杂度，也是“骗分”的重要手段。

在信息学竞赛中，“**用空间换时间***”是常用的策略。这里我们再提出一个观点：**用运行**

**时间换编程时间**，**用尽时限** 中的每个 CPU 指令。

考虑一个问题：有 **O(nlogn) **的 A 算法但需要 200 行代码，而有 O(n 2 )的 B 算法只需要

70 行代码，而对于 60%的数据，n<1000；对于 100%的数据，n<100000. 我们需要做出一个

决策。采用 A 算法，至少得 60 分，可能用掉 40 分钟；采用 B 算法，100 分到手，可能用

掉 100 分钟。对于**不同类型的比赛**，我们应有不同的决策。对于 NOIP 这种其他题目较为简

单、这样的试题是压轴题的情况，可以先做其他简单试题，最后视剩下时间长短选择算法；

而对于 NOI 这种“难题集萃”类型的试题，如果其他试题没有思路，可以用较长的时间完

全解决该题；否则两道 60 分的题胜过一道 100 分的题。

总而言之，算法的选择与“得失”的衡量有关，这样本文所述的“用运行时间换编程时

间”就是正确的。例如 NOIP1999 第四题“拦截导弹”，要求输出最长不升子序列。这道题

有 O(n 2 )的动态规划算法，也有 O(nlogn)的基于二分搜索的算法。但原题 n<=1000，就没有

必要使用较为复杂且调试困难、容易出错的 log 级算法。所以，盲目优化时间复杂度不是可

取的行为。运用这些时间，可以解决其他问题，得到更高的分数。我们的目的，就是找到“时

间复杂度”与“编程复杂度”的平衡点。

# 2

**静态查错**。这个是很重要的，也可以说是非常重要的。何谓静态查错，就是编完代

码之后，不去干其它事情，只是安静的从头到尾的把自己的代码阅读一遍，比如说普通的编

译错误、变量是不是打错了、数组开的够不够大、程序的逻辑性是不是还存在问题等等。这

个时候，一般是很容易发现错误的，并且还会有一种成就感。但是如果你编完之后去测样例，

可能样例是过了（因为样例是很弱的数据），但是其实程序仍漏洞百出，或者测样例都错了，

这个时候会严重影响你的心情，再去查错的话，事倍功半

# 3

**出测试数据**是个大学问。测试数据一般分为，小数据、大数据、极限数据等等。所

以我们一定要从这几个方面，各出几组测试数据。小数据可以手算，很容易出结果，相信是

OIer 最喜欢的。极限数据也是指那些边缘数据，比如说某个数据导致你数组越界、被 0 除

等等，一般很多题目都存在一两组这样的数据。大数据的话，一般是去检验程序是否超时间

和超空间，因为结果是否正确，真的很难手算出来，除非很离谱的错误

# 4

在科学研究意义上，时间复杂度的常数优化并不是十分重要的2。但在信息学竞赛中，

同样的复杂度为 O(n 2 )的程序，对于一组 n=5000 的数据，有的可能常数为 20，需要运行

1000ms，有的可能常数为 5，需要运行 500ms。这样，两个看似相同的算法，一个超时错误，

一个正确得分。所以，很多同学有“常数优化不重要，关键在算法3”的看法，是不正确的。

众所周知，好算法的设计不是人人都能完成，而常数优化的技巧可以在平时积累，注意训练，

考试时就能习惯的写出高效的代码。

在信息学竞赛中，常遇到程序运行超时的情况。然而，同一个程序设计思想，用不同

算法，会有不同的运行效率；而即使是同样的算法，由于在代码的细节方面设计有所不同，

执行起来效率也会有所不同。当遇到所需时间较长的问题时，一个常数级优化可能是 AC 的

关键所在。下面通过**实际测试**和**理论分析**，探索**常数时间优化**的方法策略。

# 5

**基本运行时间****5**，是指在准备计算的运算复杂度之外，只包括循环控制变量的加减与比

较所消耗的时间。要从实际运行时间中减去基本运行时间，才是这种运算真正的运行时间，

称为**净运行时间**。



```
#include<stdio.h>

int main(){ int i,j;

    double a,b,sum=0;

    for(j=0;j<20;j++){ //此处添加随机数产生

        a=clock();

        for(i=0;i<100000000;i++);//此处添加运算

        b=clock();

        printf("%lf\n",b-a);

        sum+=b-a;

    }

	printf("ans = %lf",sum/20.0);

	getch();

}
```

运行平均时间是：202.3ms。

**（**1）赋值运算

净运行时间 0.8ms，与基本运行时间 202.3ms 相比，可忽略不计，故以后将赋值运算作

为基本运行时间的一部分，不予考虑。

**（**2）加法运算

产生随机数

```
x=rand();
y=rand();
```

循环内加法：

```
t=x+y;
```

下面的各种简单运算只是更改运算符即可，不再写出代码。

净 运 行 时 间 41.45ms， 即 ： 在 1s 的 时 限 中 ， 共 可 进 行 

(1000-202.3)/ 41.45 * 10^8^=1.9* * 10^9^ 次加法运算，即：只通过循环、加法和赋值的运算次数不超过 1.9*10^9.。

而应用+=运算，与普通加法时间几乎相同，所以+=只是一种方便书写的方法，没有实质效果。同样的，各种自运算并不能提高效率。

**（**3）减法运算

净运行时间 42.95ms，与加法运算基本相同。可见，在计算机内部实现中，把减法变成

加法的求补码过程是较快的，而按位相加的过程占据了较多的时间，借用化学中的一句术语，

可以称为整个运算的“**速控步**”。当然，这个“速控步”的运行速度受计算机本身制约，我

们无法优化。在下面的算法设计中，还会遇到整个算法的“速控步”，针对这类情况，我们

要对占用时间最多的步骤进行细心优化，减少常数级运算次数。

**（**4）乘法运算

净运行时间 58.25ms，明显比加减法要慢，但不像某些人想象的那样慢，至少速度大于

加减法的 1/2。所以在实际编程时，没有必要把三个或更多的加法变成乘法，其实不如元素

乘常数来得快。不必“谈乘色变”，实际乘法作为 CPU 的一种基本运算，速度还是很快的。

以上四种运算速度都很快，比循环所需时间少很多，在普通的算法中，每个最内层循

环约含有 4-5 个加、减、乘运算，故整个算法的运行时间约为循环本身所需时间的 

**（**5）除法运算

净运行时间 1210.2ms，是四种常规运算中最慢的一种，耗时是加法的 28 倍，是乘法的

21.5 倍，确实如常人所说“慢几十倍”，一秒的时限内只能运行 8.26*10^7 次，不足一亿次，

远大于循环时间。所以，在计算时应尽量避免除法，尤其是在对时间要求较高的内层循环，

尽量不安排除法，如果整个循环中值不变，可以使用在循环外预处理并用一个变量记录，循

环内再调用该变量的方法，可以大大提高程序运行效率。

**（6**）取模运算

净运行时间 1178.15ms，与除法运算速度几乎相当，都非常慢。所以，取模运算也要尽

量减少。在大数运算而只要求求得 MOD N 的值的题目中，应尽量利用数据类型的最大允许

范围，在保证不超过 MAXINT 的前提下，尽量少执行 MOD 运算。例如在循环数组、循环

队列的应用中，取模运算必不可少，这时优化运算便十分重要。可利用计数足够一定次数后

再统一 MOD，循环完后再 MOD，使用中间变量记录 MOD 结果等方法减少次数。

![image-20221021222621366](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021222621366.png)

![image-20221021222631117](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021222631117.png)

![image-20221021222648460](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021222648460.png)

# 6

位运算的速度

**(**1）

**左移、右移**

```
x<<1; x>>1;
```

净运行时间无法测出，证明位运算速度极快。而使用自乘计算需要 64.1ms，自除运算需要 164.85ms，所以尽可能使用位运算代替乘除。

**（**2）逻辑运算

```
t=x|y; t=x^y; t=x&y;
```

净运行时间约 30ms，比加法运算（约 40ms）快较多，是因为全是按二进制位计算。但

**位运算优化**

加减与位运算关系并不大，所以利用位运算主要是利用左右移位的高速度。

在计算机内部，一切数据都是以二进制进行储存，其支持的最基本的元操作应该是布

尔逻辑运算，例如逻辑与(and)、逻辑或(or)、逻辑非(not)、逻辑亦或(xor)等等，这些运算的

实现，几乎可以说是直接与电路的基本元件逻辑门相对应起来，是计算机天生所最擅长的操

作，其执行速度无疑也是最快的。至于整数的四则运算等操作，是用众多逻辑门所搭建起来

的，加减法电路的逻辑门数量比较少，同样可以在较短的时间内进行运算，但如果像除法一

般逻辑复杂，电路也相应庞大，速度就很难以接受了。再到更复杂的浮点运算，速度也就更

慢。简而言之，在众多的 CPU 指令中，凡是在 bit 级别进行操作的，基本上都能够在一个

clock cycle中完成，例如位移(bit shift)、位扫描(bit scan)、逻辑运算等等，再加上加减法、

取补码等等简单的整数运算，组成了一个非常高速的指令集合。而巧妙地组合这些运算，往

往能取代一些原本缓慢的操作，获得速度上的极大提升。这里列出一些我所收集或者原创的 C 代码位运算技巧

```
读取第 k 位： a>>k&1
读取第 k 位并取反： ~a>>k&1
将第 k 位清 0： a&=~(1<<k)
将第 k 位置 1： a|=1<<k
将第 k 位取反： a^=1<<k
将第 k1~k2 位反转： a^=((1<<(k2-k1+1))-1)<<k2
是否恰好只有一个 true： !(x&(x-1))&&x
判断是否有两个相邻的 true： x>>1&x
是否有三个相邻的 true： x>>1&x>>2&x
计算绝对值
int abs(int x){
    int y=x>>31;
    return (x+y)^y;
}
求较大值
int max(int x,int y){ 
    int m=(x-y)>>31;
    return y&m|x&~m;
}
x 与 a,b 两个变量中的一个相等，现在要切换到另一个
x^=a^b;

不使用额外空间交换两个变量
void swap(int& x,int& y){
	x^=y;y^=x;x^=y;
}

计算两个整数的平均数，不会溢出：
int ave(int x,int y){
	return (x&y)+((x^y)>>1);
}
```

# 7

![image-20221021223234385](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021223234385.png)

# 8

有时为了程序效率的提高，需要牺牲简洁性、直观性，但在信息学竞赛中是必要的。

对一个需要反复使用且值不变的表达式，可以将其赋值为一个变量，需要时直接引用。

例如字符串的长度l=strlen(a);，可以先用 表示出来，以后直接应用 l 即可。

而且字符串string a； 不要使用 a.size(),使用a.length();

# 9

在信息学竞赛中，空间复杂度往往是选手容易忽略的方面。我们常说“用空间换时间”，

于是很多选手不注重空间复杂度优化，盲目开大数组、高维数组，程序运行起来动辄 20M，

是完全没有必要的。尤其是盲目开高维数组，还会造成时间复杂度的升高。

一个好端端的程序，却在内存占用上被卡住，出现了 Memory Limit Exceed，就得不偿

失了。所以我们进行空间复杂度优化，目的就是要“恰好”利用题目中所给的内存，不要造

成空间浪费。

下面给出常用变量的空间占用情况，供参考。

（1）INT（long）类型占 4 字节

（2）Long long int 或 int64 类型占 8 字节

（3）一个 int a[1000000]的数组占 4M，通常空间限制为 64M 时，最多开 15 个这样的

数组。若要开规模为 10000000 的 int 数组，占用达到 40M，一定只允许一个。

（4）一个 int a[1000][1000]的二维数组同样占 4M。一个 int a[2000][2000]的二维数组占

16M，最多开 3 个。二维数组最多允许 3000*3000 的规模，且只有一个。

（5）在使用空间时，一定要留出 10M 左右的空闲空间，不要将允许空间挤满，在大内

存程序调试时可以使用工具查看内存实际占用情况，不要铤而走险打“擦边球”。

不可能只有一个数组占用内存，要综合考虑整个程序。

（6）如果是允许 256M 内存，一维数组最多到 5*10^7^，即 int a[50000000]，如果两个

最多到 3 * 10^7^。二维数组最多开到 int a[7500 ] [7500]，或两个 5000 * 5000 的数组。

这里的计算都考虑了余量，不能紧逼上限，以免发生意外。

下面是笔者一些空间复杂度优化的经验：

（1）将二维带参变量的数组用结构体一维数组代替

（2）使用滚动数组，将无用的空间及时释放

（3）高精度运算尽量在原数基础上运算

（4）搜索时在原来状态基础上修改，少引入中间状态、临时状态

（5）队列使用循环队列，采用“MOD 队列长”的办法解决，不要只有 begin, end 两个

指针，造成使用过的空间浪费。尤其是广度优先搜索中注意。

（6）少使用链表等非线性结构，减少定位域的个数

以上这些降低空间复杂度的经验，由于减少了重复计算和数据复制，还可以提高时间效

率，这在搜索类问题中尤其见效。

但我们仍然强调，除非题目的最大内存使用数不确定，尽量在初始化时一次性申请好所

有内存，而不是使用 malloc 和 free 去动态申请内存。因为这样增加了编程复杂度，况且动

态申请内存也会出现 MLE 的情况，还不如直接估计好最大可能达到的，或最大能够承受的

内存，利用静态内存进行运算。

在避免数组越界方面，尽量遵守这些规则：

（1）数组规模比测试数据的最大规模略大，如 n=10000 的试题，数组可以开到 10005

（2）尤其是 C 语言，减少 0 位的使用（高精度运算除外），从 1 使用到 n，符合自然思

考习惯，便于输入输出，不易出现数组元素正负 1 的问题，并以 0 位置为“哨兵”，

放上 0 或者特殊标记，既不会在状态转移时出现数组越界，又避免了初始位置的

特殊讨论，何乐而不为？

（3）在定义数组时为今后的编程提供方便，减少特殊情况数，而不是到具体处理时再

解决边界问题、特殊处理问题，这样既浪费时间又容易出错。

当然，某些题目确实状态空间庞大，无法使用“小修小补”的常数空间复杂度优化解决

问题，那么就要考虑“**状态压缩**”，就是**将无用的空间及时释放**。从这个意义上说，动态规

划中的滚动数组、广度优先搜索中的循环队列，都是状态压缩的具体算法。

# 10

竞赛时间是有限的，为了解决尽可能多的试题，需要降低编程复杂度，用尽可能短的代

码达到较好的目的。

降低编程复杂度，这里给出笔者的几条经验：

（1）减少使用指针，尽量使用数组

（

2）保持程序逻辑清楚，变量名、函数名明确

（

3）定义常量，将最大规模、MAXINT、数学常数等用#define 或 const 预定义。

（

4）注意缩进，层次清晰

（

5）对于复杂的分类问题，将各种类别表示在数组中，使用循环进行统一判断，而不

是分别判断处理。例如走棋盘类问题中四个方向的处理，表达式处理中的不同运

算符，搜索问题中的相似选择支，模拟类问题中的数据读入、不同操作符数学模

型的转化，字符串处理中的功能相似的符号，都应该在数组中进行归类处理，这

样程序的可移植性增强，可以快速添加、删除、修改类别，便于调试时对不同类别同时修改，还不容易出错。

降低编程复杂度，很重要的便是**模块化思想**。模块化思想的最大优点就是，**逻辑清晰、**

**便于调试**。在本文“调试程序”一节中会体现模块化的巨大优势。

（1）将程序的各大功能板块，如输入、运算、输出分开编写。

（2）每一个部分解决一个问题，不要“眉毛胡子一把抓”，尽量保持各个部分之间的独

立性，尤其是变量不要反复引用，平行的中间变量尽量不要重叠，在程序段的开

始时注意初始化（尤其是最大最小值之类）。

（3）将一些成型的、经典的算法在考前练习熟练，考试时直接用函数写出来，不需要

再多考虑、调试。包括排序、并查集、基本数学算法等，在本文“应该学习的内

容”中有所介绍。

（4）这里要指出，模块化不是将一些较小的、反复用到的函数单独拿出来，因为这样

虽然逻辑清晰，但损失了时间复杂度，可以使用 Ctrl+C 的办法解决，反正源代码

的长度是没有限制的

# 11

做题思路，正着想和反着想可能思路完全不一样

![image-20221021224216347](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021224216347.png)

