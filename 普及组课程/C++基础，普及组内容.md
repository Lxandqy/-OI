# 1.初识C++

其实C语言可以用来比赛，但是C++有很多优秀的库，很多优秀的工具，我们可以直接拿来使用，所以C语言用来做启蒙使用是很适合的，但是比赛还是以C++为主

## 1.1C++的输入输出

先来看一个最基础的C++代码

```
#include<iostream>


int main(){

	std::cout << "Hello World";
	return 0;
}
```

同样的我们分析一下每一句话是干啥用的。

1. #include<iostream> 就是包含我们iostream这个工具库（用来输入输出的）
2. std::cout << "Hello World"; 在我们的屏幕上打印出 Hello World  = 我们的printf
   

C++改进了C语言的输入输出，没有了变量的概念，系统自动识别你的变量。

```
int a;char b;long long c;
cin >> a >> b >> c;
```

像这样就输入了a，b，c。但是C++的输入因为自动识别的关系，他会匹配所有类型，所以会比C语言的慢上7，8倍，所以大家还是使用C语言的比较好。

```
cout << a << " " << b << " " << c;
```

输出也是自动识别输出，所以大家只需要记住有这个用法就行了。

还有换行，在C++中换行是

```
cout << endl; //这样就是换行，英文单词的 endline的简写
cout << '\n'; //这样写也是可以的，沿用了ASCii码的翻译
```

保留小数就变得极其复杂了

```
cout<< fixed << setprecision(2) << sum << endl; //例如这样子就将后面的数字保留两位小数输出。
```

其他的东西倒是没什么改变，也不会用到

**有人会好奇，老师为什么前面加了 std::，为什么我不加std::编译都过不了！**

现在我告诉你，在C语言中，我们对于一个变量不能取相同的名字，C++为了解决这个问题，特别出了一个叫做**命名空间**的东西。

```
namespace 名字{
	//变量，函数等
};
```

例如

```
namespace aa{
	int a = 1;
};
我想要使用的话就必须 aa::a;
printf("%d",aa::a);
```

我们可以读作是空间aa里面的整形变量a

所以很多工具都是来自命名空间std的 所以我们想要使用有以下三种方式

```
1. std::cout
或者
2. using namespace std;
cout 
第二种是使用命名空间std的意思，那么使用了后，就可以不用写std::
但是注意，最好不要同时使用好多个命名空间，不然会导致错误
3.using std::cin;
第三种就是点名使用某个命名空间的某个函数或者变量
```

### 练习：

1. 以下代码是否合法？

   ```
   #include<iostream>
   
   using namespace std;
   
   int main(){
   	int a,b,c;
   	cin >> a >> b >> c;
   	cout << a << b << c;
   	return 0;
   }
   ```

   ```
   #include<iostream>
   
   using namespace std;
   
   namespace A{
   	int a = 1;
   	int b = 2;
   };
   
   namespace B{
   	int a = 4;
   	int b = 3;
   };
   using A::a;
   
   int main(){
   	cout << a << '\n';
   }
   ```

   ```
   #include<iostream>
   
   using namespace std;
   
   namespace A{
   	int a = 1;
   	int b = 2;
   };
   
   namespace B{
   	int a = 4;
   	int b = 3;
   };
   using A::a;
   using B::a;
   
   int main(){
   	cout << a << '\n';
   }
   ```

   ```
   #include<iostream>
   
   using namespace std;
   
   namespace A{
   	namespace B{
   		int x = 10;
   	}
   	int a = 1;
   	int b = 2;
   };
   using A::B::x;
   
   int main(){
   	cout << x << '\n';
   }
   ```
   
   2.以下哪种功能没有涉及 C++语言的面向对象特性支持：（ ）。（CSP 2022 入门级第一轮）
   
   A. C++中调用 printf 函数
   
   B. C++中调用用户定义的类成员函数
   
   C. C++中构造一个 class 或 struct 
   
   D. C++中构造来源于同一基类的多个派生类

## 1.2 C++中的字符串

C语言中的字符串只能通过字符数组来使用，C++给他单独成立了一个变量类型string，string是一个结构体变量，里面包含函数，变量等东西，string不能用scanf来输入，因为他是属于C++的，第一堂课我们就讲过，C语言不能使用C++的内容，但是C++可以使用C语言的内容。

```
string a = "123123";
cout << a << endl; //输出123123
cin >> a; //输入asd
cout << a << endl; 输出asd，因为自动把asd后边一个改成了'\0'
cout << a[0] << " " << a[1] << " " << a[2] << endl; //输出 a s d
```

**他的核心就是相当于一个可变长的字符数组**，一开始他是空字符串，所以他字符数组的大小是 0，当他往里面填了两个字符后，会创建一个新的大小为2的字符数组，然后再把这两个放到这里面，所以当我们的字符串 a 里面字符有 3个的时候，我们不能使用 a[3]，因为此时大小为3，只能使用 a[0 ~ 2]。同样的，'\0'是他停止符。

```
string a = "123123";
cout << a << endl; //输出123123
cin >> a; //输入asd
cout << a << endl; 输出asd，因为自动把asd后边一个改成了'\0'
cout << a[0] << " " << a[1] << " " << a[2] << endl; //输出 a s d
```

**字符串最重要的就是方便**，**字符串可以拼接字符或者字符串**，但是字符串不能拼接数字或者其他类型。那么他到底是如何拼接的呢？他是通过创建一个更大的字符数组，把第一个字符串的内容放进去，再把第二个字符串或者字符放进去，所以他拼接的需要的复杂度为 O(n)。

```、
string a = "a";
a += "b";
a += 'c';
cout << a; //输出abc
```

string不像字符数组一样专门需要一个strlen函数去判断字符串大小，string里面内部有两个函数叫做 size() ,length(),可以直接输出他的答案，因为他是结构体的变量，所以使用他的函数如下

```
string a = "123";
cout << a.length() << " " << a.size() << endl; //输出 3 3
```

**string还需要注意的一些事项就是同样的不能输入空格和换行**，但是他会自动识别，自动跳过空格和换行，不像scanf会把换行当作字符读入，如下题。
我们发现题目不确定有几行字符串，字符串中还可能出现空格，那么对于下面的题目我们可以使用如下代码

```
while(cin >> a){ //不停的读入，当遇到文件结束的时候返回0，人为运行的时候使用control + z来表示文件结束
	sum += a.length();
}
同意的scanf输入字符串也可以达到这种目的，scanf遇到文件结束的时候会返回-1
while(scanf("%s",a) != -1)
while(~scanf("%s",a));
while(scanf("%s",a)!= EOF) //end of file 文件结束的意思
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221211142044671.png" alt="image-20221211142044671" style="zoom:67%;" />
string还有一个很好的有关函数是在#include<cstring>头文件里的函数，getline( ) 读取一整行（包括空格）
他的使用方法很简单如下

```
getline(cin,a);//读入一整行到字符串 a 里边
```

### 1.2.1 示例题目

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209144354719.png" alt="image-20221209144354719" style="zoom:67%;" />
题目说只输入一行，倘若我们用字符数组来写是比较棘手的，但是如果通过string的getline来写的话，我们只需要循环从头到尾即可。

### 练习：

1. 请问以下哪些合法？如果合法答案是什么？

   ```
   string a = "";
   a[2] = 'a';
   cout << a;
   ```

   ```
   string a = "123456";
   a[0] = '3';
   cout << a;
   ```

   ```
   string a = "123";
   printf("%s",a);
   ```

   ```
   string a = "12345";
   cin >> a + 2; //输入123
   cout << a;
   ```

   ```
   string a = "12345";
   cout << a + 2;
   ```

   ```
   string a = "123123"
   a[3] = '\0';
   cout << a + 1;
   ```

2. 一个字符串中任意个连续的字符组成的子序列称为该字符串的子串，则字符串 abcab 有（ ）个内容互不相同的子串。（ CSP-J 2022 第一轮）

   A. 12 	B. 13 	C. 14 	D. 15 

3. 若串 S =$\texttt{copyright}$，其子串的个数是（ ）。(NOIP 2017 普及组初赛)
    A. 72         B. 45        C. 46         D. 36

## 1.3 文件操作

## 1.3.1 字符指针

在讲文件操作之前我们需要完善指针的知识。

在我们之前的学习中，我们尝试过 int *p = 123;这样子写是不行的，因为123是整形常量，所以他不可以被指向，首先我们考虑两个点，是因为整形不能被指向还是常量不能被指向。我们做两个试验:

```
const int a = 100;
int *p = &a;
```

以上代码，我们发现编译成功，所以常量是可以被指向的，但是常量不可以被修改，也就是说 *p = 10，这样是不允许的。

```
int *p = (int *)100;
```

以上代码我们发现编译成功，因为我们把100强制转换成了指针，由于指针里存的是内存地址，所以现在的100才表示的是地址。

以上结论得出，指针其实是可以指向常量的。

我们讲过，在C/C++中字符串的本质其实是字符数组，那么我们按照字符串的形式去输出字符串数组的地址的时候，会输出字符数组里面存储的数组，当我们使用指针去指向这个字符数组的时候，我们能否输出呢？

```
#include<stdio.h>
int main(){
	char a[10] = "123123";
	char (*p)[10] = &a;
	printf("%s ",*p);
	(*p)[0] = 'a';
	printf("%s",p);
	return 0;
}
```

我们发现以上代码成功输出了123123 a23123，所以是没有问题的，并且能够成功修改此字符数组上的值，也就是说现在的字符串是字符串变量。
我们都知道数组的本质其实就是指针，数组其实也是由指针实现的，只不过指针指向一个的地址，数组一下子申请了许多个连续的地址，由于字符数组可以直接存储字符串那么我们尝试能否用字符指针直接指向字符串。

```
#include<stdio.h>
int main(){
	char *p = "123123";
	printf("%s",p);
	return 0;
}
```

我们发现以上代码成功输出了 123123。

```
#include<stdio.h>
int main(){
	char *p = "123123";
	printf("%s\n",p);
	*p = 'a';
	printf("%s",p);
	return 0;
}
```

但是当我们修改的时候，会出现死循环或者错误的情况，说明此时此刻是不可以修改的，也就是说现在的字符串是字符串常量，所以现在的char * 等价于
const char *。

## 1.3.2 重定向

在我们C/C++中是可以在程序中选择文件输入或者输出的，倘若我们不选择系统默认在运行后的黑框框控制台输入和输出。那么我们想要让输入从系统的文件输入，输出到系统的某个文件里我们就要用到重定向输入输出
所谓重定向输出，就是可以把原本只是输出在控制台的字符，输出到你指定的路径文件中。(输入类似，就是从指定的文件中读取，而不是读取在控制台中的输入。)重定向函数可以在任何时候开启、关闭。

函数名：freopen

标准声明：FILE *freopen( const char *path, const char *mode, FILE *stream );

所在文件： <stdio.h>

参数说明：

path: 文件名，用于存储输入输出的自定义文件名。

mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。

stream: 一个文件，通常使用标准流文件。

返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。

功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。

```
#include<iostream>
#include<stdio.h>
using namespace std;
int main()
{
	//注意freopen()的地址格式！必须是双斜杠\\ !!!! 
	freopen("D:\\CZHSoftware\\C语言\\Dev编程h\\freopen\\freopenTest.txt","w",stdout);
	freopen("D:\\CZHSoftware\\C语言\\Dev编程h\\freopen\\freopenTest1.txt","r",stdin);
	int a=0,b=0;
	cout<<"hello world"<<endl;
	cin>>a>>b;
	cout<<"a+b="<<a+b<<endl;
	fclose(stdin);   //关闭读写
	fclose(stdout);  
	return 0;
} 
//如果文件里面的是 1 2
//输出以下
//a+b=3
```

## 1.4 C++中的结构体

C++的结构体也可以使用struct，但是我们一般使用的是class（类）。使用方法和结构体没啥大区别，不过我们只需要知道有这个概念即可。
我们会发现老师里面加了一个public的东西，这个就是C++新的一个概念，叫做权限，可以让别人使用，或者不让人使用。

```
class node{
	int x,y;
	public:
	void speak(){
		printf("我是帅哥");
	}
}a;
a.speak();
```

**权限一共有三种 ： public、private、protected，分别是公共的，私密的，受保护的。**
使用方法就是 public： 表示从这里开始往下的代码都是公共的
那么三者的区别现在只能做个简单的介绍，大家可以试试把上面代码的public 改成 private 和 protected 或者不写试一试，我们发现代码连编译都过不去了，说明想要在外部使用的话只能使用 public: ，注意当你不写的时候默认为 private: 。

# 2. 位运算基础

## 2.1 进制转换

平常使用的较多的是十六进制，十进制以及二进制，他们之间的转换也尤为重要。

**注：十六进制的为是 0 ~ 9，A ~ F，A代表10，F代表15，一共16个状态。**

我们可以发现，十进制转换成其他进制或者其他进制转换成十进制比较简单。

所以例如 十六进制转换成二进制，可以先由十六进制转换成十进制，十进制再转换成二进制。

这里给出两个例子

```
void Ten2Two(int n){
	int x = 1;
	while(x <= n){    //先确定最高位
		x *= 2;
	}
	x /= 2;
	while(n){
		if(n >= x) printf("1"),n -= x;
		else printf("0");
		x /= 2;
	}
	while(x){    //如果x不为1，也就是说后面都是0
		printf("0");
		x /= 2;
	}
}

int Sixteen2Ten(string a){
	int sum = 0;
	int x = 1;
	for(int i = a.length() - 1; i >= 0; i--){
		if(a[i] >= '0' && a[i] <= '9'){
			sum += (a[i] - '0') * x; 
		}else{
			sum += (a[i] - 'A' + 10) * x;
		}
		x *= 16;
	}
}
```

## 2.2 位运算

位运算，顾名思义就是对一个进制的数字的每一位进行操作。

例如我要拿到十进制$x$的第$y$位怎么拿，不过我们想要拿到十进制的第一位很容易，不过就是 % 10，去掉第一位就是 / 10，以此类推就是 $x$  / 10^y^ % 10 就能拿到第$y$位。同样的像二进制，我们想要拿到二进制$x$的第$y$位怎么拿，$x / 2^y$ % 2，不过在二进制下有按位运算符，例如拿到$x$的第一位我们可以使用按位与运算&，$x$ & 1，拿到第$y$位就是$x$ & (1 << $y$) ，同样的我们也可以去掉后$y - 1$位，想要去掉第一位我们可以使用右移运算 >>，那么去掉后$y - 1$位就是 $x$ >> ($y - 1$)那么再拿第一位就是拿到第$y$位，所以总操作就是$x$ >> ($y - 1$) & 1

### 例题

![image-20230130164957158](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230130164957158.png)


```
#include<bits/stdc++.h>
using namespace std;
int main(){
        int x;
        cin >> x;
        int sum = 0;
        for(;x;){
            if(x & 1) sum++;
            x >>= 1;
        }
        printf("%d\n",sum);
}
```

# 3. 枚举

## 3.1 简介

枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

## 3.2 要点

### 给出解空间

建立简洁的数学模型。

枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素？

### 减少枚举的空间

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

### 选择合适的枚举顺序

根据题目判断。比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。

最简单的例子：找到20，100中最小的质数

我们想要找到其中的答案，我们需要枚举 20以下的数字和100以上的数字吗？完全不需要！

```
for(int i = 20 ; i <= 100; i++){
	int sum = 0;
	for(int j = 2 ; j < i; j++){
		if(i % j == 0){
			sum++;
		}
	}
	if(sum == 0){
		printf("%d\n",i);
		break;
	}
}
```

## 3.3 例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202130646796.png" alt="image-20221202130646796" style="zoom:67%;" />
**思路：**题目让我们判断最多有多少动物，当脚的数量是一定的时候，鸡越多越好。判断最少有多少动物，当脚的数量是一定的，兔子越多越好，因为脚最多只有32768，所以最多只有32768 / 4 只兔子，那么我们假设兔子为 0只，1只，2只.....a / 4只得时候判断剩下的脚的数量是不是2的倍数即可。

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	int maxn = 0;
	int minn = 1000000;
	for(int i = 0; i <= 20000; i++){ //代表兔子的个数,那么 (a - 2 * i)就是鸡脚的个数
		if((a - 2 * i) % 4 == 0 && (a - 2 * i) >= 0){
			if(maxn < i + (a - 2 * i) / 4){
				maxn = i + (a - 2 * i) / 4;
			}
			if(minn > i + (a - 2 * i) / 4){
				minn = i + (a - 2 * i) / 4;
			}
		}
	}
	if(minn == 1000000){
		printf("0 0");
	}else{
		printf("%d %d",minn,maxn);
	}
	return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202131153328.png" alt="image-20221202131153328" style="zoom:67%;" />

**思路：**我们知道正方形的长宽是一样的，建立坐标系，假设我们组成正方形的最左上的方格的坐标是$x，y$，距离最下方距离是$a$，距离最右方的距离是$b$，什么时候能组成正方形？我们可以设边长为$1，2，3....a...b$的时候是否满足情况，如果a > b的话，我们的边长最多取到 $b$，如果$a <= b$的话，边长最多取到$b$。
什么时候能组成长方形呢？我们知道长方形的长宽可以不同，那么长可以取 $1，2.....a$，宽可以取 $1,2.....b$。所以最多可以取 $a * b$ 个长方形。

## 3.4 枚举中的位运算

现要求我们解决一个问题：现在有10个苹果，我们有$x$元，每个苹果有一定的价格和一定的价值，请问如何选择能获得最大价值。对于每一个苹果，我们有两种选择，选或者不选。对于10个苹果一共有$2^{10}$种选择，对于所有情况，我们只需要判断一下，哪种情况价值最高即可，但是我们该如何去把这些情况给写出来呢？对于这种每个物品只有两种情况我们就可以使用二进制来写题。对于一个数字$x$，把他写成二进制形式，每一位都可以当做一个苹果，0可以代表这个苹果没有取，1代表这个苹果取了，那么对于所有情况就是在 $0$ ~ $2^{10}$。

![image-20230130135237713](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230130135237713.png)



```
#include<bits/stdc++.h>
using namespace std;
const int N = 25;
int v[N],w[N];
int main(){
    int n,x;
    scanf("%d %d",&n,&x);
    for(int i = 1; i <= n; i++){
        scanf("%d %d",&v[i],&w[i]);
    }
    int maxn = 0;
    for(int i = 0; i < (1 << n) - 1; i++){   //枚举n个苹果的状态
        int s = 0,y = 0;
        for(int j = 0; j < n; j++){  //查看每个苹果的状态
            if(i & (1 << j)){
                s += w[j];
                y += v[j];
            }
        }
        if(s <= x){
            if(maxn < y) maxn = y;
        }
    }
    printf("%d\n",maxn);
}
```

### 练习：

1. 以比较作为基本运算，在 $N$ 个数中找出最大数，最坏情况下所需要的最少的比较次数为 （ ）。（CSP 2021 入门级第一轮)
   A. $N^{2}$ 	B. $N$	 C. $N-1$	D. $N+1$

# 4. 模拟

## 4.1 简介

模拟就是用计算机来模拟题目中要求的操作。

模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。

## 4.2 技巧

写模拟题时，遵循以下的建议有可能会提升做题速度：

- 在动手写代码之前，在草纸上尽可能地写好要实现的流程。
- 在代码中，尽量把每个部分模块化，写成函数、结构体或类。
- 对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 "YY-MM-DD 时：分" 把它抽取到一个函数，处理成秒，会减少概念混淆。
- 调试时分块调试。模块化的好处就是可以方便的单独调某一部分。
- 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

## 4.3 例题

**题目**：一只长度不计的蠕虫位于 英寸深的井的底部。它每次向上爬 英寸，但是必须休息一次才能再次向上爬。在休息的时候，它滑落了 英寸。之后它将重复向上爬和休息的过程。蠕虫爬出井口需要至少爬多少次？如果蠕虫爬完后刚好到达井的顶部，我们也设作蠕虫已经爬出井口。

**解题思路**：直接使用程序模拟蠕虫爬井的过程就可以了。用一个循环重复蠕虫的爬井过程，当攀爬的长度超过或者等于井的深度时跳出。

```
#include <stdio.h>

int main(void) {
  int n = 0, u = 0, d = 0;
  scanf("%d%d%d", &u, &d, &n);
  int time = 0, dist = 0;
  for(;1;){  // 用死循环来枚举
    dist += u;
    time++;
    if (dist >= n) break;  // 满足条件则退出死循环
    dist -= d;
  }
  printf("%d\n", time);  // 输出得到的结果
  return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202155220069.png" alt="image-20221202155220069" style="zoom:67%;" />
**思路:**用数组套字符数组，就可以存下一个矩阵的雷区，那么对于一个非地雷格，我们只需要取判断一下他8个位置的相邻格子有地雷。

```
#include<bits/stdc++.h>
using namespace std;
bool a[105][105];//一张地图，有雷为一，无雷为零 
int main(){
    memset(a,0,sizeof(a));//地图最开始清空 
    int n,m;
    char tmp;
    cin>>n>>m; 
    for(int i=1;i<=n;i++)//读入地图 
    {
        for(int j=1;j<=m;j++) {
            cin>>tmp;//读入每一个点 
            if(tmp=='*') a[i][j]=1;//如果是地雷就将这个点设为一 
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]==1) printf("*"); //如果是地雷不用输出数字 
            else{
                printf("%d",a[i+1][j+1]+a[i+1][j-1]+a[i+1][j]+a[i][j+1]+a[i][j-1]+a[i-1][j+1]+a[i-1][j]+a[i-1][j-1]);
                //将旁边的雷加起来输出 
            }
        }
        printf("\n");
    }
    return 0;//愉快的结束了主程序 
}
# 直接爆搜一遍就行了，一共就100*100次，不会超时
```

# 5. 递推

## 5.1 简介

[递推算法](https://baike.baidu.com/item/递推算法/2025952?fromModule=lemma_inlink)是一种用若干步可重复运算来描述复杂问题的方法。递推是序列计算中的一种常用算法。通常是通过计算前面的一些项来得出序列中的指定项的值。

## 5.2 示例

**题目**：[植树节](https://baike.baidu.com/item/植树节/419569?fromModule=lemma_inlink)那天，有五位同学参加了植树活动，他们完成植树的棵树都不相同。问第一位同学植了多少棵时，他指着旁边的第二位同学说比他多植了两棵；追问第二位同学，他又说比第三位同学多植了两棵；... 如此，都说比另一位同学多植两棵。最后问到第五位同学时，他说自己植了10棵。到底第一位同学植了多少棵树？

**分析**：设第一位同学植树的棵树为$a_1$欲求$a_1$需从第五位同学植树的棵数$a_5$入手，根据“多两棵”这个规律，按照一定顺序逐步进行推算：

(1) $a_5$=10;

(2) $a_4$=$a_5$+2=12;

(3) $a_3$=$a_4$+2=14;

(4) $a_2$=$a_3$+2=16;

(5) $a_1$=$a_2$+2=18;

## 5.3 技巧

- 递推算法总会是有一些规律的，根据旧状态推导出新状态。
- 需要特别注意边界问题，递推很多时候会出现求方案数等注意是否要开long long或者高精度
- 注意初始化问题，第一次开始的状态

## 5.4 例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202161209767.png" alt="image-20221202161209767" style="zoom:67%;" />
**思路：**蜜蜂可以从哪些路走到蜂房$m$，我们发现它可以由$m - 1$,$m - 2$走过来，递推式就为$a[m] = a[m - 1] + a[m - 2]$，假设我们知道走到$m - 1$，$m - 2$的方案数我们就可以求出走到$m$的，我们继续往前推我们发现我们知道点 $n$的方案数是$1$，因为点$n$是起始位置，那么$n + 1$的方案数是$n$的方案数，因为$n - 1$不存在，通过$n,n + 1$我们能推导出$n + 2$最后推导出$m$的。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221213102314560.png" alt="image-20221213102314560" style="zoom:67%;" />
**思路：**第 $n$ 层楼梯可以由 第$n - 1$层楼梯，第$n - 2$楼梯走过来，那么我们可以找到递推式为 $a[i] = a[i - 1] + a[i - 2]$，现在的目标就是要找到已知的情况，我们发现它是由第$0$层开始走，那么第$0$层肯定是$1$，第$1$层肯定也是$1$，我们就可以从$0，1$推出$2$再推出$3$ .....

# 6. 前缀和/差分

## 6.1 前缀和

### 前置知识

数学中有一个很形象去代表一些连续数字的和的公式如以下公式

${ \sum_{i = 1}^{n}} a_i $ 这个式子就代表 $a_1 + a_2 + .... + a_{n - 1} + a_n$

### 简介

前缀和可以简单理解为「数列的前$n$项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。

### 6.1.1 示例1 一维前缀和

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221110155156470.png" alt="image-20221110155156470" style="zoom:67%;" />

**思路**:倘若我们对于$m$个询问每次都要求一遍  $a_s + a_{s+1}...a_e$ 那么复杂度大概是在 $o(n*m)$，如果我们用一个数组$b$ 对于数组下标为 $i$ 的用来存储

${ \sum_{j = 1}^{i}} a_j $ 那么对于  $a_s + a_{s+1}...a_e$  只需要用 $b_e - b_{s - 1}$ 来表示。所以时间复杂度变成了 $o(n + m)$

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202162215620.png" alt="image-20221202162215620" style="zoom:67%;" />
**思路：**如果我们把每个相乘都求出来的话，复杂度接近$O(n^2)$超时了，但是我们想到了乘法加法里面的分配律 $a_1 * (a_2 + a_3 + .. + a_n)$ = $a_1 * a_2 + a_1 * a_3 + ... + a_1 * a_n$所以最后就变成了求解$\sum_{i = 1}^{n}a_i*(\sum_{j = i + 1}^{n}a_j)$对于$\sum_{j = i + 1}^{n}a_j$ 我们只需要求解一个前缀和数组$b$，$b_i = \sum_{j = 1}^{i}a_j$，那么$\sum_{j = i + 1}^{n}a_j$ = $b[n] - b[j]$，所以最后复杂度变成了$O(n)$

### 6.1.2 示例2 二维前缀和

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117210000077.png" alt="image-20221117210000077" style="zoom:67%;" />
**思路：**查询最多有$200000$次，但是$n，m$都为$100$，所以如果我们用二重for循环去求和的话复杂度为 $O(n * m * q)$，考虑前缀和，假设我们预处理出来每一排的复杂度，这样我们可以把复杂度降为 $O(n * q)$ 倘若我们每次的查询能为 $O(logn)$或者$O(1)$就好了。所以有另一种方法就是二维前缀和，能够直接处理出矩形的前缀和。假设 $a[x][y]$求的是前 $x$列，前$ y$行的所有值的和。那么对于一个左上角的点为 $(x1,y1) $右下角的点位$(x2,y2)$的矩阵求和。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221229102016812.png" alt="image-20221229102016812" style="zoom:67%;" />
我们想要拿到如上图阴影面积

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221229102202756.png" alt="image-20221229102202756" style="zoom:67%;" />
我们可以先拿到如上图的阴影面积，也就是$a[x][y]$，然后再去减去多余的面积

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221229102415841.png" alt="image-20221229102415841" style="zoom:67%;" />
我们减去如上图的阴影面积，也就是$a[x2][y1]$

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221229102617038.png" alt="image-20221229102617038" style="zoom:67%;" />
我们再减去如上图的阴影面积，也就是$a[x1][y2]$

此时我们多减了一块面积也就是$a[x1][y1]$，我们再给他加上，这样子就能得到一开始的阴影面积了

最后我们通过$O(1)$的复杂度拿到了面积也就是 $a[x2][y2] - a[x2][y1] - a[x1][y2] + a[x1][y1]$

## 6.2 差分

### 解释

差分是一种和前缀和相对的策略，可以当做是求和的逆运算。

这种策略的定义是令![image-20221110194141153](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221110194141153.png)

### 性质

![image-20221110194201367](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221110194201367.png)



### 6.2.1 示例1 一维的差分

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221110194404960.png" alt="image-20221110194404960" style="zoom:67%;" />

**思路**:如果对于每次都For循环一遍进行修改的话 复杂度为 $o(n * m)$所以一定会超时，但是我们想一下给$a_s,a_{s + 1}....a_e$每个数都加上h，$a_{s + 1}$和$a_s$的相对大小没有改变，$a_{s + 1}$ 和 $a_{s + 2}$的相对大小也没改变.....$a_e$和$a_{e - 1}$的相对大小也没改变，相对大小改变的只有 $a_s$ 和 $a_{s - 1}$ 还有 $a_e$ 和 $a_{e + 1}$。那么它们之间的相对大小可以用他们的差值来代表，假设我们用 $b_i$来代表  $a_i$ 和 $a_{i - 1}$的相对大小，我们最后只需要改变 $b_s$ 和 $b_{e + 1}$ 的大小即可，给$b_s + h$ 给  $b_{e + 1} - h$。那么如何求最后的$a_i$的值呢，我们继续思考 $b_1$ = $a_1$ - $a_0$，$b_2$ = $a_2$ - $a_1$，$b_3$ = $a_3$ - $a_2$，我们发现 $a_i$ = ${\sum_{1}^{i}}b_i$，所以最后修改变成了 $o(m)$查询变成了$o(n)$ 最后总复杂度为 $o(n + m)$

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202163234237.png" alt="image-20221202163234237" style="zoom:67%;" />
**思路：**我们如果用循环暴力模拟的话，复杂度大约在$O(n^2)$，好在我们学过差分，倘若我想要把牌全部都打完，假设我用 $a$ 数组用来存每个位置的牌，用 $b$ 数组求$a$ 的差分数组，那么当我把 $a$ 的牌打完后 $b$ 数组中的每一个位置都变为 $0$，所以我只需要模拟如何让 $b$ 数组每个位置都变为 $0$ 即可，因为每一次只能连续的出一张牌，所以题目变成了，用最少的 -1 +1，将 $b$ 数组变为 $0$，那就变成了一个贪心的题目。

### 6.2.2 示例2 二维的差分

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117214520937.png" alt="image-20221117214520937" style="zoom:67%;" />
**思路**:如果每次修改都是遍历整个矩阵的话那么复杂度在 $O(n * m * q)$，如果对于每一列或者每一行维护一个差分数组的话那么复杂度在$O(n * q)$。所以倘若我们每次的查询能为 $O(logn)$或者$O(1)$就好了。所以有一种方法叫做二维差分，就是对于矩形有一种二维差分。

$a[][]$数组是$b[][]$数组的前缀和数组，那么$b[][]$是$a[][]$的差分数组

原数组： $a[i][j]$

我们去构造差分数组： $b[i] [j]$

使得$a$数组中$a[i][j]$是b数组左上角$(1,1)$到右下角$(i,j)$所包围矩形元素的和。

如何构造$b$数组呢？

我们去逆向思考。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118110614135.png" alt="image-20221118110614135" style="zoom:67%;" />
假如我们给$b[x1] [y1] + c$。那么红色区域的值都会受到影响，但是我们想要 $x2$行以下，$y2$行往右都不受到影响，我们就要在差分数组这里减掉。

$b[x1] [y1] += c$，这个无可厚非。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118111728880.png" alt="image-20221118111728880" style="zoom:67%;" />
如果我们给$b[x2 + 1] [y1] -= c $我们会发现上图红色区域都会减去 $c$

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118111829317.png" alt="image-20221118111829317" style="zoom:67%;" />
如果我们给b[x1] [y2 + 1] -= c我们发现上图红色区域都会减去c

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118111915786.png" alt="image-20221118111915786" style="zoom:67%;" />
最后我们发现除了上图红色区域多减了$c$其他的都已经平衡了，所以我们只需要给 $b[x2 + 1] [y2 + 1] += c $           即可

因为我们一开始可以把数组 $a$ 全都当成 $0$，那么数组$b$也全都是$0$。最后通过修改$b$的值即可获得最初的$a$数组。 

# 7. 排序

## 7.1 基本概念

**作用**：排序的作用是将一个无序序列变得有序（从小到大排列或者从大到小排列）。

**稳定性**：排序的稳定性就是两个相同的数，在排序后他们的相对位置不改变。（相对位置就是在这个数的后边还是前边 例如 1 3 2​ 从小到大排序后变为 1 2 3，排序前 2是在 1 后边，排序后 2还是在 1后边，就是相对位置不变）。

**逆序对**：逆序对，数学术语，设 $A$ 为一个有 $n$ 个数字的有序集 ($n>1$)，其中所有数字各不相同。

如果存在正整数 $i, j$ 使得 $1 ≤ i < j ≤ n$ 而且 $A[i] > A[j]$，则 $<A[i], A[j]>$ 这个有序对称为 $A$ 的一个逆序对，也称作逆序数。

## 7.2 选择排序

**算法步骤**:对于下标为$i$的元素来说需要从$i - n$找到第1小的元素，最后和下标为$i$的元素进行交换
**稳定性：**由于存在交换所以选择排序一定是不稳定的  举例 4 4 2
**正确性：**第一次一定能够把当前序列的最大值移到最后，第二次一定能把当前序列的第二大值移到倒数第二个位置，以此类推，最多只需要$n - 1$次就可以排序完成。
**性质**：虽然也可以分为已知序列(已经排序好的数字)和未知序列，通过已知序列可以判断，整个序列中的最大值，第二大值.....或者最小值，第二小值.....
**时间复杂度:**$ o(n^2)$
**空间复杂度:** $o(n)$

```
void selection_sort(int n) {
  for (int i = 1; i < n; ++i) {
    int ith = i;
    for (int j = i + 1; j <= n; ++j) {
      if (a[j] < a[ith]) {
        ith = j;
      }
    }
    std::swap(a[i], a[ith]); //交换，algorithm工具库里的
  }
}
```

### 思考:能不能在交换途中求出逆序对个数？

## 7.3 冒泡排序

**算法步骤**:每一次遍历全部未排序的元素，前后比较交换
**稳定性：**稳定(由于每次是前后元素比较交换)
**正确性：**第一次一定能够把当前序列的最大值移到最后，第二次一定能把当前序列的第二大值移到倒数第二个位置，以此类推，最多只需要$n - 1$次就可以排序完成。|
**性质**：虽然也可以分为已知序列(已经排序好的数字)和未知序列，通过已知序列可以判断，整个序列中的最大值，第二大值.....或者最小值，第二小值.....
**空间复杂度**: $o(n)$
**时间复杂度**: $o(n^2)$ 

```
// C++ Version
for(int i = 1; i <= n - 1; i++){
		int id = i;
		for(int j = i; j <= n; j++){
			if(a[id] > a[j]){
				id = j;
			}
		}
		int s = a[i];
		a[i] = a[id];
		a[id] = s;
	}
	

```

### 思考:能不能在交换途中求出逆序对个数？

```
// C++ Version
// 假设数组的大小是n+1，冒泡排序从数组下标1开始
void bubble_sort(int n) {
  bool flag = true;
  while (flag) {
    flag = false;
    for (int i = 1; i < n; ++i) {
      if (a[i] > a[i + 1]) {
        flag = true;
        a[i] ^= a[i + 1];
        a[i + 1] ^= a[i];
        a[i] ^= a[i + 1];
        sum++;
      }
    }
  }
}

```

## 7.4 插入排序

**将排列序列分为未排序序列和已排序序列每次从未排序序列中选一个插入到已排序序列**
**算法步骤:**每次从$i$遍历到$1$ 若$ a[x] > a[j]$则$a[j]$移到$a[j + 1]$
**稳定性:** 稳定，和冒泡排序类似
**性质**：虽然也可以分为已知序列(已经排序好的数字)和未知序列，通过已知序列可以判断，已知序列中的最大值，第二大值.....或者最小值，第二小值.....
**时间复杂度:**最优复杂度 $o(n)$ 最坏复杂度 $o(n^2)$  平均复杂度$o(n^2)$
**空间复杂度**: $o(n)$

```
for(int i = 2; i <= n; i++){
		//把未知插入到已知
		for(int j = i - 1; j >= 1; j--){
			if(a[j + 1] < a[j]){
				int s = a[j + 1];
				a[j + 1] = a[j];
				a[j] = s;
			}else break;
		} 
	} 

```

### 思考:能不能在交换途中求出逆序对个数？

```
// C++ Version
void insertion_sort(int n) {
  // 对 a[1],a[2],...,a[n] 进行插入排序
  for (int i = 2; i <= n; ++i) {
    int key = a[i];
    int j = i - 1;
    while (j > 0 && a[j] > key) {
      a[j + 1] = a[j];
      --j;
      sum++;
    }
    a[j + 1] = key;
  }
}
```

## 7.5总结

区别：冒泡排序和选择排序在排序过程中可以确定整个序列的最大值和第二大值.....

插入排序在排序过程中只能确定当前已知序列的最大值和第二大值，无法整个序列的最大值和第二大值.....，只有全部排序完成之后才能够确定。

### 练习：

1. 现给你一个序列长度为$n$，我想要使用冒泡排序，请问我最多交换多少次可以确定当前序列的最大值(     )
   A. n - 1        B. n          C. n * (n - 1)         D. n * (n - 1) / 2
2. 现给你一个序列长度为$n$，我想要使用冒泡排序，请问我最多交换多少次可以确定当前序列的第二大值(     )
   A. n * (n - 1)        B.  2 * n - 4          C. 2 * n - 3        D. n * (n - 1) / 2
3. 现给你一个序列长度为$n$，我想要使用选择排序，请问我最多交换多少次可以确定当前序列的最大值(     )
   A.n - 1         B. n         C. n * (n - 1)         D. n * (n - 1) / 2
4. 现给你一个序列长度为$n$，我想要使用选择排序，请问我最多交换多少次可以确定当前序列的最二大值(     )
   A. n * (n - 1)        B. 2 * n - 4          C. 2 * n -3         D. n * (n - 1) / 2
5. 现给你一个序列长度为$n$，我想要使用插入排序，请问我最多交换多少次可以确定当前序列的最大值(     )
   A. n - 1        B. n          C. n * (n - 1)         D. n * (n - 1) / 2
6. 现给你一个序列长度为$n$，我想要使用插入排序，请问我最多交换多少次可以确定当前序列的第二大值(     )
   A. n * (n - 1)        B. 2 * n - 4          C. n * (n - 1)         D. n * (n - 1) / 2

## 7.6 关于排序的函数

这个函数是在我们的 algorithm 库里面的一个函数，让排序的复杂度在$o(nlogn)$左右
**使用方法如下**：
![image-20221117171117531](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117171117531.png)
![image-20221117171132735](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117171132735.png)

上图是sort函数的源码，有两种，我们先说第一个，如图所示第一个参数是 _RaIter类型的，那么对于数组来说的话，就是我们想要排序第一个数的首地址，第二个参数对于数组来说就是想要排序最后一个数字的末尾地址

```
int a[100];
sort(a,a + 99 + 1); //a + 99是第99个数字的首地址，再+1就是末位地址
//这样就把数组中的0~99的位置从小到大排序。
```

对于第二个sort来说他多了一个参数，那么这个参数是用来传递我们的函数的，意味着我们可以按照自己的想法去排序使用方法如下，相当于我们自己去写一个函数告诉我的 sort 函数 如何排序才是对的，所以一般 函数返回的参数是 bool 或者 int。

```
bool cmp(int a,int b){
	return a < b;
}
sort(a,a + n,cmp);
//这样就可以让我们的数组从小到大排序

bool cmp(int a,int b){
	return a > b;
}
sort(a,a + n,cmp);
//这样就可以让我们的数组从大到小排序

当然系统也提供了两个函数给我们，分别如下,type写的是数据类型，
sort(a,a + n,greater<type>()); //把type 数组 从大到小排序
sort(a,a + n,less<type>()); //把type 数组 从小到大排序
```

同样的，我们的sort也可以用来对于结构体排序。

对于结构体排序的话，因为所有元素都被存在了一个数组，所以只需要排序一个数组

倘若我们把元素分开了话，我们就需要对好几个数组进行交换排序。

```
struct node{
	int x,y;
};
node a[100];
bool cmp(node a,node b){
	return a.x > b.x;
}
sort(a + 1,a + n + 1,cmp);
```

但是大家必须要记住前几个基础排序，因为考试会考~~

### 7.6.1 示例题目

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209150941372.png" alt="image-20221209150941372" style="zoom:67%;" />
**思路：**虽然我们可以快速的去找到最大的，最小的，但是我们没法通过判断快速的找到第k大的，所以我们可以利用排序，将他从小到大排序，排序完之后，我们发现可以直接输出即可。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209151127047.png" alt="image-20221209151127047" style="zoom:67%;" />
**思路：**这道题我们有好几种方式去选择，第一种方式是去记录当前这个数字出现了几次，最后只需要从最小的数字循环到最大的数字去判断一下有没有出现过就行，第二种方式就是排序，假设我们已经完成了从小到大排序，那么对于相同的值一定会出现相邻位置，那么我们只需要判断相邻位置是否相同即可，若相邻相同则不继续输出了。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209172507260.png" alt="image-20221209172507260" style="zoom:67%;" />
**思路：**对于多个关键词的排序，我们最好的方法就是结构体，因为如果我们使用多个数组去存的话，交换的时候很麻烦，但是使用结构体的话就变成了一次交换，然后在使用以上的三个排序选择一个进行排序

```
#include<stdio.h>
#include<algorithm>

using namespace std;

const int N = 1000;

struct node{
	int Ch,Ma,En,Total,id;
}a[N];

int main(){
	int n;
	scanf("%d",&n);
	for(int i = 1; i <= n; i++){
		scanf("%d %d %d",&a[i].Ch,&a[i].Ma,&a[i].En);
		a[i].Total = a[i].Ch + a[i].Ma + a[i].En;
		a[i].id = i;
	}
	for(int i = 1; i <= n; i++){
		int Now = 0,NowCh = 0,Nowid = 0,s = i;
		for(int j = i; j <= n; j++){
			if(Now < a[j].Total){
				Now = a[j].Total;
				NowCh = a[j].Ch;
				Nowid = a[j].id;
				s = j;
			}else if(Now == a[j].Total){
				if(NowCh < a[j].Ch){
					NowCh = a[j].Ch;
					Nowid = a[j].id;
					s = j;
				}else if(NowCh == a[j].Ch){
					if(Nowid > a[j].id){
						Nowid = a[j].id;
						s = j;
					}
				}
			}
		}
		std::swap(a[i],a[s]);
	}
	for(int i = 1; i <= 5; i++){
		printf("%d %d\n",a[i].id,a[i].Total);
	}
	return 0;
}
```

**思路2：使用sort对我们的结构体进行排序，不过需要自定义函数。**

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int yw; //语文
	int sx; //数学
	int yy; //英语
	int xh; //学号
	int zongf; //总分
}a[305];
bool cmp(node a,node b){
	if(a.zongf == b.zongf && a.yw == b.yw){
		return a.xh < b.xh;
	}else if(a.zongf == b.zongf){
		return a.yw > b.yw;
	}
	return a.zongf > b.zongf;
}
int main(){
	int n;
	cin>>n;
	for(int i = 1; i <= n; i++){
		cin>>a[i].yw>>a[i].sx>>a[i].yy;
		a[i].zongf = a[i].sx + a[i].yw + a[i].yy;
		a[i].xh = i;
	}
	sort(a + 1, a + n + 1,cmp);
	int t = 1;
	for(int i = 1; i <= 5; i++){
		cout<<a[i].xh<<" "<<a[i].zongf<<endl;
	}
	
	return 0;
}
```

### 练习：

1. 以下排序算法的常见实现中，哪个选项的说法是错误的：（ ）。（CSP-J 2022 第一轮）

   A. 冒泡排序算法是稳定的	B. 简单选择排序是稳定的	C. 简单插入排序是稳定的	D. 归并排序算法是稳定的

2. 以下排序算法中，不需要进行关键字比较操作的算法是（ ）。(NOIP 2018 普及组初赛试题)
   A. 基数排序 B. 冒泡排序 C. 堆排序 D. 直接插入排序

3. 对于给定的序列 $\{a_k\}$，我们把$ (i,j)$ 称为逆序对当且仅当 $i < j$ 且 $a_i > a_j$。那么序列 $1, 7, 2, 3, 5, 4$ 的逆序对数为（ ）个。(NOIP 2017 普及组)
   A. 4         B. 5         C. 6         D. 7

4. 以下时间复杂度不是 $O(n^2)$ 的排序方法是( ). (NOIP 2014 提高组初赛)
   A. 插入排序        B. 归并排序       C. 冒泡排序        D. 选择排序

# 8. 二分

### 定义

二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。

### 过程

以在一个升序数组中查找一个数为例。

它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。

### 性质

#### 时间复杂度

二分查找的最优时间复杂度为 $O(1)$。

二分查找的平均时间复杂度和最坏时间复杂度均为$O(logn)$ 。因为在二分搜索过程中，算法每次都把查询的区间减半，所以对于一个长度为 $n$的数组，至多会进行 $logn$次查找。

#### 空间复杂度

迭代版本的二分查找的空间复杂度为 $O(1)$。

递归（无尾调用消除）版本的二分查找的空间复杂度为 $O(logn)$。

### 条件

当我们使用二分的时候，我们要先使得我们的序列变得有序，只有这样我们才能确切的判断。

以在一个升序数组中查找一个数为例。

它每次考察数组当前部分的中间元素。如果我们的序列是无序的，我们无法判断左半边是否一定都是小于中间或者大于中间元素的

那么要使得有序，我们必须要先排序，所以排序是我们二分必要的一个东西。

### 模板

```
int l = 1,r = n;
while(l < r){  //for(;l < r;)
	int mid = l + r + 1 >> 1;
	if(check(mid)) l = mid; //判断mid是否满足性质
	else r = mid  - 1;
}

int l = 1,r = n;
while(l < r){
	int mid = l + r>> 1;
	if(check(mid)) r = mid;
	else l = mid + 1;
}

double l = 1,r = n;
while(l + 1e-3 < r){
	double mid = l + r >> 1;
	if(check(mid)) r = mid;
	else l = mid;
}
```

#### 模板1讲解：

![image-20221117201643353](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117201643353.png)
如图若是按照我们模板一来说的话，当check(mid) 为真的话，说明满足条件的就是在 mid ~ r的范围内，那么我们只需要把 l 改成 mid即可。

当check(mid)为假的话，说明满足条件的就是在 l ~ mid - 1的范围内，因为 mid也不满足。所以我们只需要把 r 改成 mid - 1。

那么为什么我们的 mid = l + r + 1 >> 1 ? 这其实是为了防止死循环，当我们的 l + r  >> 1 == l 也就是 l = r - 1 的时候 我们每次如果check(mid) 为真 那么 l = mid = l所以 l就会一直为 l 所以会导致死循环。

#### 模板2讲解：

如图若是按照我们模板一来说的话，当check(mid) 为真的话，说明满足条件的就是在 1~ mid的范围内，那么我们只需要把 r 改成 mid即可。

当check(mid)为假的话，说明满足条件的就是在mid + 1 ~ r的范围内，因为 mid也不满足。所以我们只需要把 l 改成 mid + 1。

那么我们这里的 mid = l + r >> 1 不加上1了呢？ 考虑 r + l >> 1  == r 此时l == r 所以已经不满足条件，所以我们无需加1

#### 模板3讲解：

浮点数二分我们直接 l = mid，r = mid，因为除非 l 和 r的误差在 1e-16 左右我们才能导致错误，不过题目一般误差在1e-6左右

## 8.1 例题1 整数二分

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117190622726.png" alt="image-20221117190622726" style="zoom:67%;" />
**思路**:此题$n$的大小为$10^6$所以每一次for循环去查找整数$q$造成的复杂度$o(nm)$会超时，所以我们考虑二分，由于题目说给出的数字是单调不减的也就是有序的，所以我们不需要排序，直接二分就可以了。

```
bool check(int mid){
	return a[mid] <= x;
}

int l = 1,r = n; //用l,r代表我现在要查询的范围
while(l < r){
	int mid = l + r + 1 >> 1;
	if(check(mid)) r = mid;
	else l = mid - 1;
}
```

## 8.2 例题2 二分答案

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221117203654259.png" alt="image-20221117203654259" style="zoom: 67%;" />
**思路**：倘若，我们从树的最高高度往下找那么复杂度就是 $O(h * n)$我们遍历高度的同时，还要去判断哪些树产生了木材。我们思考对于高度有没有什么特殊性质，我们能够发现如果我砍的高度为 $x$都不行的话，$x$以上的高度肯定也不行，如果$x$可以的话，$x$以下的高度肯定可以，所以满足二分的条件。所以我们直接二分这个高度，如果产生的木材数量能够达到我们要求说明，我们现在的高度刚好是答案或者现在的高度太矮了。我们就需要把高度往上提，否则我们就要把高度往下提

```
bool check(int mid){
	long long sum = 0;
	for(int i = 1; i <= n; i++){
		sum += (mid<=a[i])?a[i] - mid : 0;
	}
	return sum >= x;
}

int l = 1,r = 1e9;
while(l < r){
	int mid = l + r >> 1;
	if(check(mid)) l = mid;
	else r = mid - 1;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209180058887.png" alt="image-20221209180058887" style="zoom:67%;" />
**思路：**我们同样思考，如果我跳的距离为 $x$需要移动 $y$块石头，那么我跳的距离为 $x + 1$ 需要移动的石头会比$ y$ 大吗？一定会比 $y$ 小，如果我跳的距离为 $x - 1$，那么需要移动的石头会比$y $小吗？一定不会，所以满足我们二分的条件，所以我们只需要二分我们跳跃的距离即可。

## 8.3 例题3 浮点数二分

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221215135115596.png" alt="image-20221215135115596" style="zoom:67%;" />
**思路：**经典的浮点数二分，因为 对于$x$来说 $x^3$ 一定 小于$ (x + 1)^3$，$(x - 1)^3$ 一定小于 $(x^3)$，我们直接二分答案直到逼近$n$，但是由于题目让我们保留6位小数，所以我们的误差最好不要大于 1e-7，不然可能会导致错误。

```
#include<bits/stdc++.h>
using namespace std;
double n;
int main(){
        cin >> n;
        double l = -100.0,r = 100.0;
        while(r - l > 1e-7){
            double m = (l + r) / 2;
            if(m * m * m > n) r = m;
            else l = m;
        }
        printf("%.6lf",l);
    return 0;
}
```

## 8.4 二分函数讲解

二分有两个可以对数组使用的函数
头文件：algorithm

1. lower_bound() 返回值是一个指针,返回指向大于等于key的第一个值的位置
   一共有三个参数lower_bound(首地址，结束地址，查找的值)
   我们可以先试试以下代码

   ```
   int a[10] = {0,1,2};
   int *pos = lower_bound(a,a + 2,1);
   cout << pos << endl;
   cout << a << endl;
   cout << pos - a << endl;
   //我们发现前两个输出都是地址，最后一个输出是1，因为地址之间相减变成了间隔的数的数量，地址差4，那么间隔一个数
   //所以我们一般使用 lower_bound(首地址，结束地址，查找的值) - 首地址 这样子返回的值就是在数组的位置了
   ```

2. upper_bound() 返回值是一个指针,返回指向大于key的第一个值的位置 使用方法同上

### **练习：**

1. 设有 100 个已排好序的数据元素，采用折半查找时，最大比较次数为（） （CSP 2019 入门级第一轮）
   A. 7 B. 10 C. 6 D. 8

# 9. 贪心

本页面将简要介绍贪心算法。

## 9.1 引入

贪心算法（英语：greedy algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

## 9.2 解释

### 适用范围

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

### 证明

贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
2. 归纳法：先算得出边界情况（例如 $n = 1$）的最优解 $F_1$，然后再证明：对于每个 $n$，$F_{n+1}$ 都可以由 $F_{n}$ 推导出结果。

## 9.3 要点

### 常见题型

在提高组难度以下的题目中，最常见的贪心有两种。

- 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。
- 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）类似模拟的意味

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

### 排序解法

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

## 9.4 排序解法例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202165320635.png" alt="image-20221202165320635" style="zoom:67%;" />

**思路：**倘如一共有 $n$ 个人，其中一个人接水的时间是 $x$，另一个人是$y$，满足$x > y$，倘如让这个 $x$ 这个人在 $y$ 前接水，那么答案就是 $k_1 = (n - 1) * x + (n - 2) * y$，倘如让这个 $y$ 这个人在 $x$ 前接水，那么答案就是 $k_2 = (n - 1) * y + (n - 2) * x$，明显$k_2 > k_1$，所以一定是接水时间少的在前面最优，我们只需要对序列排个序即可。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202165839002.png" alt="image-20221202165839002" style="zoom:67%;" />
**思路：**首先第一件事一定是排序，按照左端点从小到大或者按照右端点从小到大排序，只有这样我们才能找到线段的之间的规律。假设就是按照左端点从小到大排序的，对于几个有交集的区间来说什么时候最优呢？一定是选择右端点最靠左的那个区间，因为我们是按照左端点排序的，我们想要能够选择下一个区间的概率更大，所以选择右端点最靠左的区间概率最大。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202173829054.png" alt="image-20221202173829054" style="zoom:67%;" />
**思路：**我们首先得让我们的每个区间有序，只有区间有序我们才能够找到规律。如何放最少的点，无非就是在重叠的区间部分放更好，所以我们就要思考如何去考虑区间重叠，假设我们按照左端点从小到大排序的话，那么前后两个区间什么时候相交呢？假设我们现在确定了一段区间左端点的坐标是$x$，右端点的坐标是$y$，一共会出现如下情况
![image-20221202182421034](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202182421034.png)

1. 存在一个区间 x1，y1 使得 x1 <= x，y1 <= y，这两条边的相交部分是 x，y1。
2. 存在一个区间 x2，y2 使得 x2 = x，y2  > y，这两条边的相交部分是 x1，y2。
3. 存在一个区间 x3，y3 使得 y >= x3 >= x，y >= y3 >= x，这两条边的相交部分就是 x3，y3。
4. 存在一个区间 x4，y4 使得 y >= x4 >= x，y4 >= y，这两条边的相交部分就是x4，y。
5. 存在一个区间 x5 ，y5 使得 x5 >= y，y5 >= y，这两条边的相交部分就是 x5 或者没有

所以基于以上情况，如果我们对于每一个区间维护一个相交部分的左端点和右端点，如果下一个区间和我当前维护的相交部分区间有交点，那么我就通过相对关系，缩小我的相交部分，否则我就把下一区间当成新的一个相交部分区间。

```
#include <iostream>
#include <algorithm>
using namespace std;
struct node{
	int l, r;
};
node a[100005];
bool cmp(node a,node b){
	if (a.l != b.l){
		return a.l < b.l;
	}else{
		return a.r < b.r;
	}
}
int main (){
	int n;
	cin >> n;
	for (int i = 1;i <= n;i++){
		cin >> a[i].l >> a[i].r;
	}
	sort(a+1,a+1+n,cmp);
	int L = a[1].l,R = a[1].r;
	int sum = 1;
	for (int i = 1;i <= n;i++){
		if (L < a[i].l){
			L = max(L,a[i].l);
		}
		if (R > a[i].r){
			R = min(R,a[i].r);
		}
		if (L > R){
			sum++;
			L = a[i].l;
			R = a[i].r;
		}
	}
	cout << sum << endl;
	return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221202183552552.png" alt="image-20221202183552552" style="zoom:67%;" />
**思路：**这道题和第一道题一模一样。

```
#include <iostream>
#include <algorithm>
using namespace std;
struct node{
	int l, r;
};
node a[100005];
bool cmp(node a,node b){
	if (a.l != b.l){
		return a.l < b.l;
	}else{
		return a.r < b.r;
	}
}
int main (){
	int n;
	cin >> n;
	for (int i = 1;i <= n;i++){
		cin >> a[i].l >> a[i].r;
	}
	sort(a+1,a+1+n,cmp);
	int L = a[1].l,R = a[1].r;
	int sum = 1;
	for (int i = 1;i <= n;i++){
		if (L < a[i].l){
			L = max(L,a[i].l);
		}
		if (R > a[i].r){
			R = min(R,a[i].r);
		}
		if (L > R){
			sum++;
			L = a[i].l;
			R = a[i].r;
		}
	}
	cout << sum << endl;
	return 0;
}
```

大家可以发现这两个题的代码一样的，其实两个题目的意思是一样的，大家可以想 假设我选择的前区间为 l1，r1 后区间为 l2，r2 存在一个区间 l3，r3 不相交 l1，r1 和 l2，r2 并且 r3 < r2，那么就与我们题目的求解矛盾了，因为明显 我把 l2，r2当作后区间更优，所以一定不存在 这样的 l2，r2。所以中间的边分别交于 l1，r1 和 l2，r2 这样就是尽量的去把区间搞成相交对吧！

## 9.5 模拟解法

模拟解法就是顺着题目的意思想出最优解即可。

### 模拟解法例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209194639520.png" alt="image-20221209194639520" style="zoom:67%;" />
**思路：**对于当前元素只有两种选择 并到其他段上和单独一段，我们就按照这个思想模拟即可。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209194757432.png" alt="image-20221209194757432" style="zoom:67%;" />
**思路：**所有士兵撤离独木桥的时间取决于最后一个撤离独木桥的士兵，一个士兵撤离独木桥有两种，一种是去0点，一种是去 L + 1点，对于所有士兵最小撤桥值取个最大值即可！

### 练习：

1. 有四个人要从 A 点坐一条船过河到 B 点，船一开始在 A 点。该船一次最多可坐两个人。 已知这四个人中每个人独自坐船的过河时间分别为 1, 2, 4, 8且两个人坐船的过河时间为两人独自过河时间的较大者。则最短（ ）时间可以让四个人都过河到 B 点（包括从 B 点把船开回 A 点的时间）。（CSP 2021 入门级第一轮）
   A. 14 		B. 15		 C. 16 		D. 17
2. 周末小明和爸爸妈妈三个人一起想动手做三道菜。小明负责洗菜、爸爸负责切菜、妈妈负责炒菜。假设做每道菜的顺序都是：先洗菜 10 分钟，然后切菜 10 分钟，最后炒菜 10 分钟。那么做一道菜需要 30 分钟。注意：两道不同的菜的相同步骤不可以同时进行。例如第一道菜和第二道的菜不能同时洗，也不能同时切。那么做完三道菜的最短时间需要（ ）分钟。
    A. 90          B. 60         C. 50         D. 40

# 10. 双指针

双指针其实不是真正的指针，而是有两个变量在序列上进行一些操作。

解决双指针问题四种常用思想：

普通双指针（two sum），一般两个for循环，外层i和内层j可以认为是普通的双指针；
左右指针(二分搜索)：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇；
快慢指针：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾；
滑动窗口。
普通双指针我们先前题目已经练到过，例如如何输出下三角，如何输出上三角。
这堂课主要是要讲快慢指针，我们直接通过题目来描述。

## 10.1 示例1

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221215103135355.png" alt="image-20221215103135355" style="zoom:67%;" />

**思路：**如果我们使用普通双指针，对于起点为 $i$的我们每次找到一个终点为$j$的最长不包含重复的数的连续区间需要的复杂度就是 $O(n^2)$。现在假设其中的一个区间是$(i,j)$。我们思考 $(i + 1,k)$ 这个$k$和之前的区间$(i,j)$有什么关系？我们发现 $k$一定大于等于$j$，所以我们每次只需要对$i$点进行一个消除即可，随后再把$j$按照条件慢慢变大即可。

## 10.2 示例2

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221215103759391.png" alt="image-20221215103759391" style="zoom:67%;" />
**思路：**如果我们用$i$遍历$a$数组去匹配$b$数组中的$j$我们需要的复杂度是$O（n^2）$但是我们首先要发现个规律对于 $a[i] + b[j - 1] < x，a[i] + b[j] > x$，那么$a[i + 1] + b[j] > x$,但是我们并不知道 $a[i + 1] +  b[j - 1]$与$x$的关系，所以我们只需要从$j - 1$的基础上去缩小直到满足 $<= x$

# 11. 离散化

离散化（Discretization），把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：

原数据：1, 999, 100000, 15；处理后：1,3,4,2。
原数据：{100, 200}，{20, 50000}，{1, 400}；处理后：{3,4}，{2,6}，{1,5}。

离散化的原理和实现都很简单。为了确保不出错且尽可能地提高效率，我们希望离散化能实现以下几种功能：

1、保证离散化后的数据非负且尽可能的小

2、离散化后各数据项之间的大小关系不变，原本相等的也要保持相等。

由此，找出数据项在原序列中从小到大排第几就是离散化的关键。可以通过下面的方法以 $O(n logn) $的时间复杂度完成离散化，$n $为序列长度。

离散化一共有两种方法，方法一重复元素离散化后的数字相同，方法二重复元素离散化后的数字不相同。用的最多的是方法一，方法2基本上用不上，这里就不多讲了。

## 11.1 重复元素离散化后的数字相同

例如：对于序列 [105，35，35，79，-7，-7]，排序并去重后变为 [-7，35，79，105]，由此就得到了对应关系 -7->1, 35->2, 79->3, 105->4。

基本的步骤可以分为：

1、用一个辅助的数组把你要离散的所有数据存下来。

2、排序，排序是为了后面的二分。

3、去重，因为我们要保证相同的元素离散化后数字相同。

4、索引，再用二分把离散化后的数字放回原数组。

```

#include<algorithm> // 头文件 
 
const int MAXN = 1e6+4;
//n 原数组大小 num 原数组中的元素 lsh 离散化的数组 cnt 离散化后的数组大小 
int lsh[MAXN], cnt, num[MAXN], n;
 
for (int i=1; i<=n; i++) {
    scanf("%d",&num[i]);
    lsh[i] = num[i];	
}
 
sort(lsh+1 , lsh+n+1);//排序
cnt = unique(lsh+1, lsh+n+1) - lsh - 1;//去重
 
//二分查找
for(int i=1; i<=n; i++) {
    num[i] = lower_bound(lsh+1 , lsh+cnt+1 , num[i]) - lsh;
}
```

# 12. 递归

先前讲过一些递归都是用来解决一些简单的问题，此专题专门讲递归两个经典问题。

## 12.1 汉诺塔问题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118164413211.png" alt="image-20221118164413211" style="zoom:67%;" />
假设现在有三个柱子分别为A、B、C，当A初始只有一片圆盘只需从A → C 即可满足。传递次数为1次

<img src="https://img-blog.csdnimg.cn/20210607175624363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNjAxMTA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />
当A初始有2片圆盘时，只需先将A → B，再将A → C，最后将B → C 即可满足。传递次数为3次
<img src="https://img-blog.csdnimg.cn/20210607180639175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNjAxMTA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

那我们如果在A初始有3片圆盘，会是怎样的传递方式呢？

<img src="https://img-blog.csdnimg.cn/20210607183418361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNjAxMTA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

传递方式：A→C，A→B，C→B，A→C，B→A，B→C，A→C 总共传递了7次。

从这三个图可以看出，如果A初始有n片圆盘，

传递次数为$2^n -1$次，

传递规律：我们不考虑中途传递细节，满足最终要求，由大问题分成三大步来解决

先将$n-1$个圆盘从第一根柱子A移到第二根柱子B，
其次将第$n$个圆盘（最大的圆盘）从第一根柱子A移到第三根柱子C，
最后将$n-1$个圆盘从第二个柱子B移到第三个柱子C，即可满足条件。

我们思考 $n$ 个圆盘的汉诺塔的和 $n - 1$个圆盘得汉诺塔有什么关系。假设 汉诺塔是A B C 三个塔，我们需要把$n$个盘从$A$柱移动到$C$柱，若较小的$n - 1$个圆盘都在 $B$柱上，那么我们把 第 $n$个圆盘从 $A$柱移动到$C$柱。此时这个$C$柱上的圆盘有跟没有都一样。我们把$ B$柱当作 新的 $A$柱，$A$柱当作新的$B$柱，$C$柱是新的$C$柱。我们发现问题就变成了求解 $n - 1$层汉诺塔。以此类推...直到只剩下$1$个圆盘的时候直接从$A$移动到$C$。

那么现在的问题变成了如何把这 $n - 1$个盘移动到柱$B$。同样的我们把$A$柱看成$A$柱，柱$B$盘看成新的$C$柱，$C$柱看成新的$B$柱。那么问题又变成了如何把 $n - 1$ 个圆盘的汉诺塔从$A$柱移动到$C$柱。

所以一个$n$个圆片的汉诺塔每次把问题分成了几个部分。

1. 把$A$柱看成新的$A$柱，$B$柱看成新的$C$柱，$C$柱看成新的$B$柱，求解 $n - 1$ 个圆盘的汉诺塔。
2. 把 $n$盘 从$A$柱 移动到$C$柱。
3. 把 $B$柱当作 新的 $A$柱，$A$柱当作新的$B$柱，$C$柱是新的$C$柱，求解 $n - 1$个圆盘的汉诺塔。

```
void move(char pos1,char pos2){
	printf(" %c->%c ",pos1,pos2);
}
N:代表盘子的个数
pos1:A柱
pos2:B柱
pos3:C柱
*/
void Hanoi(int n,char pos1,char pos2,char pos3){
	if (n == 1){
		move(pos1,pos3);
	}else{
		Hanoi(n-1,pos1,pos3,pos2);
		move(pos1, pos3);
		Hanoi(n-1,pos2,pos1,pos3);
	}
}
```

## 12.2 递归回溯问题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221118211813128.png" alt="image-20221118211813128" style="zoom:67%;" />
 与之前的题不同的是，此题要求$n$个数字互不相同，意味着我们在递归的过程中要判断当前数字是否使用过，其实很简单，如果我们使用了当前数字我们可以开一个数组，给他打上一个标记。

```
int b[10];
void dfs(int x){
	if(x == n + 1){
		for(int i = 1; i <= n; i++){
			printf("%d",b[i]);
		}
		return;
	}
	for(int i = 1; i <= n; i++){
		if(!flag[i]){
			flag[i] = 1;
			dfs(x + 1);
		}
	}
}
```

但是如果我们给他打上标记之后，输出完 1 2 3 .... n了之后，我们发现下一种情况就不能使用了，因为他被打上了标记，那怎么办呢？

那么这种方法就叫回溯！回到之前的状态，我们使用完后结束了此次递归后回到原来的情况

```
int b[10];
void dfs(int x){
	if(x == n + 1){
		for(int i = 1; i <= n; i++){
			printf("%d",b[i]);
		}
		return;
	}
	for(int i = 1; i <= n; i++){
		if(!flag[i]){
			flag[i] = 1;
			dfs(x + 1);
			flag[i] = 0; //回溯，在递归到 x + 1层之前flag[i] = 0,所以我递归出来后需要回到之前的状态
		}
	}
}
```

## 12.3 八皇后问题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221123141545394.png" alt="image-20221123141545394" style="zoom:67%;" />
**思路：**八皇后是最经典的递归回溯问题，因为我们每一次摆放皇后都需要看前面皇后的位置。
我们可以从第一行开始摆，假设摆在了 x,y这个位置，从此以后，第x行，第y列都不能再摆放皇后了，这个很好记录，无非就是设置两个数组，用下标来代表行号和列号，用0代表可以放，用1代表不能放。比较难想的是对角线，我们尝试找规律发现右下斜线每次往下移一个行 +1，列 +1，所以一个斜线的 x - y都相同。那么会产生不同斜线的和此斜线的 x - y相同？对于x不变y改变的，x - y 会改变，对于x改变的y不改变的，x - y也会改变，所以最后得证 一个斜线的x - y相同，不同斜线的 x - y 不同，所以当前斜线，我们用数组记录 x - y即可。那么对于右上斜线的呢？我们发现，往右上移一个 x - 1，y + 1 所以发现规律，一个斜线的 x + y是相同的，那么不同斜线的x + y会相同吗？显然不会，最后发现，分别用 x - y和 x + y代表斜线的记录即可。
现在剩下最后一个问题当 x - y小于0怎么办，我们数组不能存储小于0的。我们只需把数组扩大，整体 x - y都加上一个很大的值，这样就不会小于0了。

```
#include<bits/stdc++.h>
using namespace std;
bool flag[15] = {0};
bool flag1[100] = {0};
bool flag2[100] = {0};
int sum[15];
int n;
int t = 0;
void f(int x){
	if(x > n){
		++t;
		if(t > 3) return;
		for(int i = 1; i <= n; i++){
			cout<<sum[i]<<" ";
		}
		cout<<endl;
		return;
	}
	else {
		for(int i = 1; i <= n; i++){
            if(flag[i] == 0 && flag1[x + i] == 0 && flag2[x - i + 2 * n] == 0){
                sum[x] = i;
                flag[i] = 1;
                flag1[x + i] = 1;
                flag2[x - i + 2 * n] = 1;
                f(x + 1);
                flag[i] = 0;
                flag1[x + i] = 0;
                flag2[x - i + 2 * n] = 0;
            }
		}
	}
	return;
}
int main(){
	cin>>n;
	f(1);
	cout<<t;
	return 0;
}
```

### 练习：

1. 以下对递归方法的描述中，正确的是：（ ）（ CSP-J 2022 第一轮）

   A. 递归是允许使用多组参数调用函数的编程技术

   B. 递归是通过调用自身来求解问题的编程技术

   C. 递归是面向对象和数据而不是功能和逻辑的编程语言模型

   D. 递归是将用某种高级语言转换为机器代码的编程技术

# 13. 图论中的树

在现实生活中我们有公交车，公交车有站点，每个站点之间的长度是固定的，我们可以通过这些信息推导出，我从一个地方走到另一个地方的最少的路径长度，最少时间花费，或者能否从一个点走到另一个点。对于较少的数据，我们是可以通过大脑来实现的，但是世界这么大，我们没法推导出所有，所以我们就需要计算机的帮助，像百度地图，高德地图，都是通过计算机来完成的。在计算机中，公交车站的站点我们称为**点**，每两个点之间的关系我们称作**边**，这个边可以有很多数属性可以有长度，时间等。通过一些边走到另一个点的组合边我们称为**路径**。

那么如何去判断两个点是否有关系？两个点之间的边长度是多少呢？

我们可以使用数组套数组，用外层数组的下标代表当前点，用内层数组代表其他点。

那么这种存下每个点之间的关系的我们称为**邻接矩阵**

## 13.1 树

### 什么是树

**树是由一些点，一些边组成的，这些点每每两个都可以通过一条路径互相到达。树上没有环，也没有重边。(一个点也叫做树)**

如下图所示这就是一棵树

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111102838764.png" alt="image-20221111102838764" style="zoom:67%;" />


如下图所示不是一棵树，**因为产生了一个环**

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111102912321.png" alt="image-20221111102912321" style="zoom:67%;" />


如下图所示不是一棵树，**因为有个点不能通过边互相到达**

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111103010446.png" alt="image-20221111103010446" style="zoom:67%;" />


其实上图可以给他叫做**森林**，什么是森林呢？就是由多棵树组成的图叫做森林，但是森林里面的树不能有环，仅仅是多棵树而已。

**我们通过上图发现树的一个性质，那就是边的数量为点的数量 - 1**

### 树根(根节点)

每棵树有且只有一个树根，每个节点都可以当树根，但是他们的性质不一样

![image-20221111113147704](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111113147704.png)
只有你确定了哪个点是树根，你才可以确定以下知识节点。

### 子节点

子节点是相对于一个点来说的，就是与这个点相连的就是子节点

![image-20221111113300934](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111113300934.png)
如图 若 点a 是根节点 点 a 的子节点为 点 b，f。点 b 的子节点为 点 c，d，e。 而点 c，d，e，f 没有子节点。

### 父亲节点

父亲节点也是相对于一个点来说

![image-20221111113617853](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111113617853.png)
如图 若点 a 是根节点 点 a 没有父亲节点，点 b，f 的父亲节点是 点 a。点 c，d，e 的父亲节点是点 b。

### 叶子节点

没有子节点的就是叶子节点

![image-20221111113831668](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111113831668.png)
如图 若点 a 是根节点。 点 c，d，e，f 是叶子节点。

### 深度

深度是相较于根节点来说的

距离根节点几个节点，深度就是几

![image-20221111114053809](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111114053809.png)
如图 若点 a 是根节点。点 a的深度是 0，点 b，f 的深度是1，点 c，d，e 的深度是2。

### 子树

子树也是相较于根节点来说的，与当前点以及其子节点组成的树就是当前点的子树

![image-20221111114053809](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111114053809.png)
如图 若点 a 是根节点。 点 a 的子树就是 点a，b，f，c，d，e组成的树。
点 b 的子树就是 点 b，c，d，e组成的树
点 c，d，e ，f 的子树 就是其自己组成的树

### 兄弟节点

同一个父亲节点的两个节点可以称作兄弟节点。

![image-20221111114053809](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111114053809.png)
如图 若点 a 为根节点。那么 点 b 和 f 互相是兄弟节点，点 c，d，e 互相是兄弟节点。

### 堂兄弟节点

深度相同，父亲节点不同的点互相称为堂兄弟节点

![image-20221111115004816](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111115004816.png)
如图 点 c，d，e 和 点 g，h 互相称为堂兄弟节点。

### 度

一个点与之连接的子节点个数为 x，那么点的度就为 x

### 路径

一个点通过一些边到达另一个点 这些组合边 称为一条路径

### 祖先

从当前点，走到树根上的路径上的所有点都可以称作当前点的祖先

![image-20221111115542266](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111115542266.png)
如图 若点 a 为根节点，点 d，c，e 的祖先节点都为 b，a。

点 g，h 的祖先节点为 f，a

### 链

满足与任一结点相连的边不超过2条的树称为链

### **菊花/星星（star）**：

满足存在 使得所有除自己以外结点均与自己相连的树称为菊花       

### 二叉树

每个节点最多只有两个子节点的树叫做二叉树

性质：深度为x的二叉树最多拥有 2^x^ - 1个节点

### 满二叉树/完美二叉树

一个深度为 $k $的二叉树 拥有 2^k^ - 1 个节点的叫做 满二叉树/完美二叉树。

### 完全二叉树

一棵深度为$k$的有$n$个结点的二叉树，对树中的结点按从左到右，从上至下的顺序进行编
号，如果编号为 $i$的结点与满二叉树中编号为$i$的结点在二叉树中的位置相同，则这
棵二叉树称为完全二叉树

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111120650292.png" alt="image-20221111120650292" style="zoom:67%;" />
如图就是从上至下、从左到右的顺序进行编号

### 完满二叉树

除了非叶子节点，每个节点的度都为2的称为完满二叉树

### 练习：

1. 如果一棵二叉树只有根结点，那么这棵二叉树高度为 1。请问高度为 5 的完全二叉树有 （ ）种不同的形态？ （CSP 2021 入门级第一轮）
   A. 16 	B. 15	 C. 17 	D. 32
2. 根节点深度为 0，一棵深度为 $h $的满 $k(k>1)$ 叉树，即除最后一层无任何子节点外，每一层上的所有结点都有 $k$ 个子结点的树，共有（ ）个结点。
   (NOIP 2018 普及组初赛试题)
    A. $\dfrac{k^{h+1}-1}{k-1}$       B. $k^{h-1}$       C. $k^h$        D. $\dfrac{k^{h-1}}{k-1}$

## 13.2 树的存储1

我们可以用**数组**存储

我们开一个二维数组 用这两维代表 点a，点b，用数组的值代表是否有边
例如 Edge[a] [b] = 1 代表点 a，b之间有一条边

## 13.3 树的遍历

树的遍历就是，通过给出的根节点，通过边走过树的每一个点，从而获得树的信息，例如一个点的深度，子节点，父亲节点。
我们可以通过递归来遍历整棵树，因为我们对于递归的动作是，查看当前点有哪些点与他有关，然后走向下一个点。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221123160904882.png" alt="image-20221123160904882" style="zoom:67%;" />
这道题就是一道很好的树的遍历题目。

```
#include<iostream>
#include<cstring>
using namespace std;
const int N = 1e3 + 10;
int a[N][N];
int dp[N];
int n;
void dfs(int x,int pre){
    for(int i = 1; i <= n; i++){
        if(i == pre) continue;
        if(a[x][i]){
            dp[i] = dp[x] + 1;
            dfs(i,x);
        }
    }
}
int main(){
        cin >> n;
        for(int i = 1; i <= n - 1; i++){
            int x,y;
            cin >> x >> y;
            a[x][y] = 1;
            a[y][x] = 1;
        }
        dp[1] = 1;
        dfs(1,0);
        for(int i = 1; i <= n; i++){
            cout << dp[i] << endl;
        }
    return 0;
}

```

我们发现，通过这样的写法去遍历整棵树，每次会优先往深处去遍历点，所以这种递归方法也称作**深度优先搜索(dfs)**

时间复杂度是$O(n^2)$ ， 空间复杂度 $O(n^2)$

我们发现虽然我们只有 $n$ 个点，但是我们使用了 $O(n^2)$ 的空间复杂度和时间复杂度去存储和遍历。倘如我们每个点使用的是一个可以变长的数组，并且我们知道他的长度，我们就可以在 $O(n)$ 的复杂度去存储了，因为每个点只有一个父亲。那么我们就需要用到我们的工具vector，具体看vector章节。

```
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
const int N = 1e3 + 10;
vector<int>[N];
int dp[N];
int n;
void dfs(int x,int pre){
    for(int i = 0; i < v[x].size(); i++){
        if(v[x][i] == pre) continue;
            dp[v[x][i]] = dp[x] + 1;
            dfs(v[x][i],x);
    }
}
int main(){
        cin >> n;
        for(int i = 1; i <= n - 1; i++){
            int x,y;
            cin >> x >> y;
            v[x].push_back(y);
            v[y].push_back(x);
        }
        dp[1] = 1;
        dfs(1,0);
        for(int i = 1; i <= n; i++){
            cout << dp[i] << endl;
        }
    return 0;
}
```

### 练习：

1. 以 $a$为起点，对下边的无向图进行深度优先遍历，则 $b,c,d,e$四个点中有可能作为最后一个遍历到的点的个数为（ ）。(CSP 2021 入门级第一轮)
   <img src="https://ipic.luogu.com.cn/2yir4.png" alt="img" style="zoom:33%;" />
    A. 1 	B. 2 	C. 3 	D. 4
2. 设 G是有 n个结点、m条边 $(n \leq m)$的连通图，必须删去 G 的（ ）条边，才能使得 G变成一棵树。（NOIP 2016 普及组初赛试题）
   A. m - n + 1 		B. m - n 		C. m + n + 1 		D. n - m + 1
3. 6 个顶点的连通图的最小生成树，其边数为( )。 (NOIP 2015 普及组初赛试题)
   A. 6 B. 5 C. 7 D. 4

## 13.4 树的父亲表示法

顾名思义记录每个点的父亲，当然这是对有些特定的题目来说的，因为不是所有题目都是告诉你谁是谁的父亲。

首先通过记录每个点的父亲我们最终可以得到什么信息：

1. 根节点

2. 深度

3. 每个点的子节点

   <img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221123204721864.png" alt="image-20221123204721864" style="zoom:67%;" />
   我们随机选择一个点，如果这个点有父亲节点，那么他一定不是根节点，我们只需要再去判断这个根节点是否还有父亲节点即可，重复这个操作，直到找到一个没有父亲节点的点

   ```
   #include<iostream>
   #include<cstring>
   #include<testlib.h>
   
   using namespace std;
   
   const int N = 1e3 + 10;
   int b[N][N];
   int dp[N],fa[N];
   int n;
   void dfs(int x,int pre){
       for(int i = 1; i <= n; i++){
           if(i == pre) continue;
           if(b[x][i]){
               dp[i] = dp[x] + 1;
               dfs(i,x);
           }
       }
   }
   
   int main(){
   
           cin >> n;
           memset(b,0,sizeof b);
           memset(fa,0,sizeof fa);
           for(int i = 1; i <= n - 1; i++){
               int x,y;
               cin >>x >> y;
               fa[x] = y;
           }
   
           int root = 1;
           while(fa[root] != 0){
               root = fa[root];
           }
   
           for(int i = 1; i <= n; i++){
               int root = i;
               while(fa[root] != 0){
                   b[fa[root]][root] = 1;
                   root = fa[root];
               }
           }
   
           dp[root] = 1;
           dfs(root,0);
   
           cout << root << endl;
   
           for(int i = 1; i <= n; i++) cout << dp[i] << endl;
           for(int i = 1; i <= n; i++){
               int sum = 0;
               for(int j = 1; j <= n; j++){
                   if(b[i][j]){
                       sum++;
                   }
               }
               if(!sum) cout << 0 << endl;
               else{
                  for(int j = 1; j <= n; j++){
                       if(b[i][j]){
                           cout << j << " ";
                       }
                   }
                   cout << endl;
               }
           }
       return 0;
   }
   
   ```


## 13.5 特殊的树二叉树

每个节点最多只有两个子节点的树叫做二叉树，那么左边的子节点叫左儿子，右边的子节点叫做右儿子。

性质：深度为x的二叉树最多拥有 2^x^ - 1个节点

### 练习：

1. 独根树的高度为 1。具有 61个结点的完全二叉树的高度为（ ）。（CSP 2020 入门级第一轮）
    A. 7 B. 8 C. 5 D. 6
2. 一棵二叉树如右图所示，若采用顺序存储结构，即用一维数组元素存储该二叉树中的结点（根结点的下标为 $1$，若某结点的下标为$ i$，则其左孩子位于下标 $2i$ 处、右孩子位于下标 $2i+1$ 处），则该数组的最大下标至少为（）。(CSP 2019 入门级第一轮)
   ![img](https://cdn.luogu.com.cn/upload/image_hosting/7d58dfs8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
   A. 6 B. 10 C. 15 D. 12

### 13.5.1 二叉树的儿子表示法

顾名思义就是记录树上每个节点的儿子有谁，如果是多叉树的话，我们看不准一个节点最多有几个儿子，所以我们需要开足够大的数组，那么我们的空间复杂度会很大，因为二叉树最多有两个子节点，所以我们只需要开两个变量记录即可。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124133142713.png" alt="image-20221124133142713" style="zoom:67%;" />
已经告诉了我们每个节点的子节点是谁，那么我们只需要找到根节点就可以遍历整棵树了，根节点不是任何人的儿子节点，所以我们只需要找到哪个点在这中间没有出现过即可，最后通过每个点的儿子节点遍历整棵树复杂度为$O(n)$

### 13.5.2 二叉树的数组表示法

如果我们给我们的二叉树全部都按照完全二叉树那样从上到下，从左到右取编号，我们就知道编号为 $i$ 的左儿子的编号一定是 $i * 2$ ，编号为 $i$ 的右儿子的编号一定是 $i * 2 + 1$ ，所以我们完全也可以用数组来存储二叉树，如图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125130832622.png" alt="image-20221125130832622" style="zoom:67%;" />

假设B有右子节点，D有左子节点，那么此图就变成了一个完全二叉树，我们按照完全二叉树取编号，这样就可以用数组来存储整棵树了。

### 13.5.3 二叉树的前序遍历

大家知道如果我们给多叉树的边换换位置，它长的就不一样了，但是二叉树由于固定了左儿子和右儿子，所以二叉树的形态是不会改变的，所以有了多种遍历二叉树的方式，第一种方式就是前序遍历，前序遍历就是先遍历根节点，再遍历左子树的根节点，遍历完左子树所有点之后，再遍历右子树的根节点

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124135017596.png" alt="image-20221124135017596" style="zoom:67%;" />
如图，A是这颗二叉树的根节点，那么先遍历A，遍历A了之后遍历左子树，那么左子树以B为根节点，再遍历B的左子树，左子树的根节点为C，再遍历B的右子树，右子树的根节点为D，再遍历A的右子树，根节点为E，再遍历E的右子树，因为E没有左子树，根节点为F，最后遍历的总过程就是ABCDEF

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124135613056.png" alt="image-20221124135613056" style="zoom:67%;" />
通过题目来看，已经告诉了我们所有树左儿子是谁，右儿子是谁。那么我们使用递归进行遍历的时候，每一次进入一个儿子节点，都是进入以儿子节点为根节点的子树，所以我们直接输出当前儿子节点的编号即可，但是每次递归是需要先进入左子树，再进入右子树。

我们看递归做的事情是什么，是输出 以 $x$为根节点的子树的根节点，再进入遍历$x$的左子树，再进入遍历$x$的右子树

```
void dfs(int x){
	cout << x;
	if(a[x].l) dfs(a[x].l);
	if(a[x].r) dfs(a[x].r);
}
```

通过前序遍历的性质，输出前序遍历串例如 ABCDEF，对于点C来说，我们可以猜测  AB某个点一定是C的父亲节点，因为先输出根节点，再输出左子树的根节点，那么我们也可以猜测DEF中可能有些点是点C的左儿子节点或者右儿子节点。整棵树的根节点一定是点A。

### 13.5.4 二叉树的中序遍历

二叉树的中序遍历，是先遍历左子树，再输出根节点，再遍历右子树。我们思考递归的时候，每次遍历完左子树返回根节点的时候，此时还没有遍历右子树，那么我们在遍历右子树前输出根节点即可。

```
void dfs(int x){
	if(a[x].l) dfs(a[x].l);
	cout << x;
	if(a[x].r) dfs(a[x].r);
}
```

我们看递归做的事情是什么，是进入遍历$x$的左子树，再输出 以 $x$为根节点的子树的根节点，再进入遍历$x$的右子树。

通过中序遍历的性质，输出前序遍历串例如 ABCDEF，对于点C来说，我们可以猜测  A，B点某个点可能是C的左子节点，因为我们的中序遍历是先遍历左子树，并且先输出左子树的点。同样的我们可以猜测 DEF某个点是点C的右子节点。

### 13.5.5 二叉树的后序遍历

二叉树的后序遍历，是先遍历左子树，再遍历右子树，再输出根节点。我们思考递归的时候，每次遍历完左子树返回根节点的时候，再遍历右子树，遍历完右子树之后再输出自己的根节点即可。

```
void dfs(int x){
	if(a[x].l) dfs(a[x].l);
	if(a[x].r) dfs(a[x].r);
	cout << x;
}
```

我们看递归做的事情是什么，是进入遍历$x$的左子树，再进入遍历$x$的右子树，再输出 以 $x$为根节点的子树的根节点，再进入遍历$x$的右子树。

通过后序遍历的性质，输出前序遍历串例如 ABCDEF，对于点C来说，我们可以猜测  A，B点某个点可能是C的左子节点或者是C的右子节点，因为我们的后序遍历是先遍历左子树，再遍历右子树，在输出根节点。同样的我们可以猜测 DEF某个点是可能是点C的父亲节点。整棵树的根节点一定是点F。

### 13.5.6 通过三个遍历确定整棵树

我们可以通过前序，后续，中序遍历推导出每个点之间可能存在的关系，那么我们到底能否通过这些遍历确定一整颗树呢？

#### 前序遍历，中序遍历

现在给出一棵树的前序遍历的结果是 ABCDEF，中序遍历是CBDEAF。

首先我们通过前序遍历可以知道，这整颗树的根节点是点A，那么现在确定的树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124153612560.png" alt="image-20221124153612560" style="zoom:67%;" />
现在我们想要组合 点A的左子树，我们就可以通过中序遍历找到A，因为中序遍历先遍历左子树，所以A的左边CBDE一定都是A的左子树节点。

那么接下来我们就看前序遍历的B，因为前序遍历先遍历根节点，遍历完根节点后紧接着就是左子树的根节点，倘若A有左子节点，那么前序遍历A的右边第一个一定是A的左子树的根节点，所以现在确定的树的形态如下图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124154302821.png" alt="image-20221124154302821" style="zoom:67%;" />
那么我们想要点B的左子树，同样的继续查看中序遍历B的左边有哪些，发现只有C，那么C一定是B的左子节点，所以现在确定的树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124154444291.png" alt="image-20221124154444291" style="zoom:67%;" />
我们再继续查看C节点的左子树，发现中序遍历里C的左边没有点了，那么C一定不存在左子树，那么我们就查看C的右子树，因为中序遍历先遍历左子树再遍历右子树，所以C的右边有些点可能是C的右子树，但是我们如何确定哪些点是呢？我们发现C的右边有点B，因为点B是点C的父亲节点，所以一定是等遍历完C的右子树才会遍历到，所以我们可以推导点B,C之间的就是组成点C右子树的点。由于B,C之间没有点，所以点C也没有右子树。那么我们确定了B的左子树的组成，接下来看B的右子树的组成，同样的B的右子树的组成一定由中序遍历B,A之间的点DE组成的。同样的此时，我们再看前序遍历点C的右边一位，因为前序遍历先遍历左子树再遍历右子树，所以去掉左子树的点C后，B右边第一位一定是右子树的根节点。所以点D一定是点B的右子树的根节点。此时确定的树的形态如下图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124155431845.png" alt="image-20221124155431845" style="zoom:67%;" />
我们继续查看点D是否有左子树，同样的看前序遍历点D的左边，我们发现点D的左边有B,C，但是BC我们已经确定过了，所以我们可以就去掉B,C就行了，发现点D左边就没有点了，说明点D没有左子树，那么我们继续查看点D的右子树，同样的看中序遍历点D的右边有EAF，但是因为A是点D的祖先，我们确定完点D的右子树之后才能返回点A，所以点A,D之间的点一定是组成D右子树的点，我们发现只有点E，那么此时确定的树的形态如下图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124160000004.png" alt="image-20221124160000004" style="zoom:67%;" />
我们继续查看点E是否有左右子树发现没有，我们就回到点A去查看是否有右子树，发现中序遍历点A右边只有点F，那么此时能确定的树的形态如下图。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124160154427.png" alt="image-20221124160154427" style="zoom:67%;" />
所以我们发现，前序遍历和中序遍历**可以确定一棵树**！

#### 前序遍历，后序遍历

现在给出一棵树的前序遍历的结果是 ABCDEF，后序遍历是CEDBFA。

我们首先可以通过后序遍历的性质，确定根节点是点A，那么此时能确定的树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124174858364.png" alt="image-20221124174858364" style="zoom:67%;" />
通过前序遍历的性质我们可以知道如果点A有左子树的话，左子树的根节点一定是点B，如果A没有左子树的话，右子树的根节点也一定是B，所以我们确定不了。我们通过后续遍历的性质知道如果点A有左子树的话，左子树一定是A左边的点，左边的点有FBDEC。假设点B是右子树的根节点的话，F点一定是点B为根节点子树下的一个点，那么F点在后续遍历中一定会比F点先出现，所以我们推导出了B点是点A的左子树的根节点。那么此时能确定的树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124182241842.png" alt="image-20221124182241842" style="zoom:67%;" />
同样的通过前序遍历看如果点B有左子树的话，那么他的左子树的根节点一定是点C，我们通过后序遍历查看CED是在B的左边，通过后序遍历左右中的性质，可以推导C就是B的左子树的根节点，所以此时能确定的树的形态如下图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124194504835.png" alt="image-20221124194504835" style="zoom:67%;" />
再查看C是否有左子树，发现前序遍历右边一个是D，如果C有左子树D一定是左子树的根节点，我们再查看后序遍历C的左边，发现什么都没有，所以C一定没有左子树，也没有右子树。那么我们继续查看B的右子树存不存在，如果存在的话D一定是右子树的根节点，我们查看B的左边有ED，如果D是B的右子树的根节点的话，那么ED是成立的所以此时确定了D是B的右子节点，此时能确定的树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124195524422.png" alt="image-20221124195524422" style="zoom:67%;" />
我们来查看E到底是D的左子树还是右子树，我们通过前序遍历一定是判断不出来，那么我们就通过后序遍历看，E在D的左边，但是我们没法确定是左子节点还是右子节点，所以就产生了矛盾。

最后得出结论前序遍历，后续遍历**没法确定一棵树**，会产生矛盾。

#### 中序遍历，后序遍历

现在给出一棵树的中序遍历的结果是 CBDEAF，后序遍历是CEDBFA。

通过后序遍历的性质，最后一位是根节点，那么此时确定树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125122536832.png" alt="image-20221125122536832" style="zoom:67%;" />
通过中序遍历的性质得到，A左边的都是A的左子树，右边都是B的右子树，所以CBDE组成了A的左子树，通过后序遍历的性质左右中，所以最左端一定是A的左子树的根节点。那么此时确定树的形态如下图

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125122917149.png" alt="image-20221125122917149" style="zoom:67%;" />
那么我们继续查看和B有关的，通过中序遍历的性质左中右，B左边的一定是B的左子树，所以C一定是B的左子树，我们也可以同时确定他是B的左子树的根节点
那么此时确定树的形态如下图 <img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125123121413.png" alt="image-20221125123121413" style="zoom:67%;" />

我们再查看与C有关的，也是通过中序遍历来查看，发现C没有左子树，也没有右子树（C,B之间没有点）。
我们查看B是否有右子树，发现B,A之间有两个点D,E，那么B的右子树由D,E组成。再通过后序遍历的性质左右中可以确定E是B右子树的根节点。
此时确定树的形态如下图 

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125123540470.png" alt="image-20221125123540470" style="zoom:67%;" />
再查看D，发现E是D的右子树，再发现F是A的右子树。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221124160154427.png" alt="image-20221124160154427" style="zoom:67%;" />
所以最后发现中序遍历和后序遍历**也可以确定一棵树**。

#### 总结：除了前序遍历和后序遍历不能确定一棵树，其他都能确定一棵树。

### 练习：

1. 假设一棵二叉树的后序遍历序列为 $\texttt{DGJHEBIFCA}$，中序遍历序列为$ \texttt{DBGEHJACIF}$，则其前序遍历序列为（）。（CSP 2021 普及组初赛试题）
    A. $\texttt{ABCDEFGHIJ}$    B.$ \texttt{ABDEGHJCFI} $   C. $\texttt{ABDEGJHCFI}$    D. $\texttt{ABDEGHJFIC}$

2. 前序遍历序列与中序遍历序列相同的二叉树为( )。（NOIP 2015 普及组初赛试题）

    A. 根结点无左子树 B. 根结点无右子树 C. 只有根结点的二叉树或非叶子结点只有左子树的二叉树 D. 只有根结点的二叉树或非叶子结点只有右子树的二叉树

### 13.5.7 特殊的树完全二叉树

其他性质我们之前已经说过了，现在想要说的就是如何去判断一棵树是否是完全二叉树？
倘若这棵树是完全二叉树，他从上到下，从左到右给树编号是和完全二叉树的编号一样，那么我们就只需要找到每一深度的编号是否满足完全二叉树的编号。
倘若这棵树的深度为3，那么深度为1的编号必须有1，深度为2的编号必须有2，3，深度为3的必须按照顺序拥有 4 ~ 7 这些点，或者我们遍历$1 - n$个编号判断是否全部编号都有一个点占用。

举个例子

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221125181731575.png" alt="image-20221125181731575" style="zoom:67%;" />
此图就不是一颗完全二叉树，因为最后一层有4 ，7没有5，6。

### 练习：

1. 一棵有 n 个结点的完全二叉树用数组进行存储与表示，已知根结点存储在数组的第 1 个位置。若存储在数组第 9 个位置的结点存在兄弟结点和两个子结点，则它的兄弟结点和右子结点的位置分别是（ ）。（ CSP-J 2022 第一轮）

   A. 8、18 

   B. 10、18 

   C. 8、19 

   D. 10、19 

2. 如果根的高度为 1，具有 61 个结点的完全二叉树的高度为（ ）。(NOIP 2015 普及组初赛)
   A. 5        B. 6          C. 7         D. 8

### 13.5.8 特殊的树哈弗曼树

#### 哈夫曼树相关的几个名词

**路径**：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 $a$ 之间的通路就是一条路径。

**路径长度**：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第$ i $层结点的路径长度为 $i - 1$ 。图 1 中从根结点到结点$ c$ 的路径长度为 $3$。

**结点的权**：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 $a$ 的权为 7，结点 $b$ 的权为 5。

**结点的带权路径长度**：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 $b$ 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

> WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

![img](http://c.biancheng.net/uploads/allimg/190427/09563Tb0-0.png)
图1

#### 什么是哈夫曼树

当用 $n $个结点（都做叶子结点且都有各自的权值）试图构建一棵二叉树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

#### 构建哈夫曼树的过程

对于给定的有各自权值的 $n$ 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 $n$ 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 $n$ 个权值中删除那两个最小的权值，同时将新的权值加入到 $n–2$ 个权值的行列中，以此类推；
3. 重复 $1$和 $2$，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![img](http://c.biancheng.net/uploads/allimg/190427/09563QS5-1.png)

图 2 哈夫曼树的构建过程

图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221201140601621.png" alt="image-20221201140601621" style="zoom:67%;" />
**做法1：**我们思考每次选择最小的两个点构建出一颗新树，新树的根节点是一个新的结点，并且这个节点的两个儿子节点我们是知道的，所以我们只需要存下这个新的节点，然后再放到序列里面排序即可，最后最新的节点就是根节点，再跑一遍dfs即可。

```
#include<iostream>
#include<queue>
#include<cstring>
#include<testlib.h>
using namespace std;
const int N = 2e6 + 10;
int n;
int has[N],id[N];
long long sum;
struct node{
    int id,w;
    bool operator < (const node &p)const{
        return w < p.w;
    }
}a[N];
struct node2{
    int w,l,r;
}b[N];
void dfs(int x,int pre){
    if(!b[x].l && !b[x].r) sum += b[x].w * pre;
    if(b[x].l) dfs(b[x].l,pre + 1);
    if(b[x].r && b[x].l) dfs(b[x].r,pre + 1);
    else if(b[x].r) dfs(b[x].r,pre);
}
int main(){
        cin >> n;
        memset(a,0,sizeof a);
        memset(b,0,sizeof b);
        sum = 0;
        for(int i = 1; i <= n; i++){
            int x;
            cin >> x;
            b[i].w = x;
            a[i].id = i;
            a[i].w = x;
        }
        int cnt = n;
        for(int i = 1 ; i <= n - 1; i++){
            sort(a + (i - 1) *  2 + 1, a + n + i);
            b[++cnt].w = a[(i - 1) *  2 + 1].w + a[(i - 1) *  2 + 2].w;
            b[cnt].l = a[(i - 1) *  2 + 1].id;
            b[cnt].r = a[(i - 1) *  2 + 2].id;
            a[cnt].id = cnt;
            a[cnt].w = b[cnt].w;
        }
        dfs(a[cnt].id,0);
        cout << sum << endl;
    return 0;
}
```

**做法2：**对于一颗哈夫曼树我们分析其树的每个节点被加了几次。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221201141208941.png" alt="image-20221201141208941" style="zoom:67%;" />
我们发现图中所有点的权值的和，就是我们 权值1，2，3，4构造一颗哈夫曼树产生的带权路径长度的和。

对于点D来说，在点D,C,F,G都产生了一次贡献，所以是4 *  1，点E在点E,C,F,G都产生了一次贡献所以是 2 * 4，以此类推。

所以构造一颗哈夫曼树能产生的最小的带权路径长度，就是每次从序列中选择两个最小的点，获取他们的权值，再把他们的权值放回序列中。

```
int cnt = n;
for(int i = 1; i <= n; i++){
	 sort(a + (i - 1) *  2 + 1, a + n + i);
	 int ans = sum;
	 sum += a[(i - 1) *  2 + 1];
	 sum += a[(i - 1) *  2 + 2];
	 a[++cnt] = sum - ans;
}
```

### 13.5.9 哈夫曼编码

**[哈夫曼](https://baike.baidu.com/item/哈夫曼?fromModule=lemma_inlink)**编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变[字长](https://baike.baidu.com/item/字长/97660?fromModule=lemma_inlink)编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据[字符](https://baike.baidu.com/item/字符/4768913?fromModule=lemma_inlink)出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。依据字符在文件中出现的频率来建立一个用`0,1`串表示各字符，使平均每个字符的码长最短的最优表现形式。[哈夫曼](https://so.csdn.net/so/search?q=哈夫曼&spm=1001.2101.3001.7020)编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间，通俗的来说把我们的文字或者字母全都转变成了 01 串。

在学习哈夫曼编码之前，首先应了解前缀码：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。比如：01，001，011就不满足前缀码的性质，因为011中包含01。而哈夫曼编码必须要满足前缀码的性质，否则会导致译码的时候出现多种译码方式，违背的唯一性准则。

例如 我们让 A 用 1来代替， B用 11 来代替。现在给出 11，他可以表示为 AA 也可以表示为 B，产生了歧义，所以一定要为前缀码。

那么哈夫曼编码到底怎么工作的呢？给出一个字符串比如说 ABCABCAAAB。 A 在这个字符串出现了5次，B 在这个字符串出现了 3 次，C 在这个字符串中出现了 2次，所以假设我们要把 A,B,C都变成二进制编码，现在有 3 个01串 比如 ：0，10，11 ，他们满足前缀码。我们让 A 变成谁比较好呢？ 那肯定是 0 比较好，因为 A出现的次数最多 编码0最短，这样最终产生的编码一定最短，占得空间最少。

具体是将所要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的的权值，以自底向上的方式、通过执行`n-1`次的“合并”运算后构造出最终所要求的树，即哈夫曼树，它的核心思想是让权值大的叶子离根最近。

那么为什么这样子能够保证正确呢？我们首先来看个例子。

对于a，b，c，d，e，f进行编码

<img src="C:\Users\Dell\Downloads\a69bc6ca52244914adad5191f2bbf956.png" alt="a69bc6ca52244914adad5191f2bbf956" style="zoom:50%;" />


第一次<img src="C:\Users\Dell\Downloads\110292660ea0465691046bbe8c3aa4e3.png" alt="110292660ea0465691046bbe8c3aa4e3" style="zoom:50%;" />
下一步<img src="C:\Users\Dell\Downloads\d1c74c049b8b47f2940049a5d13566ce.png" alt="d1c74c049b8b47f2940049a5d13566ce" style="zoom:50%;" />

下一步<img src="C:\Users\Dell\Downloads\d170f2311c7b4c43ab18c7d2ac1a80e8.png" alt="d170f2311c7b4c43ab18c7d2ac1a80e8" style="zoom:50%;" />


下一步<img src="C:\Users\Dell\Downloads\30c04aa582284f40811d068b14a330d1.png" alt="30c04aa582284f40811d068b14a330d1" style="zoom:50%;" />

下一步<img src="C:\Users\Dell\Downloads\5002eb1281004aa4b803f9b9d01c9a7f.png" alt="5002eb1281004aa4b803f9b9d01c9a7f" style="zoom:50%;" />

当我们产生树后如何给出编码呢？我们可以让连向左子树的边变为编码0，让连向右子树的边变为编码1。
那么 a 的编码就为 1，b 的编码为 011，c 的编码为010，d 的编码为 001，e的编码为 0001，f的编码为0000。我们发现他同时也满足前缀码的定义。
最终的结果<img src="C:\Users\Dell\Downloads\ccc752e7e4de499281a1bfda77e5af6c.png" alt="ccc752e7e4de499281a1bfda77e5af6c" style="zoom:50%;" />

### 练习：

1. 在数据压缩编码中的哈夫曼编码方法，在本质上是一种（ ）的策略。（CSP-J 2021 第一轮）
   A. 枚举 	B. 贪心 	C. 递归 	D. 动态规划
   
2. 假设字母表 {a, b, c, d, e} 在字符串出现的频率分别为 10%, 15%, 30%, 16%, 29%。若使用哈夫曼编码方式对字母进行不定长的二进制编码，字母 d 的编码长度为（ ）位。（CSP-J 2022 第一轮）

   A. 1 

   B. 2 

   C. 2 或 3 

   D. 3 

## 13.6 广度优先搜索

我们之前遍历树的方法是深度优先搜索，因为我们每次要先往深度高的地方去走，那么有没有一种方法让我们的树每次先把深度低的点走完再走深度较高的点呢？当然有了，我们假设有一种方法能够把当前层的点存下来，利用当前层的所有的点得到下一层的点，再重复这件事就好了。

大家先看一个例子 假设我现在已经用一个数组a 存下了树中的所有的点，满足第一层的点存在数组 a[$b_1$ ~ $c1$] 中，第二层存在了数组 a[$b_2$ ~ $c_2$]中，第 $i$ 层存在了数组 a[$b_i$ ~ $c_i$] 中，满足 $b_i = c_{i - 1} + 1$  也就是说我们 循环 从第一个位置直到最后一个位置，就是一层一层的往外扩，先把低层的遍历完再去遍历高层。那么我们现在的问题是，如何存下这样的一个数组呢？目前我们知道的只有第一层的点是根节点，那么我们就可以先把根节点放到数组第一个位置。那么如何拿到第二层呢？我们就可以通过邻接表来实现存储，然后找到所有第二层的点给他放到我第一层的数组位置的后边。第三层也是如此，假如我先循环把第二层的点先遍历了，把点都存到第二个点在数组位置后边即可。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208112745668.png" alt="image-20221208112745668" style="zoom: 67%;" />

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using std::cin;
using std::cout;
using std::endl;
using std::string;

const int N = 1000006;

std::vector<int>v[N];
 
int b[N],flag[N],dist[N];
void bfs(){
	int head = 0,ed = -1;
	b[++ed] = 1; //根节点 
	dist[1] = 1;
	flag[1] = 1;
	while(head <= ed){
		int k = v[b[head]].size();
		for(int i = 0; i < k; i++){
			int j = v[b[head]][i];
			if(!flag[j]){ //打上标记，表示我们走过这个点了 
				flag[j] = 1;
				b[++ed] = j;
				dist[j] = dist[b[head]] + 1; 
			}
		}
		++head;//表示这个点走过了 
	}
}
int main(){	
	int n;
	cin >> n;int x,y;
	for(int i = 1; i <= n - 1; i++){
		scanf("%d %d",&x,&y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	
	bfs();
	
	for(int i = 1; i <= n; i++){
		printf("%d\n",dist[i]);
	}
	
	return 0;
} 
```

我们发现假设有一个容器，每次拿出的是最先存进去的，我们也可以实现以上操作。
那么我们就要讲我们的数据结构（数据结构是在计算机中存储、组织数据的方式）队列。

## 13.7 队列

队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

### 11.7.1 数组模拟队列

通常用一个数组模拟一个队列，用两个变量标记队列的首尾。

```
int q[SIZE], ql = 1, qr = 0;
```

队列操作对应的代码如下：

- 插入元素：`q[++qr] = x;`
- 删除元素：`ql++;`
- 访问队首：`q[ql]`
- 访问队尾：`q[qr]`
- 清空队列：`ql = 1; qr = 0;`

### 11.7.2 C++ STL 中的队列

C++ 在 STL 中提供了一个容器 `std::queue`，使用前需要先引入 `<queue>` 头文件。

STL 中的 `queue` 容器提供了一众成员函数以供调用。其中较为常用的有：

- 元素访问
  - `q.front()` 返回队首元素
  - `q.back()` 返回队尾元素
- 修改
  - `q.push()` 在队尾插入元素
  - `q.pop()` 弹出队首元素
- 容量
  - `q.empty()` 队列是否为空
  - `q.size()` 返回队列中元素的数量

此外，`queue` 还提供了一些运算符。较为常用的是使用赋值运算符 `=` 为 `queue` 赋值，示例：

```
std::queue<int> q1, q2;

// 向 q1 的队尾插入 1
q1.push(1);

// 将 q1 赋值给 q2
q2 = q1;

// 输出 q2 的队首元素
std::cout << q2.front() << std::endl;
// 输出: 1
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208112745668.png" alt="image-20221208112745668" style="zoom: 67%;" />
那么这道题就可以这样写

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using std::cin;
using std::cout;
using std::endl;
using std::string;

const int N = 1000006;

std::vector<int>v[N];
 
int b[N],flag[N],dist[N];
void bfs(){
	std::queue<int>q;
	q.push(1);
	dist[1] = 1;
	flag[1] = 1;
	while(q.size()){
		int k = q.front();
		q.pop();
		for(int i = 0; i < v[k].size(); i++){
			int j = v[k][i];
			if(!flag[j]){ //打上标记，表示我们走过这个点了 
				flag[j] = 1;
				q.push(j);
				dist[j] = dist[b[head]] + 1; 
			}
		}
		++head;//表示这个点走过了 
	}
}
int main(){	
	int n;
	cin >> n;int x,y;
	for(int i = 1; i <= n - 1; i++){
		scanf("%d %d",&x,&y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	
	bfs();
	
	for(int i = 1; i <= n; i++){
		printf("%d\n",dist[i]);
	}
	
	return 0;
} 
```

## 13.8 栈

栈和队列恰好相反，队列是先进先出，栈是先进后出。

栈的修改是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。

当然我们也可以用数组模拟栈，这个就由同学们自己去发掘吧。

### 13.8.1 数组模拟栈

通常用一个数组模拟一个栈，用两个变量标记队列的首尾。

```
int q[SIZE], ql = 1, qr = 0;
```

队列操作对应的代码如下：

- 插入元素：`q[++qr] = x;`
- 删除元素：`qr--;`
- 访问队首：`q[qr]`
- 访问队尾：`q[ql]`
- 清空队列：`ql = 1; qr = 0;`

### 13.8.2 C++ STL 中的栈

C++ 中的 STL 也提供了一个容器 `std::stack`，使用前需要引入 `stack` 头文件。

STL 中的 `stack` 容器提供了一众成员函数以供调用，其中较为常用的有：

- 元素访问

  - `st.top()` 返回栈顶

- 修改

  - `st.push()` 插入传入的参数到栈顶
  - `st.pop()` 弹出栈顶

- 容量

  - `st.empty()` 返回是否为空
  - `st.size()` 返回元素数量

  此外，`std::stack` 还提供了一些运算符。较为常用的是使用赋值运算符 `=` 为 `stack` 赋值，示例：

  ```
  
  // 新建两个栈 st1 和 st2
  std::stack<int> st1, st2;
  
  // 为 st1 装入 1
  st1.push(1);
  
  // 将 st1 赋值给 st2
  st2 = st1;
  
  // 输出 st2 的栈顶元素
  cout << st2.top() << endl;
  // 输出: 1
  ```


### 练习：

1. 对于入栈顺序为 a, b, c, d, e的序列，下列（ ）不是合法的出栈序列。（CSP 2021 入门级第一轮）
   A. a, b, c, d, e	B. e, d, c, b, a	 C. b, a, c, d, e	 D. c, d, a, e, b

2. 有 6 个元素，按照 6、5、4、3、2、1 的顺序进入栈 S，请问下列哪个出栈序列是非法的（ ）。（CSP 2022入门级第一轮）

   A. 5 4 3 6 1 2 

   B. 4 5 3 1 2 6 

   C. 3 4 6 5 2 1 

   D. 2 3 4 1 5 6 

3. 对假设栈 S 和队列 Q 的初始状态为空。存在 e1~e6 六个互不相同的数据，每个数据按照进栈 S、出栈 S、进队列 Q、出队列 Q 的顺序操作，不同数据间的操作可能会交错。已知栈 S 中依次有数据 e1、e2、e3、e4、e5 和 e6 进栈，队列 Q 依次有数据 e2、e4、e3、e6、e5 和 e1 出队列。则栈 S 的容量至少是（ ）个数据。（CSP 2022入门级第一轮）

   A. 2 

   B. 3 

   C. 4 

   D. 6 

4. 以下对数据结构的表述不恰当的一项为：（ ）。（CSP 2022入门级第一轮）

   A. 图的深度优先遍历算法常使用的数据结构为栈。

   B. 栈的访问原则为后进先出，队列的访问原则是先进先出。

   C. 队列常常被用于广度优先搜索算法。

   D. 栈与队列存在本质不同，无法用栈实现队列。

5. 下图中所使用的数据结构是（ ）。(NOIP 2018 普及组初赛试题)

   ![img](https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/youti/95.png)

   A. 哈希表		 B. 栈 		C. 队列 		D. 二叉树

6. 今有一空栈 S，对下列待进栈的数据元素序列 a,b,c,d,e,f依次进行进栈，进栈，出栈，进栈， 进栈，出栈的操作，则此操作完成后，栈 S的栈顶元素为（）
   A. f         B. c           C. a          D. b

7. 对于入栈顺序为 a, b, c, d, e, f, g 的序列，下列（ ）不可能是合法的出栈序列。 (NOIP 2017 普及组初赛试题)
    A. a, b, c, d, e, f        B. a, d, c, b, e, g, f          C. a, d, b, c, g, f, e         D. g, f, e, d, c, b, a

## 13.9 树的遍历2

我们可以通过bfs来遍历整棵树，但是我们没法通过bfs获得每颗子树信息。所以bfs遍历就是为了防止爆栈，所以当我们无需子树的信息的时候，可以使用bfs遍历。

### 示例题目

求得树上每个点的深度。点的数量 <= 3 * 10^7^。

**思路**：通过bfs求出即可

## 13.10 树的性质运用

1. 因为是一棵树，所以树上的每两个点一定可以通过有且一条路径互相到达
2. 当我们明确树上不需要子树以及父亲节点的信息的时候，无论我们规定哪个点是树根都无所谓
3. 树上无论给哪两个点加上一条边都会产生一个环

### 13.10.1 示例1

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111125658923.png" alt="image-20221111125658923" style="zoom:67%;" />
**思路**：因为树上每两个点之间都能互相到达，所以经过点$m$的链可以经过所有点，所以最后只要输出点权最大值即可

### 13.10.2 示例2

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111132327064.png" alt="image-20221111132327064" style="zoom: 67%;" />
**思路：**只需要把其中一个端点当作树根，跑到另一个端点上即可，因为树上的两个点之间有且只有一条路径可以互相到达

### 13.10.3 示例3

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111141122929.png" alt="image-20221111141122929" style="zoom:67%;" />
**思路：**此题要找到关于子树的性质，所以我们只能确定点1为树根，跑dfs。dfs重复的动作是，取其子树的最大值，那么当是叶子节点的时候直接返回当前值。

# 14.普遍的图

## 14.1图的基本概念

普遍的图分为两种图一种是无向图，一种是有向图

无向图顾名思义边没有方向，即 点 a,b 之间有条边，点 a 可以通过这条边走到 b，点 b 可以通过这条边走到 a。

有向图顾名思义边有方向，即 点 a,b 之间有条边，点 a 可以通过这条边走到 b，点 b 不可以通过这条边走到 a。

### 连通图

在[图论](https://baike.baidu.com/item/图论/1433806?fromModule=lemma_inlink)中，连通图基于[连通](https://baike.baidu.com/item/连通/8663628?fromModule=lemma_inlink)的概念。在一个[无向图](https://baike.baidu.com/item/无向图/1680427?fromModule=lemma_inlink) G 中，若从[顶点](https://baike.baidu.com/item/顶点/11030118?fromModule=lemma_inlink)$i$到顶点$j$有路径相连（当然从$j$到$i$也一定有路径），则称$i$和$j$是连通的。如果 G 是[有向图](https://baike.baidu.com/item/有向图?fromModule=lemma_inlink)，那么连接$i$和$j$的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。**无向图的连通图称作弱连通图**，**有向图的连通图称作强连通图**。判断一张图是否是连通图，通过bfs跑一遍即可

### 简单图

简单图就是图中没有环，没有重边（两个顶点存在两条及以上的的边）。


### 无向完全图

无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。


### 有向完全图

有向完全图：在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。


### 稀疏图

称边数很少的图为稀疏图

### 稠密图

称边数很多的图为稠密图

### 顶点的度

在无向图中，顶点v的度是指依附于该顶点的边数，通常记为TD (v)

### 顶点的入度

在有向图中，顶点v的入度是指以该顶点为弧头的弧的数目，记为ID (v)

### 顶点的出度

在有向图中，顶点v的出度是指以该顶点为弧尾的弧的数目，记为OD (v)

### 权

是指对边赋予的有意义的数值量

### 回路（环）

第一个顶点和最后一个顶点相同的路径

### 简单路径

序列中顶点不重复出现的路径

### 简单回路（简单环）

除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路

### 子图

若图G=（V，E），G’=（V’，E’），如果V’属于V且E’属于E ，则称图G’是G的子图


### 练习：

1. 对于有 $n$个顶点、$m$条边的无向连通图 $(m>n)$，需要删掉（ ）条边才能使其成为一棵树。( CSP-J 2021 第一轮)
    A. $n-1$ 	B. $m-n$ 	C. $m-n-1$ 	D. $m-n+1$

2. 考虑由 N 个顶点构成的有向连通图，采用邻接矩阵的数据结构表示时，该矩阵中至少存在（ ）个非零元素。( CSP-J 2022 第一轮)

   A. $N-1$ 	B. $N$ 	C. $N+1$ 	D. $N^2$

3. 设简单无向图 G 有 16 条边且每个顶点的度数都是 2，则图 G 有( )个顶点。(NOIP 2016 普及组初赛试题)
   A. 10        B. 12       C. 8       D. 16

4. 在无向图中，所有顶点的度数之和是边数的( )倍.(NOIP 2014 提高组初赛)
   A. 0.5        B. 1        C. 2         D. 4

5. 有 10 个顶点的无向图至少应该有（ ）条边才能确保是一个连通图。(CSP 2020 入门级第一轮)
   A. 9         B. 10         C. 11         D. 12

## 14.2图的遍历

我们写过树的遍历，因为树是一种特殊情况没有环，但是一般的图都可能有环，所以我们现在要讲一下普遍图的遍历方法。

同样的遍历方法还是分为 深度优先搜索和广度优先搜索

### 14.2.1 边的长度相同

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208172125739.png" alt="image-20221208172125739" style="zoom:67%;" />
**思路：**边的长度相同的时候，假设离起点为 $1$ 的当作第一层，距离起点为 $2$的当作第二层.....这样只需要跑一遍bfs，就是最短路。

```
#include<iostream>
#include<cstring>
#include<testlib.h>
#include<queue>

using namespace std;

const int N = 1e3+ 10;

struct node{
    int x,y;
};
int x[N] = {0,1,-1,0};
int y[N] = {1,0,0,-1};

int dist[N][N],flag[N][N],c[N][N];
int n,m,t;
void bfs(){
    queue<node>q;
    q.push({1,1});
    memset(dist,0,sizeof dist);
    dist[1][1] = 1;

    while(q.size()){
        node p = q.front();
        q.pop();
        for(int i = 0; i < 4; i++){
            int xx = p.x + x[i],yy = p.y + y[i];
            if(xx > n || xx < 1 || yy > m || yy < 1 || c[xx][yy] == 1) continue;
            if(!dist[xx][yy]){
                dist[xx][yy] = dist[p.x][p.y] + 1;
                q.push({xx,yy});
            }
        }
    }
}

int main(){

        cin >> n >> m >> t;
        memset(c,0,sizeof c);
        for(int i = 1; i <= t; i++){
            int x,y;
            scanf("%d %d",&x,&y);
            c[x][y] = 1;
        }
        bfs();
        if(dist[n][m] != 0x3f3f3f3f)
            cout << dist[n][m] - 1 << endl;
        else cout << -1 << endl;
    return 0;
}

```

### 14.2.2 边的长度不同

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208172423051.png" alt="image-20221208172423051" style="zoom:67%;" />
**思路：**边的长度不同的时候我们用 bfs 和 dfs走过的方式都不一定是最短的，所以我们使用的时候一定要判断是不是最短的那条路径，如果不是最短的那条路径我们要重新走一遍。

```
#include<iostream>
#include<cstring>
#include<testlib.h>
#include<queue>

using namespace std;

const int N = 1e2+ 10;
struct node{
    int x,y;
};
int x[N] = {0,1,-1,0};
int y[N] = {1,0,0,-1};

int dist[N][N],a[N][N],c[N][N],b[N][N];
int n,m,t;
void bfs(){
    queue<node>q;
    q.push({1,1});
    memset(dist,0x3f,sizeof dist);
    dist[1][1] = 0;

    while(q.size()){
        node p = q.front();
        q.pop();
        for(int i = 0; i < 4; i++){
            int xx = p.x + x[i],yy = p.y + y[i];
            if(xx > n || xx < 1 || yy > m || yy < 1 || c[xx][yy] == 1) continue;
            if(y[i] == 1){
                if(dist[xx][yy] > dist[p.x][p.y] + a[p.x][p.y]){
                    dist[xx][yy] = dist[p.x][p.y] + a[p.x][p.y];
                    q.push({xx,yy});
                }
            }else if(y[i] == -1){
                if(dist[xx][yy] > dist[p.x][p.y] + a[xx][yy]){
                    dist[xx][yy] = dist[p.x][p.y] + a[xx][yy];
                    q.push({xx,yy});
                }
            }else if(x[i] == 1){
                if(dist[xx][yy] > dist[p.x][p.y] + b[p.x][p.y]){
                    dist[xx][yy] = dist[p.x][p.y] + b[p.x][p.y];
                    q.push({xx,yy});
                }
            }else{
                if(dist[xx][yy] > dist[p.x][p.y] + b[xx][yy]){
                    dist[xx][yy] = dist[p.x][p.y] + b[xx][yy];
                    q.push({xx,yy});
                }
            }

        }
	}
}

int main(){

        memset(a,0,sizeof a);
        memset(b,0,sizeof b);
        cin >> n >> m >> t;
        memset(c,0,sizeof c);
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m - 1; j++){
                scanf("%d",&a[i][j]);
            }
        }
        for(int i = 1; i <= n - 1; i++){
            for(int j = 1; j <= m; j++){
                scanf("%d",&b[i][j]);
            }
        }
        for(int i = 1; i <= t; i++){
            int x,y;
            scanf("%d %d",&x,&y);
            c[x][y] = 1;
        }
        bfs();
        if(dist[n][m] != 0x3f3f3f3f)
            cout << dist[n][m] << endl;
        else cout << -1 << endl;

    return 0;
}
```



### **14.2.3 边的长度相同求方案数**

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208160348670.png" alt="image-20221208160348670" style="zoom:67%;" />
**思路：**由于边相同我们bfs走到的点一定是最短路径，所以我们只需要$O(n * m)$的复杂度就够了，倘若使用dfs的话由于dfs每走到终点算一条路径，我们的路径数量很多就会导致超时，复杂度大概是$O(2^{n * m})$

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<testlib.h>
#include<queue>
using std::cin;
using std::cout;
using std::endl;
using std::string;

const int N = 1110,mod = 1e9 + 7;
struct node{
	int x,y;
};
int x[N] = {0,1,-1,0};
int y[N] = {1,0,0,-1};
int dist[N][N];
long long shu[N][N];
int b[N],c[N][N];
int n,m,t;
void bfs(){
	std::queue<node>q;
    q.push({1,1});
    memset(dist,0x3f,sizeof dist);
    dist[1][1] = 0;
    shu[1][1] = 1;
    while(q.size()){
        node p = q.front();
        q.pop();
        for(int i = 0; i < 4; i++){
            int xx = p.x + x[i],yy = p.y + y[i];
            if(xx > n || xx < 1 || yy > m || yy < 1 || c[xx][yy] == 1) continue;
            if(dist[xx][yy] > dist[p.x][p.y] + 1){
                dist[xx][yy] = dist[p.x][p.y] + 1;
                shu[xx][yy] = shu[p.x][p.y];
                q.push({xx,yy});
            }else if(dist[xx][yy] == dist[p.x][p.y] + 1){
            	shu[xx][yy] += shu[p.x][p.y];
            	shu[xx][yy] %= mod;
			}
        }
    }
}
int main(){

        cin >> n >> m >> t;
        memset(c,0,sizeof c);
        memset(shu,0,sizeof shu);
        for(int i = 1; i <= t; i++){
            int x,y;
            scanf("%d %d",&x,&y);
            c[x][y] = 1;
        }
        bfs();
        cout << shu[n][m] << endl;
	return 0;
}
```



### 14.2.4边的长度不相同求方案数

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221208135329133.png" alt="image-20221208135329133" style="zoom: 67%;" />
**思路：**对于这种不讲究路径长度的方案数我们无法使用bfs去做，因为bfs无法确定下一个点到底有没有走过，所以我们必须使用dfs去遍历整张图，一共有$5 * 5$个点。复杂度不好计算，我们大约理解为 $o(2^{n*m})$

```
#include<bits/stdc++.h>
using namespace std;
int xq,yq,xz,yz;
int sum = 0;
int xx[4] = {0,0,1,-1};
int yy[4] = {1,-1,0,0};
int c[10][10] = {0};
int flag[10][10] = {0};
int n,m,t;
bool pan(int x,int y){
	if(x < 1 || x > n || y < 1 || y > m) return false;
	return true;
}
void f(int x,int y){
	if(x == xz && y == yz){
		sum += 1;
		return;
	}
	for(int i = 0; i < 4; i++){
		if(flag[x + xx[i]][y + yy[i]] == 0 && c[x + xx[i]][y + yy[i]] != 1 && pan(x + xx[i],y + yy[i])){
			flag[x + xx[i]][y + yy[i]] = 1;
			f(x + xx[i],y + yy[i]);
			flag[x + xx[i]][y + yy[i]] = 0;
		}
	}
	return;
}
int main(){
	cin>>n>>m>>t;
	cin>>xq>>yq>>xz>>yz;
	int a,b;
	for(int i = 1; i <= t; i++){
		cin>>a>>b;
		c[a][b] = 1;
	}
	flag[xq][yq] = 1;
	f(xq,yq);
	cout<<sum;
	return 0;
}
```

# 15.初等数论

## 15.1整数的基本性质

设a,b是两个整数，其中b != 0。如果存在一个整数q使得等式 a = bq成立，就称b整除a或者a被b整除记作b|a，并把b叫作a的因数，把a叫作b的倍数。这时，q也是a的因数，我们常常将q写成a / b; 
在C++中用 a % b == 0表示整除

整除的一些常用结论:

1. 当b遍历整数a的所有因数时，-b也遍历也遍历整数a的所有因数

2. 当b遍历整数a的所有因数时，a/b也遍历整数a的所有因数
   所以对于此来说 1~sqrt(a)的因子和sqrt(a) + 1 ~ a的因子一一对应
   所以我们求数a的因子有哪些的代码通常这样写

   ```
   for(int i = 2; i * i <= a; i++){
   	if(a % i != 0) continue;
   	if(i * i == a) b[++cnt] = i;
   	else b[++cnt] = i,b[++cnt] = a / i;
   }
   ```

3. 设b，c都是非零整数

   1. 若b | a，则 |b| | |a|
   2. 若 b | a，则 bc | ac
   3. 若 b | a，则 1< |b| <= |a|
   4. 若 b | a，a | c 那么 b | c
   5. 若 b | a，b | c 那么任意 整数x，y使得 b | ax + cy
   6. 设 a != 0,b = q * a + c 那么 a | b $\Longleftrightarrow$ a| c
   
4. 整除不满足结合律也不满足交换律
   假设 x = k * m + c，y = s * m + d，满足c + d = m
   那么 (x + y) / m = k + s + 1，x / m + y / m = k + s
   假设 x = k * m + c，那么 x / m * m = k * m，x * m / m = k * m + c

------

### **练习：**

​	1.苹果丰收，得到了120个苹果，恰好平分给x个小朋友（每个小朋友拿到的苹果数量一样) 请问，x能取那些值





​	2.找循环节。给定一个长度为n的字符串，求它的最小循环节长度，n <= 10^5^。例如输入 "abbaabbaabba" 输出4





​	3.洛谷P2926。给定n和n个正整数，求每个数是另外多少个数的倍数，n <= 10^5^，其他数字a~i~不超过 10^6^。例如给出5个数，分别是2，1，2，3，4。答案输出 2，0，2，1，3





​	4.洛谷P1403

![image-20220923152838729](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220923152838729.png)


N <= 10^6^



















**拓展:**

![image-20220923152838729](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220923152838729.png)


N <= 10^9^





























洛谷P2424

![image-20220923155352591](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220923155352591.png)



X,Y <= 10^9^



------

## 15.2素数

**设n为一个正整数且n != 1，倘若n的因子只有自己本身和1的话他就是个素数(又称质数，不可约数)，其他的数称为合数**

**特殊的 0，1既不是质数也不是合数，所以最小的质数是2，最小的合数是4**

**规定:若没有特殊说明，素数一般指正整数，用p~1~,p~2~.....p~n~表示**

p 和 -p总是同为素数或者同为合数。**如果没有特别说明，素数总是指正的素数。**

整数的因数是素数，则该素数称为该整数的素因数（素约数）。

素数与合数的简单性质：

- 大于1的整数a是合数，等价于a可以表示为整数d 和e（1<d,e<a）的乘积。
- 如果素数p有大于1的约数 d，那么 d = p 。
- 大于1的整数a一定可以表示为素数的乘积。
- 对于合数a，一定存在素数 p <= $\sqrt{a}$使得  p | a。
- 素数有无穷多个。
- 所有大于3的素数都可以表示为6n士1 的形式。
  证明:当n表示自然数的时候，用6n、6n+1、6n+2、6n+3、6n+4、6n+5就可以表示所有的自然数。其中，6n是6的倍数，一定不是质数；
  6n+2是偶数，只有n=0时，6n+2=2是质数；
  6n+3是3的倍数，只有n=0时，6n+3=3是质数；
  6n+4是偶数，并且大于2，一定不是质数；
  所以，在n＞0的情况下，只有6n+1和6n+5才可能是质数。
  而6n+5也可以用6n–1表示，如n=1时，6n+5=11；n =2时，6n–1=11。
  这就证明了，大于3质数，都是形如6n+1或6n–1的数。

若gcd(a,b,c,d) = 1 则称 a,b,c,d互素(质数)

### 13.2.1 算术基本定理:任何一个大于1的[自然数](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394)N,如果N不为**质数**，那么N可以**唯一**分解成有限个质数的乘积.

x = $p_{1}^{a_1}$ * $p_{2}^{a_2}$  * ..... * $p_{n}^{a_n}$ 

#### 存在性证明:

**反证法**

假设存在不能**分解成有限个质数**的乘积的[合数](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%90%88%E6%95%B0/49186%3Ffr%3Daladdin)，则其中必有一个**最小**的数（[最小数原理](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E6%95%B0%E5%8E%9F%E7%90%86/6062268%3Ffr%3Daladdin)）设为n.

n不是**质数**，所以存在大于1小于n的自然数a,b，使n=ab.

∃a,b∈N∧1<a,b<n⇒n=ab

- 如果a，b都为**质数**，与假设矛盾.
- 如果a，b**至少**有一个是**合数**,因为都比n要小，所以这个合数一定可以被分解成有限个质数的乘积，将乘积替换，可推出n可以分解成有限个质数的乘积，与假设矛盾.

所以原命题成立.

#### 唯一性证明：

**反证法**

[欧几里得引理](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%BC%95%E7%90%86/7642654%3Ffr%3Daladdin)**：**如果 p是素数且p|bc，那么p|b或者p|c.

假设存在某些数，它们有能分解为两种**不同**的质数乘积，将其中**最小**的数设为n

$n=p_1p_2p_3···p_r=q_1q_2q_3···q_s$

因为$p_1 可以除以 (q_1)(q_2q_3···q_s) ,由欧几里得引理得出p_1丨q_1 或者p_1丨q_2q_3···q_s$ （注意这里设的p和q全为**质数**）

所以可以得到 $p_1=q_1 或者 p_1=q_i$(2≤i≤s,i∈k)

上面任意一种情况，等可以将原式子左右两边同时**消掉**一个数，这样就得到了一个**更小的数**能表示两种质数乘积，与**n是最小数**的假设矛盾，唯一性得证.

### 练习:

1. 给定 n 个正整数 a~i~，判定每个数是否是质数。 n <= 100, a~i~ <= 1e9

   

   

2. 给定 n 个正整数 a~i~，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。 n <= 100, a~i~ <= 1e9

   

   

3. 洛谷U248208给定一个正整数 n，请你求出 1∼n 中质数的个数。 n <= 1e6

   

   

4. 给定一个正整数 n，请你求出 1∼n 中质数的个数。 n <= 1e7

   

5. ###### U248212哥德巴赫猜想的内容如下：

   任意一个大于 4 的偶数都可以拆成两个奇素数之和。

   例如：

   8=3+5

   20=3+17=7+13

   42=5+37=11+31=13+29=19+23

   现在，你的任务是验证所有小于一百万的偶数能否满足哥德巴赫猜想。 n<=1e6

   

   

6. 100 以内最大的素数是（）（CSP 2019 入门级第一轮）
    A. 89 B. 97 C. 91 D. 93

## 15.3余数

![image-20220928142743050](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928142743050.png)
**运算取mod：**设$a_1 = b*k_1 + c_1$   $a_2 = b * k_2 + c_2$
求证： $(a_1 + a_2) \% b  = (a_1 \% b + a_2 \% b) \% b$
$(a_1 \% b + a_2 \% b) \% b =  (c_1 + c_2)  \%  b$
又因为   $(a_1 + a_2)  \% b = (b * (k_1 + k_2) + c_1 + c_2) \% b = (c_1 + c_2)\% b$
所以$(a_1 + a_2)  \% b = (a_1 \% b +  a_2 \% b) \% b$
求证：$(a_1\% b * a_2 \% b) \% b = (a_1 * a_2) \% b$
$(a_1 * a_2) \% b =  (b^2 * k_1 * k_2 + c_1 * b * k_2 + c_1 * c_2) \% b = (c_1 * c_2) \% b$
又因为 $a_1 \% b$ = $c_1 \% b$ = $c_1$ ，$a_1 \% b * a_2 \% b = (c_1 * b * k2 + c_1 * c_2) \% b = (c_1 * c_2) \% b$
所以$(a_1 \% b * a_2\% b) \% b = (a_1 * a_2) \% b$
所以取模运算也满足分配律和结合律

**除法中的取mod**
求证：$(a \% b / x) \% b$ != $a / x \% b$
假设 $a = (k_1 * x  + c) = (k_2 * b + d),d = k_3 * x + e$
$(a \% b / x) \% b == k_3 \% b$
$a /x \% b== k_1 \% b$
我们发现只要满足 $k_1 != k_3$即可满足条件，当 $k_1 == k_3满足 a = (k_1 * x + c) = (k_2 * b + k_1*x + e)$
因为 $d < b$ 所以 $k_2 == 0$，所以此时 $a == d$ 满足 $b > a$
所以当 $b > a$原式子成立

### 练习:

1. 洛谷U248267 给定两个整数a,b输出$a^1$，$a^2$....，$a^b$，输出可能很大所以答案对于1e9+7取模 a,b <= 10^6^

   

2. 洛谷ABC275B $输入 A,B,C,D,E,F(0\le A,B,C,D,E,F\le10^{18})$，$输出 (A\times B\times C)-(D\times E \times F) \mod 998244353$

   

   

## 15.4同余

同余的定义：设整数m≠0。若m | (a - b)，称m为模数（模），a同余于b模m，b是a对模m的剩余。记作 a $\equiv $b(mod m)。
否则，a不同于b模m，b不是a对模m的剩余。
这样的等式，称为模m的同余式，简称同余式。
根据整除的性质， a $\equiv $b(mod -m) **如果没有特别说明模数一般是正整数**
式中的b是a对模m的剩余，这个概念与余数完全一致。通过限定b的范围，相应的有a对模m的最小非负剩余、绝对最小剩余、最小正剩余。

![image-20220927181349482](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220927181349482.png)



### 证明


1. 自反性：m | (a - a) 
2. 对称性：若 m | (a - b)满足，m | (b - a)满足。
3. 传递性：若 m | (a - b)满足，m | (b - c)满足，假设 (a - b) = k * m，(b - c) = s * m，那么 a - c = (k + s) * m，所以满足 m | (a - c)
4. 线性运算：若 m | (a - b)满足，m | (c - d)满足，
   假设 (a - b) = k * m，(c - d) = s * m，
   那么 a = b + k * m,c = d + s * m，a - c = b - d + k * m - s * m，
   那么 a - c - (b - d) = k * m - s * m，
   所以满足 a + c $\equiv $ b + d(mod m) 。减法亦然
   若 m | (a - b)满足，m | (c - d)满足，
   假设 (a - b) = k * m，(c - d) = s * m，
   那么 a = b + k * m,c = d + s * m，a * c = (b * d + b * s * m + d * k * m + k * m * s * m)，
   那么 a * c - b * d = (b * s * m + d * k * m + k * m * s * m)
   所以 a * c $\equiv $ b * d(mod m)
5. 假设 m | (a - b)，m * c = (a - b) 。那么 (a - b ) * k = m * c * k，所以 a * k $\equiv $ b * k (mod mk)
6. 假设 d | a，d | b，d | m，倘若满足 m | (a - b) ，因为 d | m 所以  m / d | (a - b) / d，所以  ![image-20221209121740881](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221209121740881.png)
7. 假设 d | m，m | (a - b)，那么 d | (a - b)
8. 假设 m| (a - b)，(a - b) = p * m，有 gcd(a,m) = gcd(b,m) = d，倘若 d | m，d | a，设 m = k * d，a = s * d，又因为 (a - b) = p * m
   所以 b = -p * m + a = -p * m + s * d = -p * k * d + s * d，所以 d | b。其他条件亦然如此

**乘法逆元**: 如果一个线性同余方程ax $\equiv $1(mod b)  ，则称x为a mod b的逆元，记作a^-1^

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928115506240.png" alt="image-20220928115506240" style="zoom: 80%;" />

```
inv[1] = 1;// 代表 i的逆元
for (int i = 2; i <= n; ++i) {
  inv[i] = (long long)(p - p / i) * inv[p % i] % p;
}
```



### 练习：

1. 洛谷P3811给定一个数n求解 1 ~ n每个数的逆元，n <= 3e6

   

   

## 15.5约数

其实上边讲整除的时候讲过一部分了，但是这里主要是做练习

### 练习:

1. 洛谷U248278 给定 n 个正整数 $a_i$，请你输出这些数的乘积的约数个数，答案对 10^9^+7取模。

   

   

2. 洛谷U248283 给定 n 个正整数 $a_i$，请你输出这些数的乘积的约数之和，答案对 10^9^+7取模。

   

   

   

## 15.6最大公约数

如果我们已知两个数a和b，如何求出二者的最大公约数呢？

叫做欧几里得算法。

不妨设 a > b

我们发现如果b是a的约数，那么b就是二者的最大公约数。 下面讨论不能整除的情况，即a = b * q + r ，其中 r < b。

我们通过证明可以得到 gcd(a,b) = gcd(b,a mod b)，过程如下

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220927222221203.png" alt="image-20220927222221203"  />

```
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928155957614.png" alt="image-20220928155957614"  />


### 练习

1. 319 和 377377 的最大公约数是（）。（CSP 2019 入门级第一轮）
    A. 27 B. 33 C. 29 D. 31

## 15.7最小公倍数

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928160026725.png" alt="image-20220928160026725" style="zoom:67%;" />

## 15.8埃拉托斯特尼筛法

### 过程

考虑这样一件事情：对于任意一个大于1的正整数n，那么它的x倍就是合数（x > 1）。利用这个结论，我们可以避免很多次不必要的检测。

如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。

```
// C++ Version
int Eratosthenes(int n) {
  int p = 0;
  for (int i = 0; i <= n; ++i) is_prime[i] = 1;
  is_prime[0] = is_prime[1] = 0;
  for (int i = 2; i <= n; ++i) {
    if (is_prime[i]) {
      prime[p++] = i;  // prime[p]是i,后置自增运算代表当前素数数量
      if ((long long)i * i <= n)
        for (int j = i * i; j <= n; j += i)
          // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i
          // 的倍数开始，提高了运行速度
          is_prime[j] = 0;  // 是i的倍数的均不是素数
    }
  }
  return p;
}
```

优化：对于 整数n来说 $\sqrt{n}$ ~ n的合数来说他们的质因子一定是在 1~$\sqrt{n}$所以我们只需要求解 1~$\sqrt{n}$的质因数的个数，并且把$\sqrt{n}$ ~ n的合数都记录下来就知道1~n的质数个数了

```
// C++ Version
int n;
vector<char> is_prime(n + 1, true);
is_prime[0] = is_prime[1] = false;
for (int i = 2; i * i <= n; i++) {
  if (is_prime[i]) {
    for (int j = i * i; j <= n; j += i) is_prime[j] = false;
  }
}
```

## 15.9线性筛

线性筛思想：**这个合数只会被它的最大非自身因数（对应最小质因数）筛。** 这样能保证每个合数只会被筛一次。

我们发现埃氏筛还是有很多重复的筛过的，例如 30 = 3 * 10 = 2 * 15 所以我们思考优化筛过的重复的
通过x = $p_{1}^{a_1}$ * $p_{2}^{a_2}$  * ..... * $p_{n}^{a_n}$  我们发现我们每个数都有一个最小素因数，假设我们使用他来做数字的标记，我们就可以达到每个数字只被筛选一次。对于一个数字 x 来说，我们从小到大使用质数给 x * 质数 打上标记，直到遇到 x 的最小素因数。

```
// C++ Version
void init() {
  for (int i = 2; i < MAXN; ++i) {
    if (!vis[i]) {
      pri[cnt++] = i;
    }
    for (int j = 0; j < cnt; ++j) {
      if (1ll * i * pri[j] >= MAXN) break;
      vis[i * pri[j]] = 1;
      if (i % pri[j] == 0) {
        // i % pri[j] == 0
        // 换言之，i 之前被 pri[j] 筛过了
        // 由于 pri 里面质数是从小到大的，所以 pri[j]就是他的最小素因数
        break;
      }
    }
  }
}
```

# 16.简单数据结构

## 16.1链表

链表是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749?fromModule=lemma_inlink)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782?fromModule=lemma_inlink)，[数据元素](https://baike.baidu.com/item/数据元素/715313?fromModule=lemma_inlink)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素?fromModule=lemma_inlink)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域。 相比于[线性表](https://baike.baidu.com/item/线性表/3228081?fromModule=lemma_inlink)[顺序结构](https://baike.baidu.com/item/顺序结构/9845234?fromModule=lemma_inlink)，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到$O(1)$的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要$O(n)$的时间，而线性表和顺序表相应的时间复杂度分别是$O(logn)$和$O(1)$。
![image-20221223104456308](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223104456308.png)

### 插入

![image-20221223104735712](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223104735712.png)

```
struct node{
	int x; //数据域
	node *next; //指针域 
}a[1000];
node head;
void insert(int x,node y){ //假设要把y 插入到数据域为x的后边 
	node s = head;   //表头，用来记录链表的第一个位置
	while(s.x != x){  //我们发现查找是 o(n)的
		s = *(s.next);
	}
	y.next = s.next;   //插入时 o(1)的
	s.next = &y;
}
```

不过指针形式的链表我们一般不使用，我们一般都是使用数组来模拟我们的链表

模拟链表一共有两种形态：

1. 数据不重复链表
2. 数据充符链表

### 16.1.1数据不重复链表

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223105719842.png" alt="image-20221223105719842" style="zoom:67%;" />
**思路：**对于有$q$次插入的，那么一定是我们的链表了，我们可以使用数据不重复链表。

大体思路就是因为数据不重复，所以我们可以使用两个数组 to[]，last[]。to[i]代表 数字 $i$ 后边的是谁，last[i]代表 数字 $i$ 的上一个是谁，因为数据不重复，所以to，last不会产生重复，这种写法把数据域和指针域重叠了一起。

```
#include<iostream>
#include<testlib.h>
using namespace std;
const int maxn = 2000010;
int a[maxn],to[maxn],last[maxn];
int cnt = 0;
int main(){
        int n;
        cin >>n;
        for(int i = 1; i <= n; i++){
            cin >> a[i];
        }
        for(int i = 0; i <= 2000003; i++) to[i] = last[i] = -1;
        for(int i = 1; i <= n - 1; i++) to[a[i]] = a[i + 1];
        for(int i = 2 ; i <= n; i++) last[a[i]] = a[i - 1];

        int q;
        cin >> q;
        while(q--){
            int x,y;
            cin >>x >> y;
            to[y] = to[x];
            last[to[y]] = y;
            last[y] = x;
            to[x] = y;
        }

        int head = a[1];
        while(to[head] != -1){
            cout << head << " ";
            head = to[head];
        }
        cout << endl;

    return 0;
}

```

### 16.1.2数据重复链表

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223112415241.png" alt="image-20221223112415241" style="zoom:67%;" />
**思路：**数据重复链表，其实就是我们一开始讲的链表的写法，无非就是有数据域和指针域两种，我们只需要模拟出数据域和指针域就好了。我们每次可以给新增的数据一个新的编号，这样子每组数据是唯一的，我们把编号当作新的数据不重复链表即可。

```
#include<iostream>
using namespace std;
const int maxn = 100010;
int next1[maxn],w[maxn],head = -1,cnt = 0;
void add1(int x){   往表头加
    w[cnt] = x;
    next1[cnt] = head;
    head = cnt++;
}
void add2(int k,int x){     
    w[cnt] = x;
    next1[cnt] = next1[k];
    next1[k] = cnt++;
}
void delte(int k){
    next1[k] = next1[next1[k]];
}
int main(){
        int t;
        cin >> t;
        cnt = 0;
        head = -1;
        char ch;int x,y;
        for(int i = 1; i <= t; i++){
            cin >> ch;
            if(ch == 'H'){
                cin >> x;
                add1(x);
            }else if(ch == 'D'){
                cin >> x;
                if(!x) head = next1[head];
                delte(x - 1);
            }else{
                cin >> x >> y;
                add2(x - 1,y);
            }
        }
        for(int i = head;i != -1; i = next1[i]){
            cout << w[i] << " ";
        }
    return 0;
}
```



# 17.动态规划

动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题
核心思想: 通过将问题拆分成一个一个小问题，记录过往结果，减少重复运算

a. 动态规划是一种**求最优**化递推问题，**动态规划**中涉及到**决策过程**； 所以动态规划是递推问题的子问题；

　　其中 **递推公式** 在动态规划中叫做 **状态转移方程**， 具体步骤与上面递推是类似的；

b. 在状态转移方程中，主要下面三个重点：

　　　**状态定义：**

　　　**决策过程：**从所有可能中选择最优解；　　//如果不涉及决策，大概率就是贪心算法；

　　　**阶段依赖：**当前阶段只依赖上一阶段； 对于不同问题中，阶段概念是一个很宽泛的定义；

c. 在实际求解问题过程中，有两种方向：处理问题中，如果从哪里来的条件判断比较复杂，那就可以考虑到哪里去的方法；

　　　　　**从哪里来：**当前状态 = f(前一个状态 ) ； 　　　　　　　　　　　   　　当前这个状态(被推导) 可以通过其他状态推导得到；

　　　　　**到哪里去：**每更新当前状态时 ==> 主动更新可以从它推导出状态的结果； 当前这个状态(去推导)可以到达哪些状态；

　　　 这两种方向，本质是一样的，**底层是一个图的结构，** 而**递推(动归) 求解顺序就是状态依赖图的一个拓扑序，**对有向图的一维化序列化的结果；

 d. **动归典型题**： 体会从哪里来，到哪里去的精髓；
小例子：

```
A ： "1+1+1+1+1+1+1+1 =？"
A ： "上面等式的值是多少"
B ： 计算 "8"
A : 在上面等式的左边写上 "1+" 呢？
A : "此时等式的值为多少"
B : 很快得出答案 "9"
A : "你怎么这么快就知道答案了"
A : "只要在8的基础上加1就行了"
A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"
```

## 17.1线性动态规划

### 17.1.1 P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles

![image-20221021130315391](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021130315391.png)

对于第一行我们已经知道了他的最大值，所以对于第二行通过第一行枚举就好了，第三行通过第二行枚举就好了。
每一行都要等上一行枚举完成才能进行新一轮的枚举。并且当前行只会影响下一行，不会影响上一行，我们称为无后效性，只对未来有影响。

### 17.1.2 U255571 最长上升子序列（基础版）

![image-20221021133659630](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021133659630.png)

### 17.1.3 U255583 最长上升子序列（加强版）

通过上一题，我们发现，我们只需要找到前面最长的且最后一位比我们当前i小的即可。

![image-20221021142510253](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021142510253.png)

记录完后我们发现有一个性质，那就是长度越长的结尾的数一定会越大
以 $i$ 为结尾的 长度为 $j$ 的上升子序列，一定是在前 $i - 1$存在一个以点$k$结尾长度为 $j - 1$的上升子序列。只有满足 $a_i > a_k$才能成立
所以长度为$j - 1$结尾的最大也可以取到$a_k$ 所以长度越长，结尾的数一定会越大
所以我们最后只需要二分就能完美解决了。

### 17.1.4 U255600 最长公共子序列

![image-20221021152618679](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021152618679.png)

### 17.1.5 P2758 编辑距离

![image-20221021155632483](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021155632483.png)

![image-20221021160027095](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221021160027095.png)

可以由这两种状态转移

## 17.2 背包问题

背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。

### 17.2.1 01背包

![image-20221008183530564](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183530564.png)



例题中已知条件有第$i$个物品的重量 $w_i$，价值 $v_i$，以及背包的总容量 $W$。

设 DP 状态 $f_{i,j}$为在只能放前$i$个物品的情况下，容量为$j$的背包所能达到的最大总价值。
那么对于容量为$j$，最大总价值为$f_{i,j}$，前$i$个物品一定有一种选取方式成立
考虑转移。假设当前已经处理好了前$i - 1$个物品的所有状态，那么对于第$i$个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为$f_{i - 1,j}$；当其放入背包时，背包的剩余容量会减小 ，背包中物品的总价值会增大 ，故这种情况的最大价值为$f_{i - 1,j - w_{i}} + v_i$。
由此可以得出状态转移方程：![image-20221011104826290](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011104826290.png)

### 实现：

```
代码块1
// C++ Version
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= W - w[i]; j++){
		f[i][j + w[i]] = max(f[i - 1][j] + v[i],f[i - 1][j + w[i]]);
	}
	for(int j = 0; j <= w[i] - 1; j++) f[i][j] = f[i - 1][j];
}
```

上述代码的空间复杂度和时间复杂度都是 O(nw)
有什么办法可以降低空间复杂度吗？
我可以发现每一个$f_{i,j}$他只与$f_{i - 1,j}$有关，所以当我们遍历到$i$的时候$i - 1$以前的状态我们都可以舍弃不要，所以我们每次只需要记录两种状态就可以了，所以我们可以采用滚动数组。

```
代码块2
// C++ Version
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= w[i] - 1; j++) f[i % 2][j] = f[(i - 1) % 2][j];
	for(int j = 0; j <= W - w[i]; j++){
		f[i % 2][j + w[i]] = max(f[(i - 1) % 2][j + w[i]],f[(i - 1) % 2][j] + v[i]);
	}
}
```

那么能不能再简化呢？
如果我们只用一维行不行?

```
代码块3
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
```

![image-20221011105701889](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011105701889.png)



```
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);
//需要对0~w[i] - 1的进行操作吗？
```

为什么这样枚举就是正确的呢？
大家可以自己的想一想，我们每次更新的$f_l$是从大到小更新的，而没有更新过的都是上一物品转换完的状态。

## 17.3 完全背包

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183718260.png" alt="image-20221008183718260" style="zoom: 80%;" />

![image-20221011110332625](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011110332625.png)
这样的枚举方法就是把完全背包转换成了01背包，把一个物品$i$当作一个物品，把两个物品$i$当作一个物品，...，把n个物品$i$当作一个物品。

```
代码块4
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++){
      for(int k = 0;;k++){
          if(k * w[i] + l > W) break;
          f[i][l + k * w[i]] = max(f[i][l + k * w[i]],max(f[i - 1][l + k * w[i]],f[i - 1][l] + k * v[i]));
      }
      for(int l = 0; l <= w[i] - 1; l++) f[i][l] = f[i - 1][l];
  }
```

那么我们如何进行一个优化呢？物品1可以取无限次，和有无限个物品1，每个只能取一次，这俩个是等价的，对于$f[i][j]$来说，当$j = k$时有$f[i][j + 2*w[i]] = max(f[i][j] + 2 * v[i],f[i][j + 2*w[i]])$，相当于尝试买了两个该物品，同样的当$j = k + w[i]$时有$f[i][j + w[i]] = max(f[i][j] + v[i],f[i][j + w[i]])$ ，相当于尝试买一个该物品，倘若我们在实现第二次转换前实现过了当$j = k$时有$f[i][j + w[i]] = max(f[i][j] + v[i],f[i][j + w[i]])$，那么对于$j = k + w[i]$时来说，再尝试就相当于尝试过买了两次和尝试买过两次，所以我们只需要只对于每一个做买一个物品的尝试即可。

```;
代码块5
// C++ Version
for (int i = 1; i <= n; i++){
  for(int l = 0; l <= w; l++) f[i][l] = f[i - 1][l];
  for (int l = 0; l <= W - w[i]; l++)
  	f[i][l + w[i]] = max(f[i][l + w[i]],f[i][l] + v[i]));
}
```

随后我们发现$f_{i,j}$只和自己这些物品有关系

```
代码块6
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
```

## 17.4多重背包

![image-20221008183835536](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183835536.png)




```
for(int i = 1; i <= n; i++){
	for(int j = W; j >= 0; j--){
 		for(int l = 1; l <= k[i]; l++){
			if(j + l * c[i] > w) break;
			dp[i % 2][j + l * c[i]] = max(dp[i % 2][j + l * c[i]],dp[(i - 1) % 2][j] + v[i]);
		}
	}
}
```

![image-20221009133332834](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133332834.png)


![image-20221009133342948](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133342948.png)
典型的空间复杂度换取时间复杂度的做法


```
// C++ Version
index = 0;
for (int i = 1; i <= m; i++) {
  int c = 1, p, h, k;
  cin >> p >> h >> k;
  while (k - c > 0) {
    k -= c;
    list[++index].w = c * p;
    list[index].v = c * h;
    c *= 2;
  }
  list[++index].w = p * k;
  list[index].v = h * k;
}
```

## 17.5混合背包

![image-20221009133533775](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133533775.png)


```
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```

## 17.6区间动态规划

### 定义

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。

令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max\{f(i,k)+f(k+1,j)+cost\}$，$cost$ 为将这两组元素合并起来的代价。

### 性质

区间 DP 有以下特点：

**合并**：即将两个或多个部分进行整合，当然也可以反过来；

**特征**：能将问题分解为能两两合并的形式；

**求解**：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

### 17.6.1 无环合并类区间dp

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223140012060.png" alt="image-20221223140012060" style="zoom:67%;" />

**思路：**对于这种题来说一定是对于区间来说的，因为他的价值随着区间的扩大而扩大，不停的区间合并产生的区间不同，对于同样的一个区间 i,j 可以由 i,i + 1 与 i + 2,j 合并，或者 i,i + 2与i + 3,j来合并...... 所以我们的目标就是找到最优的一种合并方式

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223141521099.png" alt="image-20221223141521099" style="zoom:67%;" />
对于区间长度为 k的需要通过长度为 1，2..... k-1的推导过来，所以我们要从区间长度短的开始推导。哪些是已知的状态呢？区间长度为1的时候是已知的状态。

```
#include<bits/stdc++.h>
using namespace std;
int dp[310][310],len,a[310],n,sum[310];
int main(){
	cin>>n;
	memset(dp,0x3f,sizeof(dp));//初始化1，因为是求最小代价，所以初始化设为很大的一个数，为了后面更新。
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		dp[i][i]=0;//初始化2，他自己本身的代价为0。
	}
	for(int len=2;len<=n;len++){  //循环长度
		for(int i=1;i<=n-len+1;i++){  //循环起始点
			int j=i+len-1;
			for(int k=i;k<j;k++){ //状态转移
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);
			}
		}
	}
	cout<<dp[1][n];
}
```

### 17.6.2 有环合并类区间dp

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223142341002.png" alt="image-20221223142341002" style="zoom:67%;" />

#### 怎样处理环

题目中石子围成一个环，而不是一条链，怎么办呢？

**方法一**：由于石子围成一个环，我们可以枚举分开的位置，将这个环转化成一个链，由于要枚举 $n$ 次，最终的时间复杂度为 $O(n^4)$。

**方法二**：我们将这条链延长两倍，变成 $2\times n$ 堆，其中第 $i$ 堆与第 $n+i$ 堆相同，用动态规划求解后，取 $f(1,n),f(2,n+1),\dots,f(n-1,2n-2)$ 中的最优值，即为最后的答案。时间复杂度 $O(n^3)$。

    for (len = 1; len <= n; len++)
      for (i = 1; i <= 2 * n - 1; i++) {
        int j = len + i - 1;
        for (k = i; k < j && k <= 2 * n - 1; k++)
          f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
      }

### 17.6.7 不合并类区间dp

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223145703907.png" alt="image-20221223145703907" style="zoom:67%;" />
**思路：**典型的一看就像区间dp但是不知道怎么合并，因为这道题其实就是不合并。对于一个区间 i,j 的人来说，最后排进队的要么是 第 i个要么就是 第 j个人，所以对于区间 i，j的转移只有 i - 1，j 和 i，j - 1，其他的我们没法合并。对于这两个区间来说，我们需要知道最后一个人是谁我们才能知道 第 i个人或者第 j个人排在左边还是右边，所以我们还需要知道前一个区间最后一位进来的是谁，以至于我们的区间就变成了 i，j，k，表示 区间 i，j排好队了，最后一个进来的是 k ，我们可以让 k = 0代表最左，k = 1代表最右，最后实现转移。

```
#include <bits/stdc++.h>
using namespace std;
int f[2010][2010][2],a[2010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)f[i][i][0]=1;
	for(int len=1;len<=n;len++)
		for(int i=1,j=i+len;j<=n;i++,j++){
			if(a[i]<a[i+1])f[i][j][0]+=f[i+1][j][0];
			if(a[i]<a[j])f[i][j][0]+=f[i+1][j][1];
			if(a[j]>a[i])f[i][j][1]+=f[i][j-1][0];
			if(a[j]>a[j-1])f[i][j][1]+=f[i][j-1][1];
			f[i][j][0]%=19650827;
			f[i][j][1]%=19650827;
		}
	cout<<(f[1][n][0]+f[1][n][1])%19650827;
	return 0;
}
```

# 18. 组合数学

## 18.1 分类加法计数原理

完成一件事有两类不同方案，在第1类方案中有m种不同的方法，在第2方案中有n种不同的方法。那么完成这件事共有N=m+n种不同的方法。要点诠释:
如果完成一件事有n类办法，这n类办法彼此之间是相互独立的，无论哪一类办法中哪一种方法都能完成这件事，求完成这件事的方法种数，就用分类加法计数原理:在解题时，应首先分清楚怎样才算完成这件事，有些题目在解决时需要进行分类讨论，分类时要适当地确定分类的标准，按照分类的原则进行，做到不重不痛。

注意事项：（1）每种方式都能实现目标，不依赖于其他条件； （2）每种情况内任两种方式都不同时存在；（3）不同情况之间没有相同方式存在。

### 练习

1. 如图<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223161222832.png" alt="image-20221223161222832" style="zoom:67%;" />
   对于第一条路径来说有X种方法到达点B，对于第二条路径来说有Y种方法到达点B，对于第三条路径来说有Z种方法到达点B，请问一共有多少种方法到达点B?
2. 某医院研究所研制了5种消炎药X1、X2、X3、X4、X5和4种退烧药T1、T2、T3、T4,现从中取出两种消炎药和一种退烧药同时使用进行疗效试验，又知X1、X2两种消炎药必须同时搭配使用，但X3和X4 两种药不能同时使用，则不同的试) (      )
   A.16种         B.15种       C.14种        D.13种

## 18.2 分步乘法计数原理

完成一件事需要两个步骤，做第1步有种不同的方法，做第2步有n种不同的方法，那么完成这件事共有N = m*n种不同的方法。要点诠释:
如果完成一件事需要分成n个步骤，缺一不可，即需要依次完成所有的步骤，才能完成这件事，而完成每一个步骤各有若干种不同的方法，计算完成这件事的方法种数就用分步乘法计数原理。解题时，关键是分清楚完成这件事是分类还分步，在应用分步乘法计数原理时，各个步骤都完成，才算完成这件事，步骤之间互不影响，即前一步用什么方法，不影响后一步采职什么方法，运用分步乘法计数原理，要确定好次序，还要注意元素是否可以重复选取。

![image-20221223165157065](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223165157065.png)


### 练习

1. 1.一个袋子里放有6个球，另一个袋子里放有 8个球，每个球各不相同从两袋子里各取一个球，不同取法的种数为(      )
   A.182      B.14      C.48       D.91
2. 集合 A= {a，b，C}   B={d，e，f，g}从集合A到集合 B的不同的映射个数是 (       )
   A.24       B.81        C.6        D.64
3. 5本不同的书，全部迭给6位学生，有多少种不同的书方法(         )
   A.720种       B.7776种       C.360种          D.3888种
4. 有四位老师在同一年级的 4个班级中各教一个班的数学，在数学考试时，要求每位老师均不在本班监考，则安排监考的方法种数是( ) A.8种      B.9种       C.10种      D.11种

## 18.3综合应用

应用两个原理的分别要注意:
若用分类计数原理，要做到“不重不漏”，分类后再分别对每一类进行计数，最后用分类计数原理，即加法原理求和得到总数:若用分步计数原理，要做到步骤“完整”一一完成了所有步骤，恰好完成所有任务，当然步与步之间 要相互独立，分步后再计算每一步的方法数，最后根据分步计数原理，即乘法原理把完成每一步的方法数 相乘得到总数要点四 、分类计数原理和分步计数原理的应用

1. 利用两个基本原理解决具体问题时的思考程序:
   (1)首先明确要完成的事件是什么，条件有哪些?
   (2)然后考虑如何完成?主要有三种类型
   1.分类或分步。2.先分类，再在每一类里再分步 3. 先分步，再在每一步里再分类，等等。
   (3)最后考虑每一类或每一步的不同方法数是多少? 
2. 利用两个基本原理解决具体问题时的注意事项:
   (1)应用分类计数原理，应注意: 1. 分类时，要按一个标准来分，最忌采用双重或多重标准分类: 2. 每类中的每一种方法都可以独立地完成此任务:它的起点、终点就是完成这件事情的开始和结束:两类不同办法中的具体方法，互不相同 ( 即分类不重 ) ;4.完成此任务的任何一种方法，都属于某一类( 即分类不漏)
   (2) 应用分步计数原理，应注意:
   1.任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务:
   2各步计数相互独立;
   3.只要有一步中所采取的方法不同，则对应的完成此事的方法也不同63.利用两个基本原理解决具体问题时的方法技巧:
   利用两个基本原理解决具体问题，关键环节是分类或者分步。类与步的关系式辩证的。有些问题需要 先分类，再在每一类里再分步:有些问题需要先分步，再在每一步里再分类，等等。到底采用何种顺序分 类与分步，要看
   <img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223165907373.png" alt="image-20221223165907373" style="zoom:67%;" />
   <img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223165959744.png" alt="image-20221223165959744" style="zoom:67%;" />

### 练习

1. 如图所示，在连接正八边形的三个顶点而成的三角形中，与正八边形 有公共边的三角形有个（       ）

   <img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223170322881.png" alt="image-20221223170322881" style="zoom:67%;" />

2. 用数字 1,2,3 可写出多少个小于 1000 的正整数?(各位上的数字允许重复) (        )

3. 在所有的两位数中，个位数字大于十位数字的两位数共有多少个 (         )

4. 从1,2，3.,10 中选出3 个不同的数， 使这三个数成等差数列，则这样的数列共有多少个(           )

5. 体育场南侧有 4 个大门，北侧有 3 个大门，某学生到该体育场练跑步，则他进出门的方案有(           )
   A.12种      B.7种         C.24 种         D.49 种

6. 从6 人中选 4 人分别到巴黎、伦敦、悉尼、莫斯科四个城市游览，要求每个城市有一人游览，每人只游览一个城市，且这 6 人中甲、乙两人不去巴黎游览，则不同的选择方案共有 ( ).
   A.300种        B.240种          C.144种              D.96种

7. 甲、乙两人从4 门课程中各选修 2门，则甲、乙所选的课程中恰有 1门相同的选法有 ()
   A.6种           B.12种           C.24种         D.30种

8. 一个口袋内装有 5 个小球，另一个口袋内装有 4 个小球，所有这些小球的颜色互不相同
   (1) 从两个口袋内任取一个小球，有多少种不同的取法?
   (2)从两个口袋内各取一个小球，有多少种不同的取法?

9. 现有一分硬币3 枚，两角纸币6 张，十元纸币4张，则它们共可以组成多少种非零的币值?

10. 用数字0，1，2，3，4 组成数字允许重复的三位数，其中有几个偶数?

11. 用0，1，2，3，4，5这六个数字
    ( 1)可以组成多少个数字不重复的三位数?
    ( 2)可以组成多少个数字允许重复的三位数?
    ( 3)可以组成多少个数字不重复的三位奇数?
    (4)可以组成多少个数字不重复的小于 1000 的自然数?
    ( 5)可以组成多少个数字不重复的大于 3000，小于 5421的四位数?

12. 一个口袋里有 5封信，另一个口袋里有 4封信，各封信内容均不相同
    (1)从两个口袋里各取 1封信，有多少种不同的取法?
    (2)把这两个口袋里的9封信，分别投入4 个邮筒，有多少种不同的投法?

13. 用5种不同颜色给图中A，B，C，D四个区域涂色，每个区域涂一种 颜色.若要求相邻(有公共边的涂色方法 ?
    ![image-20221223171129017](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221223171129017.png)

14. 某赛季足球比赛的计分规则是: 胜一场得3分,平一场得1分，负一场得0分球队打完15场,积 33分,若不考虑顺序，该队胜、负、平的情形有 ( ).
    A.3种            B.4种             C.5种             D.6种
    
15. 设m =3^4^ * 11^2^ * 13^7^ * 5^8^问m有多少个正因子?

## 18.4 排列

#### 集合S有$n$个不同元素，从中选出$r$个元素排成一队(考虑排队的顺序)，称为一个r-排列。所有r- 排列的个数记为A(n,r)或者P(n,r)

或者说从某个集合中有序的取出若干个元素的问题
集合S ={a,b,c} 的选排列有
1-排列: a , b , c
2-排列: ab , ac , ba , bc , ca , cb
3-排列: abc , acb , bac , bca , cab , cba

#### 定理

A(n,r) = $\frac{n!}{(n - r)!} $ = $A_{n}^{r} = $ $n * (n - 1) * .... * (n - r + 2) * (n - r + 1)$ =$\frac{A_{n}^{n}}{A_{n - r}^{n - r}} $ 

**证明：**把 $n$个元素选出$r$个排成一队，第一位置可以从 $n$ 个里面选出一个，第二个位置可以从 $n - 1$里面选出一个，直到最后一个位置可以从$n - r + 1$里面选一个。

#### 推论

全排列：$A_{n}^{n}$ = n!，$A_{n}^{0}$= 1，$A_{n}^{1}$ = n，$A_{n}^{n - 1}$= n!

### 18.4.1 基础例题

1. 用字母 a,b,c,d,e 组成4个字母的词，每个字母最多出现一次:
   经典的排列，$A_{5}^{4} = 120$
2. 从甲、乙、丙3名同学中选出2名去参加某天的一项活动，其中1名同学参加上午的活动，1名同学参加下午的活动，有多少种不同的选法?
   经典的排列，$A_{3}^{2} = 120$
3. 有从1到9共计9个号码球，请问，可以组成多少个三位数
   经典的排列，$A_{9}^{3} = 504$
4. 8人排成前后两排每排4人,其中甲乙在前排,丁在后排,共有多少排法？
   8人排前后两排相当于8人坐8把椅子可以把椅子排成一排先在前4个位置排甲乙两个特殊元素有 $A_{4}^{2}$种再排后4个位置上的特殊元素有$A_{4}^{1}$种其余的5人在5个位上任意排列有$A_{5}^{5}$种则共有$A_{4}^{2}$ * $A_{4}^{1}$ * $A_{5}^{5}$
5. 一个班有6名战士，其中正副班长各1人现从中选4人完成四种不同的任务,每人完成一种任务，且正副班长有且只有1人参加,则不同的选法有(    )种

### 18.4.2 特殊例题1

#### 学校组织老师学生一起看电影，同一排电影票12张8个学生，4个老师，要求老师在学生之间，且老师互不相邻，共有多少种不同的坐法 ?

**分析：**此题涉及到的是不相邻问题,并且是对老师有特殊的要求,因此老师是特殊元素,在解决时就要特殊对待.所涉及问题是排列问题。
此题的做法叫做**插空法**，我们只需要先把学生排好，把老师插入学生的空档中即可
学生排列是$A_{8}^{8}$，8个学生一共有7个空档，老师从7个空档里面选4个空档即可。
最后的答案就是 $A_{8}^{8}$ * $A_{7}^{4}$

#### 结论1 

**插空法:**对于某两个元素或者几个元素要求不相邻邻的问题,可以用插入法.即先排好没有限制条件的元素,然后将有限制条件的元素按要求插入排好元素的空档之中即可

#### 练习：

1. 用26个字母排列，是元音 ,e,i,o,u 组不相继出现（不相邻），有多少种排法?

2. 用1,2.··.,9可以组成多少个数码相异的7位数，5和6不以任何顺序相继出现 ?

3. 学校A、B、C、D、E共5人排队做课间操，其中A、B两人不排在一起，则一共有多少种排队方式?

4. 两个大人带四个孩子去坐只有六个位置的圆型旋转木马，那么两个大人不相邻的概率为（    ）
   A.2/5        B.3/5         C.1/3       D.2/3

5. 某单位举办职工大会，7名优秀员工坐一排，其中有2名男员工，若要求2名男员工不能坐在一起，则有多少种不同的座次安排?

6. 某班新年联欢会原定的5个节目已排成书目单，开演前又增加了两个新节目.如果将这两个新节目插入原节目单中，且两个新节目不相邻，那么不同插法的种数为(      )

   

### 18.4.3 特殊例题2

#### 5个男生3个女生排成一排,3个女生要排在一起有多少种不同的排法?

**分析：**此题涉及到的是排队问题,对于女生有特殊的限制因此,女生是特殊元素,并且要求她们要相邻,因此可以将她们看成是一个元素来解决问题。此题的做法叫做**捆绑法**，我们把3个女生当作一个整体先和男生进行排序。
这样就是$A_{6}^{6}$，女生自己也需要排序是$A_{3}^{3}$，所以最后的答案就是$A_{6}^{6}$ * $A_{3}^{3}$

#### 结论2

捆绑法:要求某几个元素必须排在一起的问题结论2可以用捆绑法来解决问题.即将需要相邻的元素合并为一个元素,再与其它元素一起作排列,同时要注意合并元素内部也可以作排列

#### 练习：

1. 给甲、乙、丙等5人重新排座位，甲乙两人挨着坐的排法有多少种？
2. 现有2本艺术类、3本教育类和4本医药类书籍需要并排放到同一层书架上，要求同类书籍必须放在一起。问共有多少种可能的放置方式？
3. 甲、乙、丙三所学校的学生被安排在周一至周五参观某革命纪念馆。纪念馆每天最多只能安排一所学校，其中甲学校连续参观两天，其余学校均只参观一天，那么共有多少种安排方法？
4. 某镇举办农业科学知识培训共计15人。结业典礼当天组织大家合影留念。共站两排，站在前排的5个人中有一对夫妇。现要求夫妻二人相邻的照相顺序有( )种。
   A. $A_{15}^{15}$       B. $A_{13}^{13}$  * 8          C.$A_{13}^{13}$  * 2         D.$A_{13}^{3}$  * 8  
5. 4 个男生 2 个女生 6 人站成一排合影留念，有多少种排法?如果要求 2 个女生紧挨着排在正中间有多少种不同的排法?
6. 4 个男生 2 个女生 6 人站成一排合影留念，有多少种排法?如果要求 2 个女生紧挨着有多少种不同的排法?
7. 某小组有 12 个同学，其中男少先队员有 3 人，女少先队员有4人，全组同学站成排，要求女少先队员都排一起，而男少先队员不排在一起，这样的排法有多少?
8. 用1,2,3,4,5组成没有重复数字的五位数其中恰有两个偶数夹1，5这两个奇数之间,这样的五位数有多少个?
9. 5男生和5女生站成一排照像,男生相邻女生也相邻的排法有(     )种

### 18.4.4 特殊例题3

#### 学生一共8个人玩游戏，需要排成一个圆，请问有多少种排列方式（1 2 3 和 3 1 2 是一样的排列方式）

<img src="https://img-blog.csdnimg.cn/20200929203117193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rlc3RpbnlfYmFsYWJhbGE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />
**分析：**这类题叫做圆排列，就不是一条直线，是一个圆。

答案是$A_{8}^{8}$ / 8，为什么呢？对于一个n个数的排列来说，可以旋转n次，每个排列都是n次重复。所以要除以n。

#### 10个人为圆桌任意就坐，求指定的两个人A与B不相邻的概率

(1)任意坐: n=9!

(2)不相邻:A先就坐，B不相邻 :7其余8人排序 :8! m=7 * 8!

(3)P = m/n = 7 * 8! / 9! = 7/9

#### 结论3

圆排列题型为 $A_{n}^{n}$ / n

#### 练习：

1. 有5对夫妇参加一场婚实，他们被安排在一张 10 个座位的圆桌就餐，但是婚礼操办者并不知道他们彼此之间的关系，只是随机安排座位。问 5 对夫妇恰好都被安排在一起相邻而坐的概率是多少?(     ）
   A.在1%到5%之间     B，在5%到1%之间     C超过1%   D.不超过1%
2. 用六枚不同的珍珠串一条项链，共有多少种不同的串法?
   A.120      B.60     C.30       D.24

### 18.4.5 特殊例题4

#### 把6名实习生分配到7个车间实习,共有多少种不同的分法

**分析：**完成此事共分六步:把第一名实习生分配把第二名实习生分配到车间有7种分法到车间也有7种分法，依此类推,由分步数原理共有7^6^种不同的排法

#### 结论4

允许重复的排列问题的特点是以元素为研究对象，元素不受位置的约束，可以逐一安排各个元素的位置，一般地n不同的元素没有限制地安排在m个位置上的排列数为 m^n^种

#### 练习：

1. 某8层大楼一楼电梯上来8名乘客人,他们到各自的一层下电梯,下电梯的方法(      )
2. 学校组织10个学生去图书馆，每个学生都可以选择A,B,C,D四个图书馆中的一个，请问一共会有多少种情况(      )

### 18.4.6 特殊例题5

#### 7人排队,其中甲乙丙3人顺序一定共有多少不同的排法（   ）

**分析：**如果不考虑甲乙丙3人的顺序的话排法一共是$A_{7}^{7}$，考虑甲乙丙三个人的顺序有$A_{3}^{3}$种，我们只需要其中的一种，所以答案是 $A_{7}^{7}$ /  $A_{3}^{3}$  这个方叫**倍缩法**

#### 结论5

**倍缩法：**对于**某几个元素顺序一定**的排列问题,可先把这几个元素与其他元素一起进行排列,然后用总排列数除以这几个元素之间的全排列数

#### 练习：

1. 一共7枚棋子（分别记为abcdefg）排成一排，其中3枚(abc)是固定顺序的请问有多少种排法（  ）
2. 有6个彩球，其中2个颜色相同，剩余4个颜色各不相同，从中按顺序取出6个球，问共有多少种取法（   ）
3. 6本同书分3份
   (1) 1份3本，1份2本，1份1本共有多少法?
   (2) 1份4本，另2份各1本共有多少法?
   (3) 每份2本共有多少法?
4. 单词MISSISSIPPI中字母的排列数是多少?
5. 设S ={3 * a,2 * b,4 * c} 一共9个元素，3个a，2个b，4个c求S的8-排列的个数

## 18.5 组合

#### 集合S有n个不同元素，从中选出r个元素组成一组(不考虑排列顺序)，称为S的一个r-组合。

或者说从某个集合中无序的取出若干个元素的问题

集合S ={a,b,c,d} 的3-组合有 {a,b,c} ,  {a,b,d},  {a,c,d},  {b,c,d}

n个元素的所有r-组合的个数记为$C_{n}^{r}$或 $_{r}^{n}$

#### 定理

$C_{n}^{r}$ = $\frac{A_{n}^{n}}{A_{r}^{r} * A_{n - r}^{n - r}}$ = $\frac{n!}{r! * (n - r)!}$  = $\frac{A_{n}^{r}}{A_{r}^{r}}$

#### 证明

例如集合里有7个元素，从7个中选出3个的组合，请问一共有多少种选法。

首先如何我们不考虑组合，考虑排列的话，就是 $A_{7}^{3}$ 。倘若只取选出的三个的一种，那么就要再除以 $A_{3}^{3}$

所以最后答案是$C_{7}^{3}$  = $ \frac{A_{7}^{3}}{A_{3}^{3} }$，$A_{7}^{3}$  =  $\frac{A_{7}^{7}}{A_{4}^{4}}$

#### 推论

$C_{n}^{n}$ = 1，$C_{n}^{0}$= 1，$C_{n}^{1}$= n，$C_{n}^{n - 1}$ = n

以上4个是最简单的

$C_{n}^{r} = C_{n}^{n - r}$

可以理解为：将原本的每个组合都反转，把原来没选的选上，原来选了的去掉，这样就变成从$n$个元素种取出$n−m$个元素，显然方案数是相等的。

$C_{n}^{r} = C_{n - 1}^{r - 1} + C_{n - 1}^{r}$

可以理解为：我们要从$n$个不同的球里面选择$r$个球，求它的方案数。如果我们要选择第一个球的话，就要从后面$n - 1$个球里面选择$r - 1$个球，如果不选择第一个球的话，就要从后面的$n - 1$个球里面选择$r$个球

### 18.5.1 组合经典例题分析

1. 平面上有25个点，没有3点共线。这些点能够确定多少条直线?确定多少个三角形?
   每两个点确定一条直线   $C_{25}^{2}$
   每三个点确定一个三角形 $C_{25}^{3}$
2. 15选修数学课，其中12人来上课，他们随便坐在教室的25个座位上。共有多少中不同坐法?
   15个人有12个人来上课是组合  $C_{25}^{3}$
   从教室25个选12个位置是组合  $C_{25}^{12}$
   12个人从12个位置选位置是排列  $A_{12}^{12}$
   所以最后答案是  $C_{25}^{3}$ *  $C_{25}^{12}$ *  $A_{12}^{12}$
3. 将13个球队分成3组,一组5个队,其它两组4个队,有多少分法?
   分成一组 5个队是组合 $C_{13}^{5}$
   分成一组 4个队是组合 $C_{8}^{4}$
   分成一组 4个队是组合 $C_{4}^{4}$
   因为队伍是选人后组成的不存在队伍1，队伍2，所以两个四人队是组合，所以还要除以 $A_{2}^{2}$
   最后答案是 $C_{13}^{5}$ *  $C_{8}^{4}$ *  $C_{4}^{4}$ /  $A_{2}^{2}$
4. 某校高二年级共有六个班级，现从外地转入4名学生，要安排到该年级的两个班级且每班安排2名，则不同的安排方案种数为
   从年级里选两个班级是组合  $C_{6}^{2}$
   先给第一个班安排两名是组合 $C_{4}^{2}$
   再给第二个班安排两名是组合 $C_{2}^{2}$
   因为班级1和班级2是不同的班，是先前存在的，所以不需要除以 $A_{2}^{2}$

### 18.5.2 特殊例题1

#### 有10个运动员名额，在分给7个班，每班至少一个,有多少种分配方案?

**分析：**因为10个名额没有差别，把它们排成一排。相邻名额之间形成9个空隙。在9个空档中选6个位置插个隔板可把名额分成7份，对应地分给7个班级，每一种插板方法对应一种分法共有$C_{9}^{6}$种分法，这种方法叫**隔板法**
![image-20221228100906304](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221228100906304.png)

#### 结论1

**隔板法**：将$n$个**相同**的元素分成$m$份 ($n，m$为正整数),每份**至少一个**元素,可以用$m-1$块隔板插入$n$个元素排成一排的$n-1$个空隙中，所有分法数为$C_{m - 1}^{n - 1}$

**注释:特别注意插板法与捆绑法、插空的区别之处在于其元素是相同的**

#### 练习：

1. 10个相同的球装5个盒中,每盒至少一有多少装法?
2. x+y+z+w=100求这个方程组的自然数解组
3. 假设x、y、z是三个非零自然数，且有x+y+z=36，则共有多少组满足条件的
4. 将10本没有区别的图书分到编号为1、2、3的图书馆，要求每个图书馆分得图书数量不小于其编号数，问共有多少种不同的分法?(  )
   A.12        B.15           C.30           D.45
5. 某单位订阅了30份学习材料发放给3个部门，每个部门至少发放9份材料可一共有多少种不同的发放方法?(      )
   A.7          B.9             C.10            D.12
6. 有8个相同的球放到三个不同的盒子里，共有 ( ) 种不同方法
   A.35       B.28           C.21           D.45
7. 有9颗相同的糖，每天至少吃1颗，要4天吃完，有多少种吃法?
8. 一条马路上有编号为1、2、···、9的九燕路灯，现为了节约用电，要将其中的三盏关掉，但不能同时关掉相邻的两盏或三盏，则所有不同的关灯方法有多少种?
9. 在一张节目单中原有六个节目，若保持这些节目的相对顺序不变，再添加进去三个节目，则所有不同的添加方法共有多少种?
10. 停车场划出一排12个停车位置，今有8辆车需要停放，要求空位置连在一起，不同的停车方法有多少种?
11. 3个人坐在一排8个椅子上，若每个人左右两边都有空位，则坐法的种类有多少种?

### 18.5.3 特殊例题2

#### 10个名额分配到八个班，每班至少一个名额，问有多少种不同的分配方法?

**分析：**此题一看就是插板法，不过我们也可以使用另一种方法来写，先每个班级分一个名额，然后剩下两个名额，如果两个名额分到一个班级里面则有$C_{8}^{1}$，如果两个名额分到两个班级里面则有$C_{8}^{2}$种分法，则共有8+28=36，这种方法就三最普通的**列举法**

#### 结论2

**列举法：**也就是平常我们所说的分类，把问题分成好几个小类来解决，分类要保证不重不漏。

#### 练习：

1. 某单位订阅了30份学习材料发放给3个部门，每个部门至少发放9份材料问一共有多少种不同的发放方法?（    ）
   A.7          B.9             C.10            D.12
2. 停车场划出一排12个停车位置，今有8辆车需要停放，要求空位置连在一起，不同的停车方法有多少种?
3. 有9颗相同的糖，每天至少吃1颗，要4天吃完，有多少种吃法?
4. 有男生 12 人，女生8 人，从中选取 3 人作代表出席一次会议，代表中至少有 1名男生，问有多少种选法?
5. 在一次演唱会上共10名演员，其中8人能能唱歌,5人会跳舞,现要演出一个2人唱歌2人伴舞的节目,有多少选派方法?
6. 设有编号1,2,3,4,5的五个球和编号1,2,3,4,5的五个盒子,现将5个球投入这五个盒子内,要求每个盒子放一个球，并只恰好有两个球的编号与盒子的编号相同有多少投法
7. 给图中区域涂色,要求相邻区域不同色,现有4种可选颜色,则不同的着色方法有(       )种
   ![image-20221228124429932](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221228124429932.png)

### 18.5.4 特殊例题3

#### 袋中有不同的5分硬币23个,不同的1角硬币10个如果从袋中取出2元钱,有多少种取法?

**分析：**此题是一个组合问题,若是直接考虑取钱的问题的话,情况比较多,也显得比较凌乱,难以理出头绪来.但是如果根据组合数性质考虑剩余问题的话,就会很容易解决问题，把所有的硬市全部取出来,将得到0.05 * 23+0.10 * 10=2.15元，我们想要取2元和取0.15元没区别，所以剩下0.15元即剩下3个5分或1个5分与1个1角，共有 $C_{23}^{3} + C_{10}^{1} * C_{23}^{1}$，这种方法叫**对等法(求剩法)**

#### 结论3

**对等法**:在组合问题中,有多少取法,就有多少种剩法,他们是一一对应的,因此,当求取法困难时,可转化为**对等法**

#### 练习

1. 期中安排考试科目9门,语文要在数学之前考,有多少种不同的安排顺序?
2. 客人一进门说老板给我搭配20块钱的烧烤，目前店里 1元的烧烤有3种，2元的有2种，3元的有1种，4元的有2种，5元的有一种，请问我可以给客人搭配多少种烧烤?

### 18.5.5 特殊例题4

#### 某班里有43位同学,从中任抽5人,正、副班长团支部书记至少有一人在内的抽法有多少种?

**分析：**此题若是直接去考虑的话,就要将问题分成好几种情况,这样解题的话,容易造成各种情况遗漏或者重复的情况.而如果从此问题相反的方面去考虑的话,不但容易理解，而且在计算中也是非常的简便.这样就可以简化计算过程， 43人中任抽5人的方法有$C_{43}^{5}$种,正副班长,团支部书记都不在内的抽法有$C_{40}^{5}$ ,所以正副班长,团支部书记至少有1人在内的抽法有种$C_{43}^{5} - C_{40}^{5} $，这个方法叫**排除法**

#### 结论4

排除法:有些问题,正面直接考虑比较复杂,而它的反面往往比较简捷,可以先求出它的反面,再从整体中扫除

#### 练习：

1. 有12个人，按照下列要求分配，求不同的分法种数
   (1) 分为两组，一组7人，一组5人
   (2) 分为甲、乙两组，甲组7人，乙组5人
   (3) 分为甲、乙两组，一组7人，一组5人
   (4)分为甲、乙两组，每组6人 :
   (5) 分为两组，每组6人:
   (6) 分为三组，一组5人，一组4人，一组3人
   (7) 分为甲、乙、丙三组，甲组5人，乙组4人，丙组3人
   (8) 分为甲、乙、丙三组，一组5人，一组4人，一组3人
   (9) 分为甲、乙、丙三组，每组4人 ;
   (10) 分为三组，每组4人
2. 从0,1,2,3,4,5,6,7,8,9这十个数字中取出三个数，使其和为不小于10的偶数,不同的取法有多少种?
3. 5个人排队，甲不站头，乙不站尾有多少种?
4. 从4名男生和3名女生中选出4人参加某个座谈会，若这4人中必须既有男生又有女生，则不同的选法共有?
5. 3成人2小孩乘船游玩，1号船最多乘3人，2号船最多乘2人，3号船只能乘1人,他们任选2只船或3只船,但小孩不能单独乘一只船，这5人共有多少乘船方法
6. 同一寝室4人,每人写一张贺年卡集中起来然后每人各拿一张别人的贺年卡，则四张贺年卡不同的分配方式有多少种?

### 18.5.6 特殊例题5

#### 30030能被多少个不同的偶数整除

**分析：**先把30030分解成质因数的乘积形式30030=2 * 3 * 5 * 7 * 11 * 13依题意可知偶因数必先取2,再从其余5个因数中任取若千个组成乘积，所有的偶因数为$C_{5}^{0} + C_{5}^{1} + C_{5}^{2} + C_{5}^{3} + C_{5}^{4} + C_{5}^{5} = 2^5$，最后一个等于可以理解为除了2必选以外其他的都可以选择选或者不选。这个叫做**分解法**

#### 推论

$C_{n}^{0} + C_{n}^{1} + ...+ C_{n}^{n - 1} + C_{n}^{n} = 2^n$

#### 结论5

**分解法：**处理复杂的排列组合问题时可以把一个问题退化成一个简要的问题，通过解决这个简要的问题的解决找到解题方法，从而进下一步解决原来的问题 

#### 练习：

1. $C_{n}^{0} + C_{n}^{2} + ...+ C_{n}^{n}$ = ？

### 18.5.6 特殊例题6

#### 25人排成5 * 5方队,现从中选3人,要求3人不在同一行也不在同一列,不同的选法有多少种?

**分析：**将这个问题退化成9人排成3 * 3方队,现从中选3人,要求3人不在同一行也不在同一列,有多少选法.这样每行必有1人从其中的一行中选取1人后,把这人所在的行列都划掉，如此下去从 3 * 3的方队里面选3人的方法数有 $C_{9}^{1} * C_{4}^{1} / A_{3}^{3}$，那么对于5 * 5的方队，我们只需要从中选取3行3列即可把问题转换成 5 * 5种选3人，答案就是 $C_{5}^{3} * C_{5}^{3} * C_{9}^{1} * C_{4}^{1} / A_{3}^{3}$，当然直接从5 * 5的方阵种选也一样，$C_{25}^{1} * C_{16}^{1} * C_{9}^{1} / A_{3}^{3}$，但是当题目数字很大的时候，我们就必须转换一下，退而求其次。

#### 结论6

处理复杂的排列组合问题时可以把一个问题退化成一个简要的问题，通过解决这个简要的问题的解决找到解题方法，从而进下一解决原来的问题

#### 练习：

1. 某城市的街区由12个全等的矩形区组成其中实线表示马路，从A走到B的最短路径有多少种?<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221228130940368.png" alt="image-20221228130940368" style="zoom:67%;" />

   



## 18.6组合之杨辉三角与二项式定理

<img src="https://pic4.zhimg.com/80/v2-8099aafc04d9c180d107e2315804b23f_720w.webp" alt="img" style="zoom:67%;" />
我们从这张杨辉三角示意图上发现，杨辉三角的每行行首与每行结尾的数都为1.而且，**每个数等于其左上及其右上二数的和**。这样我们发现，杨辉三角左右对称。

对于杨辉三角我们可以写成 $N_{i,j} = N_{i - 1,j - 1} + N_{i - 1,j}$

而组合数表示从$n$个物品里面选择$r$个的不同组合，表示为  $C_{n}^{r} = C_{n - 1}^{r - 1} + C_{n - 1}^{r}$

我们发现当$ i = 1,j = 0$的时候 $N_{i,j} = 1$，$ i = 1,j = 1$的时候 $N_{i,j} = 1$

和$C_{1}^{0} = C_{1}^{1}$一样，导致后边的所有的 $n = i,j = r$值都一样，所以杨辉三角每一行每一列的值可以直接用组合数表示出来

我们再来看以下式子：
$(a + b)^1 = a + b$

$(a + b)^2 = a^2 + 2   a  b + b^2$

$(a + b)^3 = a^3 + 3a^2b + 3ab^2 + b^3$

$(a + b)^4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4$

对于每一项的系数我们惊奇的发现与杨辉三角的每一项都一一对应

这是因为杨辉三角原本就是记录的二项式高次幂展开式的系数规律，这称作**二项式定理**：

$(x + y)^n = \sum_{k = 0}^{n} C_{n}^{k}x^{n - k}y^k$

我们可以这样子来理解这个式子：

$(x + y) * (x + y) * (x + y) * ...*(x + y)$这里一共有$n$个$x + y$ 相乘

对于$x$的指数为$k$的情况，我们需要从这$n$个里面选$k$个$x$，剩下的都选$y$，所以系数是$C_{n}^{k}$，并且$y$的指数是$n - k$

$(x + y)^n = \sum_{k = 0}^{n} C_{n}^{k}x^{n - k}y^k$**每一项前的的系数的绝对值称为二项式系数，系数也就是整数项**

第一项为$C_{n}^{0}x^{n}y^0$ 第二项为$C_{n}^{1}x^{n - 1}y^1$以此类推

### 18.6.1 严格证明

令$n = m$，$(x + y)^m = \sum_{k = 0}^{m} C_{m}^{k}x^{m - k}y^k$ 成立

当$n = 1$的时候 显然成立

当$n = m + 1$的时候 

$(x + y)^{m + 1} = (x + y) ^ m * (x + y) = \sum_{k = 0}^{m} C_{m}^{k}x^{m - k}y^k * (x + y) = \sum_{k = 0}^{m} C_{m}^{k}x^{m - k + 1}y^k + \sum_{i = 0}^{m} C_{m}^{i}x^{m - i}y^{i + 1}$ 

令$i = j - 1$，那么 $1<=j<=m + 1$

那么原式子 $=\sum_{j = 0}^{m} C_{m}^{j}x^{m - j + 1}y^j + \sum_{j = 1}^{m + 1} C_{m}^{j - 1}x^{m - j + 1}y^j $

$=x^{m + 1} + \sum_{j = 1}^{m} C_{m}^{j}x^{m - j + 1}y^j + \sum_{j = 1}^{m} C_{m}^{j - 1}x^{m - j + 1}y^j  + y^{m + 1}$

又因为 $C_{m}^{j} + C_{m}^{j - 1} = C_{m + 1}^{j}$

所以原式子 $=x^{m + 1} + \sum_{j = 1}^{m} C_{m + 1}^{j}x^{m - j + 1}y^j + y^{m + 1}$ = $\sum_{j = 0}^{m + 1} C_{m + 1}^{j}x^{m - j + 1}y^j$

$(x + y)^{m + 1} = \sum_{k = 0}^{m + 1} C_{m + 1}^{k}x^{m - k + 1}y^k$ 归纳假设成立，证毕。

### 18.6.2 经典例题分析

1. $(2x+\frac{1}{x} )^6$的展开式中第三项的二项式系数为(               );第三项的系数为(            ),常数项为(          );含x的项为(          )
   对于此题我们得熟知二项式系数和系数和常数项和含x的项的概念
   第三项为 $C_{6}^{2}(2x)^{4}(\frac{1}{x})^{2}$ ，所以二项式系数为$C_{6}^{2}*2^4$
   第三项的系数也为$C_{6}^{2}*2^4$
   常数项值得就是没有未知数的那一项，也就是$x^k (\frac{1}{x})^{6-k}$，$x$应该被削掉所以$k = 6 - k，k = 3$所以常数项为$C_{6}^{3}*2^3$
   含x的项就是$x^k (\frac{1}{x})^{6-k}，x$的指数为1，也就是$k - 6 + k = 1，k = 3.5$所以含x的项为0
2. 已知 $(x-\frac{1}{2\sqrt{x} } )^n$第五项是常数项，求$n$的大小，求展开式所有的有理项
   第五项也就是$C_{n}^{4}x^{n - 4}(-\frac{1}{2\sqrt{x} })^4$所以$x^{n - 4 - 2} = 1，n = 6$
   有理项 X的指数是整数的项（可正可负），所以第1，3，5，7都是有理项 
   第1项为 $x^4$
   第3项为 $C_{6}^{2}\frac{1}{4}x^2$
   第5项为  $C_{6}^{4}\frac{1}{16}x^0$
   第7项为  $C_{6}^{6}\frac{1}{64}x^{-2}$
3. $(1 + 2x^2)(1 - x)^4$ 的展开式中$x^2$的系数是多少
   此题对于$(1 - x)^4$的展开式每一项都乘以 1或者 $2x^2$，所以$(1-x)^4$中系数为$x^2$或者$x^0$的对最终答案有贡献。
   $C_{4}^{2}(1)^2(-x)^2 * 1$和$C_{4}^{0}(1)^2(-x)^0 * 2x^2$，所以$x^2$的系数是8。

### 练习：

1. $(\frac{1}{2} + 2x)^8$的展开式二项式系数最大的是第(        )项
2. $(\frac{1}{2} + 2x)^9$的展开式二项式系数最大的是第(        )项
3. 已知$(1 - 2x)^7 = a_0 + a_1x + a_2x^2 + ... + a_7x^7$，求
   （1）$a_1 + a_2 + .. + a_7$ 
   （2）$a_1 + a_3 +...+a_7$
   （3）$a_0 + a_2 + ... + a_6$
   （4）$|a_0| + |a_1| + ... + |a_7|$ 
4. 若$(\sqrt{x} + \frac{2}{\sqrt[3]{x} })^n$展开式中存在常数项，则$n$的值可以是（       ）
   A.8             B.9              C.10              D.12
5. $(2x + \sqrt{x})^4$的展开项中$x^3$的系数是多少（     ）
   A.6               B.12               C.24                  D.48
6. $(\sqrt{x} - \frac{1}{x})^6$的常数项为（       ）
   A.15          B.-15          C.20            D.-20
7. $(x - 1)(x + 1)^8$的展开式$x^6$的系数是多少（      ）
   A.-14           B.14           C.-28          D.28
8. $(x^2 - \frac{1}{\sqrt{x}})^n$第三项与第五项的系数之比是$\frac{3}{14}$则展开式的常数项是（     ）
   A.-1             B.1              C.-45          D.45
9. $(3\sqrt{x} - \frac{1}{\sqrt{x}})^n$的展开式各项系数之和为64则展开式的常数项为（      ）
   A.-540         B.-162          C.162           D.540

# 19. 序列式容器

## 19.1 `vector`

`std::vector` 是 STL 提供的 **内存连续的**、**可变长度** 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。

我们平时的数组是确定的，不可变的，所以我们可以利用vector去存储一些图

### 为什么要使用 `vector`

作为 OIer，对程序效率的追求远比对工程级别的稳定性要高得多，而 `vector` 由于其对内存的动态处理，时间效率在部分情况下低于静态数组，并且在 OJ 服务器不一定开全优化的情况下更加糟糕。所以在正常存储数据的时候，通常不选择 `vector`。下面给出几个 `vector` 优秀的特性，在需要用到这些特性的情况下，`vector` 能给我们带来很大的帮助。

### `vector` 可以动态分配内存

很多时候我们不能提前开好那么大的空间（eg：预处理 1~n 中所有数的约数）。尽管我们能知道数据总量在空间允许的级别，但是单份数据还可能非常大，这种时候我们就需要 `vector` 来把内存占用量控制在合适的范围内。`vector` 还支持动态扩容，在内存非常紧张的时候这个特性就能派上用场了。

### `vector` 重写了比较运算符及赋值运算符

`vector` 重载了六个比较运算符，以字典序实现，这使得我们可以方便的判断两个容器是否相等（复杂度与容器大小成线性关系）。例如可以利用 `vector<char>` 实现字符串比较（当然，还是用 `std::string` 会更快更方便）。另外 `vector` 也重载了赋值运算符，使得数组拷贝更加方便。

### `vector` 便利的初始化

由于 `vector` 重载了 `=` 运算符，所以我们可以方便的初始化。此外从 C++11 起 `vector` 还支持 [列表初始化](https://zh.cppreference.com/w/cpp/language/list_initialization)，例如 `vector<int> data {1, 2, 3};`。

### `vector` 的使用方法

以下介绍常用用法，详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/vector)。

### 构造函数

用例参见如下代码（假设你已经 `using` 了 `std` 命名空间相关类型）：

```cpp
// 1. 创建空vector; 常数复杂度
vector<int> v0;
// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度
v0.reserve(3);
// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度
vector<int> v1(3);
// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度
vector<int> v[N];
//4.创建N个vector，用v[0]代表第一个vector,v[N - 1]代表最后一个
```

可以利用上述的方法构造一个 `vector`，足够我们使用了。

### 元素访问

`vector` 提供了如下几种方法进行元素访问

1.  `at()`

    `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。

2.  `operator[]`

    `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。

3.  `front()`

    `v.front()` 返回首元素的引用。

4.  `back()`

    `v.back()` 返回末尾元素的引用。

5.  `data()`

    `v.data()` 返回指向数组第一个元素的指针。

### 迭代器

**迭代器**（iterator）有时又称**光标**（cursor）是程序设计的[软件设计模式](https://baike.baidu.com/item/软件设计模式?fromModule=lemma_inlink)，可在容器对象（container，例如[链表](https://baike.baidu.com/item/链表?fromModule=lemma_inlink)或[数组](https://baike.baidu.com/item/数组?fromModule=lemma_inlink)）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。类似我们的指针。

vector 提供了如下几种 [迭代器](./iterator.md)

1.  `begin()/cbegin()`

    返回指向首元素的迭代器，其中 `*begin = front`。

2.  `end()/cend()`

    返回指向数组尾端占位符的迭代器，注意是没有元素的。

3.  `rbegin()/crbegin()`

    返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。

4.  `rend()/crend()`

    返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。

以上列出的迭代器中，含有字符 `c` 的为只读迭代器，你不能通过只读迭代器去修改 `vector` 中的元素的值。如果一个 `vector` 本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自 C++11 开始支持。

### 长度和容量

`vector` 有以下几个与容器长度和容量相关的函数。注意，`vector` 的长度（size）指有效元素数量，而容量（capacity）指其实际分配的内存长度，相关细节请参见后文的实现细节介绍。

**与长度相关**：

- `empty()` 返回一个 `bool` 值，即 `v.begin() == v.end()`，`true` 为空，`false` 为非空。

- `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())`。

- `resize()` 改变 `vector` 的长度，多退少补。补充元素可以由参数指定。

-   `max_size()` 返回容器的最大可能长度。

    **与容量相关**：

- `reserve()` 使得 `vector` 预留一定的内存空间，避免不必要的内存拷贝。

- `capacity()` 返回容器的容量，即不发生拷贝的情况下容器的长度上限。

- `shrink_to_fit()` 使得 `vector` 的容量与长度一致，多退但不会少。

### 元素增删及修改

- `clear()` 清除所有元素
- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 距离末尾长度成线性而非常数的**
- `erase()` 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 `insert` 一致。
- `push_back()` 在末尾插入一个元素，均摊复杂度为 **常数**，最坏为线性复杂度。
- `pop_back()` 删除末尾元素，常数复杂度。
- `swap()` 与另一个容器进行交换，此操作是 **常数复杂度** 而非线性的。

### `vector` 的实现细节

`vector` 的底层其实仍然是定长数组，它能够实现动态扩容的原因是增加了避免数量溢出的操作。首先需要指明的是 `vector` 中元素的数量（长度）$n$ 与它已分配内存最多能包含元素的数量（容量）$N$ 是不一致的，`vector` 会分开存储这两个量。当向 `vector` 中添加元素时，如发现 $n>N$，那么容器会分配一个尺寸为 $2N$ 的数组，然后将旧数据从原本的位置拷贝到新的数组中，再将原来的内存释放。尽管这个操作的渐进复杂度是 $O(n)$，但是可以证明其均摊复杂度为 $O(1)$。而在末尾删除元素和访问元素则都仍然是 $O(1)$ 的开销。
因此，只要对 `vector` 的尺寸估计得当并善用 `resize()` 和 `reserve()`，就能使得 `vector` 的效率与定长数组不会有太大差距。

### `vector<bool>`

标准库特别提供了对 `bool` 的 `vector` 特化，每个“`bool`”只占 1 bit，且支持动态增长。但是其 `operator[]` 的返回值的类型不是 `bool&` 而是 `vector<bool>::reference`。因此，使用 `vector<bool>` 使需谨慎，可以考虑使用 `deque<bool>` 或 `vector<char>` 替代。而如果你需要节省空间，请直接使用 [`bitset`](./bitset.md)。

## 19.2 deque

`std::deque` 是 STL 提供的 [双端队列](../../ds/queue.md) 数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。

### `deque` 的使用方法

以下介绍常用用法，详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/deque)。`deque` 的迭代器函数与 `vector` 相同，因此不作详细介绍。

### 构造函数

参见如下代码（假设你已经 `using` 了 `std` 命名空间相关类型）：

```cpp
// 1. 定义一个int类型的空双端队列 v0
deque<int> v0;
// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度
deque<int> v1(10);
// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度
deque<int> v2(10, 1);
// 4. 复制已有的双端队列 v1; 线性复杂度
deque<int> v3(v1);
// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度
deque<int> v4(v2.begin(), v2.begin() + 3);
// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11
deque<int> v5(std::move(v2));
```

### 元素访问

与 `vector` 一致，但无法访问底层内存。其高效的元素访问速度可参考实现细节部分。

- `at()` 返回容器中指定位置元素的引用，执行越界检查，**常数复杂度**。
- `operator[]` 返回容器中指定位置元素的引用。不执行越界检查，**常数复杂度**。
- `front()` 返回首元素的引用。
- `back()` 返回末尾元素的引用。

### 迭代器

与 `vector` 一致。

### 长度

与 `vector` 一致，但是没有 `reserve()` 和 `capacity()` 函数。（仍然有 `shrink_to_fit()` 函数）

### 元素增删及修改

与 `vector` 一致，并额外有向队列头部增加元素的函数。

- `clear()` 清除所有元素
- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 与两端距离较小者成线性**。
- `erase()` 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 `insert` 一致。
- `push_front()` 在头部插入一个元素，**常数复杂度**。
- `pop_front()` 删除头部元素，**常数复杂度**。
- `push_back()` 在末尾插入一个元素，**常数复杂度**。
- `pop_back()` 删除末尾元素，**常数复杂度**。
- `swap()` 与另一个容器进行交换，此操作是 **常数复杂度** 而非线性的。

### `deque` 的实现细节

`deque` 通常的底层实现是多个不连续的缓冲区，而缓冲区中的内存是连续的。而每个缓冲区还会记录首指针和尾指针，用来标记有效数据的区间。当一个缓冲区填满之后便会在之前或者之后分配新的缓冲区来存储更多的数据。更详细的说明可以参考 [STL 源码剖析——deque 的实现原理和使用方法详解](https://blog.csdn.net/baidu_28312631/article/details/48000123)。

## 19.3 `list`

`std::list` 是 STL 提供的 [双向链表](../../ds/linked-list.md) 数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。

### `list` 的使用方法

`list` 的使用方法与 `deque` 基本相同，但是增删操作和访问的复杂度不同。详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/list)。`list` 的迭代器、长度、元素增删及修改相关的函数与 `deque` 相同，因此不作详细介绍。

#### 元素访问

由于 `list` 的实现是链表，因此它不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。

- `front()` 返回首元素的引用。
- `back()` 返回末尾元素的引用。

#### 操作

`list` 类型还提供了一些针对其特性实现的 STL 算法函数。由于这些算法需要 [随机访问迭代器](./iterator.md)，因此 `list` 提供了特别的实现以便于使用。这些算法有 `splice()`、`remove()`、`sort()`、`unique()`、`merge()` 等。

## 19.4 `forward_list`（C++11）

`std::forward_list` 是 STL 提供的 [单向链表](../../ds/linked-list.md) 数据结构，相比于 `std::list` 减小了空间开销。

### `forward_list` 的使用方法

`forward_list` 的使用方法与 `list` 几乎一致，但是迭代器只有单向的，因此其具体用法不作详细介绍。详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/forward_list)

# 20. 位运算进阶

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221214201118400.png" alt="image-20221214201118400" style="zoom:67%;" />
**思路：**考虑$a * b \% p = a * (k_1^{c_1} \% p + k_2^{c_2} \% p + ... + k_n^{c_n} \% p) \% p$，我们发现个问题不管我们在哪里取模都有可能超出长整形吗，但是倘若我们能使得 $a*k_i$不超出长整形范围，他们之间的加法也不会超出长整形，因为长整形的数据范围为 9e18。我们又考虑$a * c \% p = a * (k_1^{b_1} \% p + k_2^{b_2} \% p + ... + k_n^{b_n} \% p) \% p = a * (k_1 + k_1 + ... + k_2 + k_2 + ... +k_n + k_n)$，此时 $k_i$为质因子无法继续分解，我们如果想要相加不超过长整形，只能考虑 $k_i == 2$ 所以我们往二进制去想。
把 b写成二进制形式，然后如果某位上为1就加上它$a*（2^n）$（$n$与这位的位置有关）
并且每次计算后取模就可以了  

例：计算 3*7

```
7的二进制 111
3*(2^0)=3
3*(2^1)=6
3*(2^2)=12
```

观察可发现每次的可由前一次 * 2 推出(记得取模)

```
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

int main(){
    ll a,b,p,res;
    cin>>a>>b>>p;
    res=0;
    while(b){   //判断b里面还有没有1   龟速乘
        if(b&1)
            res=(res+a)%p;
        b>>=1; 
        a=2*a%p;    
    }
    cout<<res<<endl;
    return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221215144211618.png" alt="image-20221215144211618" style="zoom:67%;" />
**思路：**考虑 $a ^ b$ = $a^{c_1}*a^{c_2} *...*a^{c^n}$满足$c_1 + c_2 + ..c_n == b$，如果 $x \% 2 == 0$满足$a^x == (a^2)^{x / 2}$。倘若 $c_i$都是$c_{i - 1}$的整数倍，那么题目就变得简单起来了，如果$c_i == c_{i -1}$ 那么$n$最多为31，因为$2^{31}$是$b$的极限。所以我们考虑二进制分解$b$对于二进制的每一位来说从第$i$位到第$i + 1$位，我们都可以使得$a = a * a$，这样最后的复杂度就变为了$o(logn)$。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int b,p,k;
ll f(ll x,ll y){
	ll s = 1;
	while(y > 0){
		if(y & 1){
			s = s * x % k;
		} 
		x = x * x % k;
		y /= 2;
	}
	return s;
}
int main(){
	cin>>b>>p>>k;
	if(k == 1) cout<<b<<"^"<<p<<" mod "<<k<<"="<<0;
	else cout<<b<<"^"<<p<<" mod "<<k<<"="<<f(b,p);
	return 0;
} 
```

# 21. 进阶贪心

贪心最难的还是有关于推导的题目了，这种题目可能需要大量的证明，所以需要不断的练习才能达到偶尔能做出

### 21.1 示例题目

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221227094349642.png" alt="image-20221227094349642" style="zoom:67%;" />
**思路：**中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最有性，而不是局部最优性。具体的来说，我们设在仓库左边的所有点，到仓库的距离之和为p，右边的距离之和则为q，那么我们就必须让p+q的值尽量小。当仓库向左移动的话，p会减少x，但是q会增加n−x，所以说当为仓库中位数的时候,p+q最小。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221227094958308.png" alt="image-20221227094958308" style="zoom:67%;" />
对于 $100\%$ 的数据，$1 \le N \le 5\times 10^4$，$1 \le W_i \le 10^4$，$1 \le S_i \le 10^9$。
**思路：**假设现在有 a,b两个奶牛,重量和力量分别为Wa,Wb,Sa,Sb，a,b奶牛头上的奶牛重W。 那么对于a,b有两种情况，一种是a在b的头上，一种是b在a的头上 
1.a在b的头上，那么a的压扁指数就是 W - Sa，b的压扁质数就是 W + Wa - Sb。 
2.b在a的头上，那么a的压扁指数就是 W + Wb - Sa，b的压扁质数就是 W - Sb。 

题目要求我们求最小压扁指数，所以我们是想要求 max(max(W - Sa,W + Wa - Sb),max(W + Wb - Sa,W - Sb))

现在有4种情况

1. max(W - Sa，W + Wb - Sa)成立条件为 W - Sa > W + Wa - Sb，W + Wb - Sa > W - Sb   得到 Wa + Sa < Sb ，Wb + Sb > Sa 
2. max(W + Wa - Sb，W + Wb - Sa)成立条件为 W - Sa < W + Wa - Sb，W + Wb - Sa > W - Sb   得到 Wa + Sa > Sb ，Wb + Sb > Sa 
3. max(W - Sa，W - Sb)成立条件为 W - Sa > W + Wa - Sb，W + Wb - Sa < W - Sb   得到 Wa + Sa < Sb ，Wb + Sb < Sa 
4. max(W + Wa - Sb，W - Sb)成立条件为 W - Sa < W + Wa - Sb，W + Wb - Sa < W - Sb   得到 Wa + Sa > Sb ，Wb + Sb < Sa

对于情况1来说 max(W - Sa，W + Wb - Sa) = W + Wb - Sa 
对于情况2来说 若W + Wa - Sb > W + Wb - Sa 那么 Wa + Sa > Wb + Sb 
对于情况3来说 情况不存在，因为W - Sa 一定小于 W + Wb - Sa，W - Sb一定小于 W + Wa - sb 
对于情况4来说 max(W + Wa - Sb，W - Sb) = W + Wb - Sb 
情况1，4可以合并成一种情况 即 Wa + Sa < Sb，Wb + Sb > Sa 情况2 即为 Wa + Sa > Sb，Wb + Sb > Sa ，Wa + Sa > Wb + Sb
 综上所述，情况1 和 情况 2若不管 Wa + Sa > Wb + Sb 其实囊括了所有情况(就是奶牛a,b无论怎么放都可以) 那么加上条件Wa + Sa > Wb + Sb后我们也可以给情况1也增加这个条件 那么最优情况就是 Wa + Sa > Wb + Sb

# 22. 进阶模拟

高精度是算法竞赛学子们最讨厌写的一个东西，所以大多数学生会使用python来写高精度的题，不过我们还是得熟练去使用C++去书写，毕竟python真的很慢！

### 22.1 示例题目

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221227100533878.png" alt="image-20221227100533878" style="zoom:67%;" />

**思路：**和我们普通加法一样，只不过变成了字符的形式进行加减了而已，给他两个数组记录在字符数组里边，第一件事我们要比较两个数组的长度是否相等，长度不相等位数就不相等，所以我们还需要记录这些数字的长度，然后从两个数的第一位开始加，并且记录进位，依次模拟即可。

```
#include<iostream>
using namespace std;
const int maxn = 100010;
string n,m;
int a[maxn],b[maxn],c[maxn];
int main(){
    cin >> n >> m;
    for(int i = 0; i < n.length(); i++){
        a[n.length() - i] = n[i] - '0';
    }
    a[0] = n.length();
    for(int i = 0; i < m.length(); i++){
        b[m.length() - i] = m[i] - '0';
    }
    b[0] = m.length();
    int s = 0;
    for(int i = 1; i <= max(a[0],b[0]); i++){
        if(a[i] + b[i] + s >= 10){
            c[i] = (a[i] + b[i] + s) % 10;
            s = 1;
        }else{
            c[i] = a[i] + b[i] + s;
            s = 0;
        }
        c[0]++;
    }
    if(s == 1){
        c[0]++;
        c[c[0]] = 1;
        for(int i = c[0]; i >= 1; i--){
            cout << c[i];
        }
    }else{
        for(int i = c[0]; i >= 1; i--){
            cout << c[i];
        }
    }
    return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221227101622746.png" alt="image-20221227101622746" style="zoom:67%;" />
**思路：**首先数字相乘他们的位数应该相加，所以我们的数组大小要开数字长度的两倍，随后一位一位进行模拟乘法，并且记录进位即可。

```
#include<iostream>
using namespace std;
const int maxn = 100010;
string a,b;
int s1[maxn],s2[maxn],s3[maxn];
int main(){
    cin >> a >> b;
    s1[0] = a.length();
    s2[0] = b.length();
    for(int i = 0; i < s1[0]; i++){
        s1[s1[0] - i] = a[i] - '0'; 
    }
    for(int i = 0; i < s2[0]; i++){
        s2[s2[0] - i] = b[i] - '0';
    }
    for(int i = 1; i <= s1[0]; i++){
        for(int j = 1; j <= s2[0]; j++){
            s3[i + j - 1] += s1[i] * s2[j];
        }
    }
    for(int i = 1; i <= s1[0] + s2[0]; i++){
        if(s3[i] >= 10){
            s3[i + 1] += s3[i] / 10;
            s3[i] %= 10;
        }
    }
    int len = s1[0] + s2[0] + 5;
    for(int i = s1[0] + s2[0] + 5; i >= 2; i--){  //防止前导0
        if(s3[i] == 0) len = i;
        else{
            break;
        }
    }
    for(int i = len - 1; i >= 1; i--){
        cout << s3[i];
    }
    return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221227101928542.png" alt="image-20221227101928542" style="zoom:67%;" />
**思路：**此题b不超过10^9^所以就可以使用我们最简单的除法思路，从最高位开始，如果当前数比 b 大，则记录余数，否则的话答案就增加个0然后把当前数 * 10 加上下一位，模拟即可。

```
#include<iostream>
using namespace std;
string a;
const int maxn = 1000010;
int s1[maxn],s2[maxn];
int main(){
    int b;
    cin >> a >> b;
    s1[0] = a.length();
    for(int i = 1; i <= s1[0]; i++){
        s1[i] = a[i - 1] - '0';
    }
    int s = 0;
    for(int i = 1; i <= s1[0]; i++){
        if(s >= b){
            s2[i] = s / b;
            s = s % b;
        }else{
            s2[i] = 0;
            s = s * 10 + s1[i];
            if(s >= b){
                s2[i] = s / b;
                s = s % b;
            }
        }    
    }
    if(s >= b) {
        s2[++s1[0]] = s / b;
        s = s % b;
    }
    int h = 1;
    while(s2[h] == 0 && h < s1[0]){
        h++;
    }
    for(int i = h; i <= s1[0]; i++){
        cout << s2[i];
    }
    cout << endl << s << endl; 
    
    return 0;
}
```

