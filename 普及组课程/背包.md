# 什么是动态规划?

动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题
核心思想: 通过将问题拆分成一个一个小问题，记录过往结果，减少重复运算
小例子：

```
A ： "1+1+1+1+1+1+1+1 =？"
A ： "上面等式的值是多少"
B ： 计算 "8"
A : 在上面等式的左边写上 "1+" 呢？
A : "此时等式的值为多少"
B : 很快得出答案 "9"
A : "你怎么这么快就知道答案了"
A : "只要在8的基础上加1就行了"
A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"
```

# 什么是背包问题？

背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。

# 01背包

![image-20221008183530564](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183530564.png)


例题中已知条件有第$i$个物品的重量 $w_i$，价值 $v_i$，以及背包的总容量 $W$。

设 DP 状态 $f_{i,j}$为在只能放前$i$个物品的情况下，容量为$j$的背包所能达到的最大总价值。
那么对于容量为$j$，最大总价值为$f_{i,j}$，前$i$个物品一定有一种选取方式成立
考虑转移。假设当前已经处理好了前$i - 1$个物品的所有状态，那么对于第$i$个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为$f_{i - 1,j}$；当其放入背包时，背包的剩余容量会减小 ，背包中物品的总价值会增大 ，故这种情况的最大价值为$f_{i - 1,j - w_{i}} + v_i$。
由此可以得出状态转移方程：![image-20221011104826290](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011104826290.png)

## 实现：

```
代码块1
// C++ Version
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= W - w[i]; j++){
		f[i][j + w[i]] = max(f[i - 1][j] + v[i],f[i - 1][j + w[i]]);
	}
	for(int j = 0; j <= w[i] - 1; j++) f[i][j] = f[i - 1][j];
}
```

上述代码的空间复杂度和时间复杂度都是 O(nw)
有什么办法可以降低空间复杂度吗？
我可以发现每一个$f_{i,j}$他只与$f_{i - 1,j}$有关，所以当我们遍历到$i$的时候$i - 1$以前的状态我们都可以舍弃不要，所以我们每次只需要记录两种状态就可以了，所以我们可以采用滚动数组。

```
代码块2
// C++ Version
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= w[i] - 1; j++) f[i % 2][j] = f[(i - 1) % 2][j];
	for(int j = 0; j <= W - w[i]; j++){
		f[i % 2][j + w[i]] = max(f[(i - 1) % 2][j + w[i]],f[(i - 1) % 2][j] + v[i]);
	}
}
```

那么能不能再简化呢？
如果我们只用一维行不行?

```
代码块3
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
```

![image-20221011105701889](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011105701889.png)


```
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);
//需要对0~w[i] - 1的进行操作吗？
```

为什么这样枚举就是正确的呢？
大家可以自己的想一想，我们每次更新的$f_l$是从大到小更新的，而没有更新过的都是上一物品转换完的状态。

# 完全背包

![image-20221008183718260](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183718260.png)

![image-20221011110332625](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011110332625.png)
这样的枚举方法就是把完全背包转换成了01背包，把一个物品$i$当作一个物品，把两个物品$i$当作一个物品，...，把n个物品$i$当作一个物品。

```
代码块4
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++){
      for(int k = 0;;k++){
          if(k * w[i] + l > W) break;
          f[i][l + k * w[i]] = max(f[i][l + k * w[i]],max(f[i - 1][l + k * w[i]],f[i - 1][l] + k * v[i]));
      }
      for(int l = 0; l <= w[i] - 1; l++) f[i][l] = f[i - 1][l];
  }
```

那么我们如何进行一个优化呢？我们换个思想去想，只要我们给物品$i$足够的个数，再取01背包，这样看来也是完全背包。
物品1可以取无限次，和有无限个物品1，每个只能取一次，这俩个是等价的

![image-20221011141346834](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221011141346834.png)

```;
代码块5
// C++ Version
for (int i = 1; i <= n; i++){
  for(int l = 0; l <= w; l++) f[i][l] = f[i - 1][l];
  for (int l = 0; l <= W - w[i]; l++)
  	f[i][l + w[i]] = max(f[i][l + w[i]],f[i][l] + v[i]));
}
```

随后我们发现$f_{i,j}$只和自己这些物品有关系

```
代码块6
// C++ Version
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
```

# 多重背包

![image-20221008183835536](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221008183835536.png)


```
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= W; j++){
 		for(int l = 0; l <= k[i]; l++){
			if(j + l * c[i] > w) break;
			dp[i % 2][j + l * c[i]] = max(dp[i % 2][j + l * c[i]],dp[(i - 1) % 2][j] + v[i]);
		}
	}
}
```

![image-20221009133332834](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133332834.png)


![image-20221009133342948](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133342948.png)
典型的空间复杂度换取时间复杂度的做法


```
// C++ Version
index = 0;
for (int i = 1; i <= m; i++) {
  int c = 1, p, h, k;
  cin >> p >> h >> k;
  while (k - c > 0) {
    k -= c;
    list[++index].w = c * p;
    list[index].v = c * h;
    c *= 2;
  }
  list[++index].w = p * k;
  list[index].v = h * k;
}
```

# 混合背包

![image-20221009133533775](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133533775.png)



```
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```

# 二维费用背包

![image-20221009133809722](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009133809722.png)


```
f[i][j][k]表示前i个任务花费了j分支k元产生的最大价值
f[i][j][k] = max(f[i][j][k],f[i][j - t[i]][k - c[i]] + w[i]);
```



# 分组背包

![image-20221009134913202](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009134913202.png)

```
// C++ Version
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])
        dp[i] = max(dp[i],dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

# 有依赖的背包

![image-20221009134951865](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009134951865.png)
当作分组背包来看，主件，附件 + 主件，只能买一样



# 其他：

![image-20221009135642563](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009135642563.png)


```
int v = V;  // 记录当前的存储空间
// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
for (从最后一件循环至第一件) {
  if (g[i][v]) {
    选了第 i 项物品;
    v -= 第 i 项物品的重量;
  } else {
    未选第 i 项物品;
  }
}
//大家对于输出方案只需要思考，如果我们现在的最大空间是W,最大的价值是V
//一定是有一种方案使得价值是最大
//最后一点空间一定是由我们最后买的那件商品去填补的
//所以如果最后一件商品在方案中 一定存在 dp[W] == dp[W - w[i]] + v[i];
```

![image-20221009135759179](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221009135759179.png)














