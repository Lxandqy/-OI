# 1.第一个C语言程序

平常随处可见的电脑想要运行起来，软件运行起来，需要我们人类告诉电脑如何运行，但是电脑又听不懂我们的话那该怎么办。这就创造了我们的语言: C语言，C++，JAVA，Python。但是我们语言这么多种我们为什么就偏要学C语言，C++呢？

那么C语言和C++有什么区别呢，具体来说C语言是C++的爹，因为C++是在C语言的基础上进行改进的。所以C语言能用的C++也能用，C++能用的C语言用不了，所以我们可以先学C语言再学C++。

下面一起来看一段代码:

```
#include<stdio.h> //include在英文是包含的意思，包含stdio.h里面的一些内容(C语言作者)
int main(){ //告诉电脑我们从这里开始运行
	
	printf("Hello C语言"); //输出一句话 Hello C语言
	printf("Hello C语言2"); //输出一句话 Hello C语言2
	printf("Hello C语言3"); //输出一句话 Hello C语言3
	printf("Hello C语言4"); //输出一句话 Hello C语言4
	//printf("Hello C语言5");
	return 0; //返回0
}
```

我们一句一句来解析到底干了什么事情

-  `#include<stdio.h>`
  include在英文是包含的意思，包含`stdio.h`里面的一些内容
  这些内容是由创造C语言的人给我们的工具箱，就像下面的 `printf`就是工具箱里面的一个工具

- `main`
  他是一个 **函数**(后边会学) 他告诉电脑，从他这里开始运行代码，代码必须从上往下一句一句执行。(程序的入口)

- `{ }` 
  大括号里面写我们想要干的事情，包含内容。

- `printf` 
  可以输出中文，字母，数字等

- `return 0 `
  return是返回的意思，这句话就是告诉电脑，我做完了这件事得到了什么结果

- `" " `
  双引号，是字符串的意思，里面的内容就是我们想要输出的东西

- `;`
  这个标识相当于语文中的句号，表示我们说完了这句话，称作语句，只有计算机看得懂的合法操作才算是语句。

- `// `
  注释，把一些不需要机器运行的句子给注释掉。

我们想要学好语言的第一件事就是要知道语言的规则是什么，如何写才能正确。

第一个提到的规则就是**语句的规则** ： 语句一定是需要计算机能看懂的东西，例如数字，字符，字符串。

```
10;
"123123";  //在计算机中双引号引起来的叫做字符串
"abc"; 
'a'; //单引号引起来的叫做字符
```

### 练习：

1. 以下哪些是合法语句？

   ```
   1;
   asd;
   "111";
   231;
   ();
   *;
   &;
   ^;
   '111';
   '&';
   "&^*%$";
   ```

2. 试验以下操作
   1.如果写两个`main`函数会怎么样？
   2.如果不写`return`会怎么样
   3.如果写`return 1`，`return 2`会怎么样
   4.如果不写`#include<stdio.h>`会怎么样
   5.如果`printf `不写`" " `会怎么样

<div STYLE="page-break-after: always;"></div>

# 2.输入 输出

### 示例程序输出

```
#include<stdio.h>
int main(){
	printf("我是大帅哥");
	printf("我是大美女\n");
	printf("我是小帅哥");printf(" 我是小美女");
	return 0;
}
```

大家通过示例程序会发现最后输出如下

```
我是大帅哥我是大美女
我是小帅哥 我是小美女
```

以上代码体现了几个重点

- 3,4行输出代码写在不同行，但是最后输出并没有换行，说明我们主观上的换行不行
- 4行加入了 `\n`  结果输出换行了，说明 `\n` 是用来换行的
- 第5行写了两个语句并没有出现错误，说明一行可以写多句代码。

## 2.1输入

在平常使用电脑或者手机中，我们有很多方式可以输入，例如电脑的键盘，手机的触屏。那么需要输入的场景也是各种各样的，比如你在聊天的时候需要输入才能发送消息给你的朋友，那么输入到哪去？输入到聊天框去，那么也就是说聊天框变成了我们信息的载体，帮我们存储了这些信息。那么C语言也是一样的，当我们输入进去的东西如果没有东西给他存下来的话，那么这些信息就会消失。

输入以下步骤：

1. 使用输入工具`scanf("")`
2. 选择输入的载体
3. 输入你的信息

但是目前我们好像并没有好的载体，所以就有了我们的**变量**。

**变量**就是在C语言中用来存储**信息的载体**，变量有各种各样的类型 ：整形，浮点数，字符等…

那么为什么变量需要这么多类型：举个例子我们在家里做菜的时候，有许多的调料：鸡精、味精、醋、酱油等，这些调料都是分别放在各自的盒子里，假如把放醋的放到酱油里，那么他们的味道就会混合，让我们的菜变得混乱，所以数据也是一样，为了防止数据混乱，我们创造了许多类型。同时大家可能会疑问：”老师不同类型我能够理解，为什么要创造长整型，整形呢？“这个问题很好解释：我们知道变量是信息的载体，那既然是载体那肯定需要空间，每个载体的空间都是需要向我们的计算机去申请的，倘若计算机空间不够这个变量就申请不了了，不仅如此申请成功的空间后，我们会给这个变量一个地址。我们都知道不同的物品大小需要的盒子大小就不同，所以对待不同大小的数据我们需要不同大小的变量，假如一串数字 1234567890123456789，和一串数字 123，我们就能知道 123所需要的空间肯定更小。

**常见的变量类型有以下几种:**

|   类型写法    |   类型含义   |  占位符  |
| :-----------: | :----------: | :------: |
|    **int**    |   **整形**   |  **%d**  |
| **long long** |  **长整形**  | **%lld** |
|   **float**   | **单浮点数** |  **%f**  |
|  **double**   | **双浮点数** | **%lf**  |
|   **bool**    |   **布尔**   |  **无**  |
|   **char**    |   **字符**   |  **%c**  |

既然我们有变量类型那肯定有变量名：所以代码一般这样写

```
int a; //合法语句
char b;
int c,d;
```

以上代码被称为**变量的声明**，就相当于书本的目录，告诉计算机从这一行开始我创造了一个什么类型的载体，但是这个载体内部一开始存的是什么我们不知道

**变量类型被称为关键词，变量名被称为标识符。**

**取名也是有规则的**: 可以用小写字母，大写字母，数字和下划线(_)来命名。而且名称的第1个字符必须是字母或下划线，不能是数字。

| 有效的名称 | 无效的名称 |
| ---------- | ---------- |
| wiggles    | $Z]**      |
| cat2       | 2cat       |
| Hot_Tub    | Hot-Tub    |
| _kcab      | Tax rate   |

### 整型类型

**作用**：整型变量表示的是整数类型的数据。

**语法：**`int a = 123;`

### 实数类型

**作用**：用于表示小数

浮点型变量分为两种：

1. 单精度float 
2. 双精度double

### 字符类型

**作用：**字符型变量用于显示单个字符

**语法：**`char ch = 'a';`

> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号

> 注意2：单引号内只能有一个字符，不可以是字符串

### 布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

**语法：**`bool a = true 或 bool a = 1 `

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

那么我们创造好了信息的载体，就开始把我们输入的信息放到载体里面去。

大家可以看到，我们上边表格是有一个栏叫做占位符，那么占位符又有什么用呢？我们先来看一段代码的例子。

```
#include<stdio.h>
int main(){
	int a;int b;
	scanf("%d",&a);
	printf("%d",a);
}
```

这段代码当我们输入什么数字，就会输出什么数字，但是当我们把 `%d` 去掉之后，连输入都没有输入程序就结束了。

那么这个占位符就是告诉计算机我在这里位置要输入什么数据，那么计算机就会给我们留位置输入，一个占位符对应一个变量。

举个例子：

```
char a,b,c,d;
scanf("%c%c%c.%c",&a,&b,&c,&d);
```

**对于计算机来说的话，我们的scanf其实相当于一个原料分拣窗口，%c相当于一个接受字符类型的占位符，相当于分拣器的一个框框。当我们的计算机如果期望读到 “[一个字符] [一个字符] [一个字符] . [一个字符]” 按照这样子格式输入的数据。当读到123.4的时候他就会把这个读入拆分成"['1'] ['2'] ['3'] . ['4']"，当每个框框都读取到足够的数据后，就会让后面的框框读取第一个分拣框把 数据 '1'转交给了变量a，一直到第四个分拣框把数据'4'交给了变量d。 那么转交给他的话就是需要我们的地址符号&**

![image-20230227140601029](C:%5CUsers%5CAdmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230227140601029.png)

大家可以尝试一下不加上 `&` 会发生什么。导致这个的原因我举个例子大家就明白了。

就像爸爸妈妈让我们把饼干放盒子里面，那么饼干就一定在盒子里了吗？一定要我们去盒子所在的位置把饼干放进去才可以。

**所以C语言也是一样  我们必须要告诉计算机，这个变量的位置在哪里。**

**那么C语言作者给我们创造了一个符号 &(取地址) ,&a就表示 变量a的位置。**

所以全部都结合在一起就是

```
#include<stdio.h>

int main(){ 
	int a;
	long long b;
	float c;
	double d;
	char e;
	scanf("%d %lld %f %lf %c",&a,&b,&c,&d,&e); 
	printf("%d %lld %f %lf %c",a,b,c,d,e);//输出也是一样，但是请思考输出为什么不用加&
	return 0; //返回0
}
```

## 2.2输出

通过示例程序我们已经会了输出一些特定的字符串，不过变量我们也是可以输出的。

输出和输入一样输出的占位符就是表示在这个位置输出，但是不需要加 `&` ，因为我们把东西存进去后，我们已经拥有了这一部分的记忆。

当然占位符不仅仅可以输出变量也可以输出常量

程序如下：

```
#include<stdio.h>

int main(){ 
	int a = 2;
	double b = 3;
	printf("%d %lf %d %d %c",a,b,1,2,'a');
	return 0; //返回0
}
```

### 注意:

对于浮点数来说是有保留几位小数的，c++很人性化给出了几个例子

```
printf("%.2f",a);就是保留两位小数输出
printf("%.3f",a);就是保留三位小数输出
```

## 2.2 赋值

变量我们说是信息的载体，所以对于变量来说我们除了用输入把信息放进去，我们还有一种方法就是赋值。

计算机赋值符号是 `=`。注意：不是等于

一般形式为 `变量 = 表达式;`

使用赋值会把原来存在载体中的信息覆盖掉。  **=左边的叫做左值，右边的叫右值，常量不能当左值。**举例如下代码：

```
1 = 2;// 这样是错误的 ，因为 1 是常数所以不能当左值
int a = 1; //变量可以在声明的过程中就直接赋值
int c,d = 1,e = 2;//变量可以在声明的过程中就直接赋值
a = 2; //变量直接赋值为常量
int b = a;//变量也可以赋值为变量
```

但是大家请注意以下2点：

1. 由于赋值表达式 `=` 右边的表达式也可以是赋值表达式，因此下述表达形式
   变量 = (变量 = 表达式); 这样子是成立的，其一般展开形式为：
   变量 = 变量 = 变量 = …. = 表达式
   例如 a = b = c = 5，它实际等价于 c = 5; b = c; a = b;

2. 在进行赋值运算时，如果赋值运算符两边的数据类型不同，系统会自动进行类型转换，即将赋值运算符右边的数据类型转换成左边的变量类型。当左边是整形而右边是浮点数时，将去掉小数部分并截取该整形对应的有效位数。例如：

   ```
   int a = 123.567;
   printf("%d",a); //输出123
   ```

### 示例程序

**例1：** 输入两个整数 a 和 b，尝试交换 a，b的值(使 a 的值等于 b，b 的值等于 a)

**【分析】** 交换两个变量值的方法很多，一般我们采用引入第三个变量的算法，两个变量交换，可以想象成一瓶酱油和一瓶醋交换，这时容易想到哪一个空瓶子过来：①将酱油倒入空瓶 ②将醋倒入酱油瓶 ③将原空瓶的酱油倒入醋瓶 。 程序如下：

```
#include<stdio.h>
int main(){
	int a,b,c; //声明三个变量
	scanf("%d %d",&a,&b);
	c = a; a = b; b = c;
	printf("%d %d",a,b); 
}
```

**例2：** 求三个整数的和

输入 a,b,c三个整数，输出它们的和。

**【分析】** 我们有两种选择，第一种选择定义四个整形变量 a,b,c,d。其中 a,b,c 用来存储输入，d 用来存储 a + b + c 的和最后输出 s，第二种就是直接按照整形输出 a + b + c 的值。 

```
#include<stdio.h>
int main(){
	int a,b,c; //声明三个变量
	scanf("%d %d %d",&a,&b,&c);
	int s = a + b + c;
	printf("%d",a + b + c);
    //printf("%d",s);
}
```

**例3：** 小明买图书

已知小明有 $n$ 元，他买了一本书，这本书原价为 $m$ 元，现在打 8 折出售。求小明还剩多少钱(保留2位小数)。

**【分析】**这个题主要考察格式化输出的方式，保留两位小数。

```
#include<stdio.h>
int main(){
	double n = 0,m = 0,c = 0,d = 0;
	scanf("%lf %lf",&n,&m);
	c = m * 0.8;
	d = n - c;
	printf("%.2lf",d);
    //printf("%d",s);
}
```

### 练习：

1. 输入一个整形 a 以下哪个选项正确（ ）

   A`.scanf("%d",&a);`   	B.`scanf("%c",&a);`		C.`scanf("%d",a);`		D.`scanf("%f",a);`

2. 输出一个双浮点数 a 以下哪个选项正确（ ）

   A.`printf("%d",a);`		B.`printf("%c",&a);`		C.`printf("%f",&a);`		D.`printf("%lf",a);`

3. 输出我是大傻蛋 以下哪个选项正确（ ）

   A.`printf("我是大傻蛋");`		B.`printf(我是大傻蛋);`		C.`printf("我是大傻蛋")`

4. 请手写 分别输入整形 a，字符 b，单浮点数c 并且输出出来 (每输出一个换一个行)。

   

5. 请问以下哪些操作是合法的；

   ```
   int a = 1;
   a = -a;
   ```

   ```
   char a = 'a';
   ```

   ```
   char a = '1';
   ```

   ```
   char a = '123';
   ```

   ```
   char a = "1";
   ```

   ```
   float a = 1;
   ```

   ```
   double a = 0
   ```

   ```
   int a;
   a = 1;
   ```

   ```
   int a;
   scanf("%f",&a);
   ```

   ```
   int a;
   scanf("%d",a);
   ```

   ```
   int a = 2;
   scanf("%d",&a);
   ```

   ```
   printf("%d",1);
   ```

   ```
   int a = 1;
   printf("%d",&a);
   ```

   ```
   printf("");
   ```

   ```
   printf('%c','a');
   ```

   ```
   printf("12314%d",1);
   ```

   ```
   printf("%d",1,2,3);
   ```

   ```
   printf("%d %d %d",1);
   ```

   ```
   printf("123""123");
   ```

   ```
   printf("123","123");
   ```

   ```
   int a = 1,b,c,d = 1;
   ```

   ```
   int a,int b,int c;
   ```

6. 下面的一个程序想要问一下你的意见有没有错误

   ```
   #include<stdio
   
   int main(){
   	
   	int a,b,c = 2;
   	printf("%d",a,b);
   	printf("%d %d",c)
   	return;
   
   ```

7. 请问以下代码会输出什么？

   ```
   printf("Baa Baa Black Sheep.");
   ```

   ```
   int num;
   num = 2;
   num = 3;
   printf("%d + %d = %d",num,num,num + num);
   ```

   ```
   printf("123","1234");
   ```

   ```
   printf("123123""123");
   ```

   ```
   printf("123%d""123%d",4,5);
   ```

   ```
   printf("%d%d",1,2);
   ```

   ```
   int a = 100;
   int b = a = 12 * 10;
   ```

8. 以下哪个选项能在电脑上输出( )(多选)

   ```
     *
    ***
   *****
    ***
     *
   ```

   A. $printf("\ \ *"); printf("\ ***"); printf("\ *****");printf("\ ***");printf("\ \ *");$

   B.$printf("\ \ *\n"); printf("\ ***\n"); printf("\ *****\n");printf("\ ***\n");printf("\ \ *\n");$

   C.$printf("\ \ *\n\ ***\n\ *****\n\ ***\n\ \ *\n");$

9. 考虑以下程序

   ```
   #include<stdio.h>
   int main(){
   	int a,b;
   	a = 5;
   	b = 2;//第7行
   	b = a;//第8行
   	a = b;//第9行
   	printf("%d %d",b,a)；
   	return 0;
   }
   //请问执行完第7，8，9行后程序的状态分别是什么 (a等于几，b等于几)
   ```


<div STYLE="page-break-after: always;"></div>

# 3.运算符

运算符有特别多，我们现在只讲几个常用的运算符，后面的学习运算符会越来越多

## 3.1算术运算符

用于各类数值运算。包括加( `+` )、减( `-` )、乘( `*` )、除( `/` )、求余(或称作取模运算, `%` )、自增( `++` )、自减( `--` )。

- 模运算符
  求余的运算符 `%` 也称作模运算符 ，是一个双目运算符，俩个操作数都是整型数。 a % b 的值就是 a除以b 的余数， 5 % 2 = 1，其操作对象只能为整数。注意 `%` 的原理就是 a % b ，为 a - a / b * b (a / b为向下取整)。
- 除法运算符
  C语言中的 `/` 和数学中的不太一样，数学中 1 / 2 = 0.5 但是C语言是分为整形，浮点数的，所以C语言中 整形 / 整形=整形(向0取整），浮点数 / 整形 = 浮点数，浮点数 / 浮点数 = 浮点数 ，整形 / 浮点数 = 浮点数

**注意：**取模只能整数对整数，不能其他类型！，并且取模也不能对0取模

```
#include<stdio.h>
int a,b,c;
double d;
int main(){ 
	a = 10,b = 100,c = 10,d = 1.0;
	printf("%d %d %d %d %d %lf\n",a * b,a + b,c - b,(a + b) * c,a + b * c,d / a);
	return 0; //返回0
}
//输出  1000 110 0 1100 1100 0.1000000
```

**当然C语言中也存在运算优先级，括号优先，乘法除法取模再次，加法减法最后。**

- 自增自减运算符

自增、自减运算符用来对一个操作数进行加1或减1运算，其结果仍然赋予该操作数， 而且参加运算的操作数必须是变量，而不能是常量或表达式。

（1）	自增运算符。例如，`x++` 表示在使用 x **之后**，使 x 的值加 1 ,即 `x = x +1`；` ++x` 表 示使用 x 之前，先使 x 的值加 1 ,即 `x = x + 1`。

例如：

```
int x = 1,y = 1;
int a = x++,b = ++y;
printf("%d %d %d %d",a,b,x,y);
//输出了 1 2 2 2 说明 x++ 是先使用了 x 后使用 x = x + 1，++y 是先使用 y = y + 1 后使用 y
```

（2）	自减运算符。例如，`x—-` 表示在使用 x **之后**，使 x 的值减 1 ,即 `x = x - 1`； `--x` 表 示使用 x 之前，先使 x 的值减 1 ,即 `x = x - 1`。

例如：

```
int x = 1,y = 1;
int a = x--,b = --y;
printf("%d %d %d %d",a,b,x,y);
//输出了 1 0 0 0 说明 y-- 是先使用了 y 后使用 y = y - 1，--y 是先使用 y = y - 1 后使用 y
```

## 3.2关系运算符

关系运算符一般用于比较运算。包括 大于( `>` )、小于(` <` )、等于( `==` )、大于等于(  `>= ` )、小于等于( `<=` ) 和 不等于( `!=` )。

他们都是二元运算符，也就是说有两个操作数，例如使用就是 a > b，a == b 等

对于这些操作数也是有结果的，也就是真和假，计算机在给出这些结果中 以 `1` 代表 真，`0` 代表 假，但是反过来在判断一个值是真还是假的时候以 `0` 代表假，用 `非0` 代表真。

```
printf("%d %d %d %d",2 > 1,2 == 2,2 != 2,1 <= 2);
//最后会输出 1，1，0，1
```

## 3.3逻辑运算符

逻辑运算符包括 与( `&&` )、或( `||` )、非( `!` )。

与运算符 和 或运算符均为双目运算符，具有左结合性，非运算符为单目运算符，具有右结合性。

- 与运算符：也就是 和 的意思，只有参与运算的两个都为真才为真，有一个为假就为假。
  例如 5 > 0 && 4 > 2，由于 5 > 0 为真，4 > 2 为真，所以与出来的结果也为真。

- 或运算符：也就是 或者 的意思，只要参与运算的有一个为真就为真，两个都为假才为假。
  例如 5 > 0 || 5 > 8，由于 5 > 0 为真，5 > 8 为假，所以或出来的结果也就为真。

- 非运算符：就是把假的变为真的，真的变为假的。
  例如 !(5 > 0)，由于 5 > 0 为真，进行非运算后最终的结果为假。

逻辑运算符和其他运算符优先级的关系可表示如下：

按照与运算符的优先顺序可以得出：

a > b && c > d 等价于 (a > b) && (c > d)

!b == c || d < a 等价于 ((!b) == c) || (d < a)

a + b > c && x + y < b 等价于 ((a + b) > c) && ((x + y) < b)

## 3.4逗号运算符

在C语言中，可以把多个表达式用逗号联接起来（或者说，把这些表达式用逗号分开），构成一个更大的表达式。其中的逗号称为**逗号运算符**，所构成的表达式称为逗号表达式。逗号表达式中用逗号分开的表达式分别求值，以最后一个表达式的值作为整个表达式的值。

**用法1：**当做表达式之间的分隔符，使得表达式相互没有任何影响

```
int a = 1,b = 2;
a += 1,b += 2;
```

**用法2：**求值

如果在语句中同时用了逗号运算符和赋值运算符，则需要特别注意，**赋值运算符的优先级高于逗号运算符**。看下面这两个例子：

```
int a1,b = 2,c = 7,d = 5;
a1 = (++b,c--,d + 3);
```

本例，对于第 2 行，由于用逗号分开的三个表达式被包含在括号内，所以先计算这个括号内的表达式，再进行赋值。括号内的表达式的最终值应该是最后一个表达式的值，也就是 (d+3) 的值，为 8，所以 a1 被赋值为 8。

```
int a1, b = 2, c = 7, d = 5; // 第1行
a1 = ++b, c--, d + 3; // 第2行
```

本例，对于第2行，由于赋值运算符的优先级高于逗号运算符，所以“ a1 = ++b ” 实际是逗号表达式中的一个子表达式，虽然最终表达式的值虽然也为 8，求值之后，“ ++b ” 的值为3，a1 被赋值为 3 ，而整个逗号表达式的值为 8。

## 3.5运算符的简写

在C语言中，有一些运算符可以简写，如下表：

|  简写  |   含义    |
| :----: | :-------: |
| a += b | a = a + b |
| a -= b | a = a - b |
| a *= b | a = a * b |
| a /= b | a = a / b |
| a %= b | a = a % b |

运算符的优先级如下：

| 优先级 | 运算符                                                       | 结合律   |
| :----: | ------------------------------------------------------------ | -------- |
|   1    | 后缀运算符：[]   ()   .   ->  ++  –  (类型名)   {列表}       | 从左到右 |
|   2    | 一元运算符：++   –   ！  ~   +   -    *    &    sizeof_Alignof | 从右到左 |
|   3    | 类型转换运算符：（类型名称）                                 | 从右到左 |
|   4    | 乘除运算符： *      /      %                                 | 从左到右 |
|   5    | 加减运算符：  +     -                                        | 从左到右 |
|   6    | 移位运算符：   <<      >>                                    | 从左到右 |
|   7    | 关系运算符：    <<=     >>=                                  | 从左到右 |
|   8    | 相等运算符：   ==     !=                                     | 从左到右 |
|   9    | 位运算符 AND ： &                                            | 从左到右 |
|   10   | 位运算符 XOR ： ^                                            | 从左到右 |
|   11   | 位运算符 OR ： \|                                            | 从左到右 |

### 练习：

1. 下面的运算是真是假？
   正整数 >= 负数
   整数 >= 负数
   1 >= 2
   2 >= 2
   -2 >= -1
   -2 < -1
   1 == 2
   1 != 2
   2 > 1 > 1
   10 < 1 < 1
   10 != 2 != 1
   10 != 2 != 0
   2 >= 1 >= 1
   5 > 1 > 2 > 1 > 1 != 0
   2 == 1 == 2 == 3 == 0

2. 给定3个整数 a，b，c。计算出表达式 (a + b) * c

   

3. 给定3个整数 a，b，c。计算出表达式 (a + b) / c

   

4. 给定被除数 a，除数 b，求出整数商和余数

   

5. 输入一个数字 a ，假设 a 是偶数则输出0，否则输出 1 

   

6. (3 >= 2) && (5>= 3）真还是假？

   (3 >= 2) && (2 >= 3)  真还是假？

   (1 >= 2) && (2 >= 3)  真还是假？

   (3 >= 2) || (5>= 3）真还是假？

   (3 >= 2) || (2 >= 3)  真还是假？

   (1 >= 2) || (2 >= 3)  真还是假？

   (3 >= 2) && (！(5>= 3) )真还是假？

   (3 >= 2) && (！(2 >= 3) ) 真还是假？

   (1 >= 2) && (！(2 >= 3) )  真还是假？

   (1 >= 2) || (！(2 >= 3) )  真还是假？

   (1 > 2 > 3） && (1 < 2 < 3) 是真还是假？



<div STYLE="page-break-after: always;"></div>

# 4.计算机中的数据

## 4.1 原码反码补码

在我们使用以上运算符的时候我们有时候会得到错误的值，例如：

```
#include<stdio.h>
int main(){
	int a = 1000000000,b = 10000000000;
	printf("%d %d",a + b,a * b);
}
```

我们发现与我们的预期值不一样，为什么相乘得到了负数，相加变小了。

这个时候就要说到我们的数据存储，以及数据大小了。

给大家举个例子，我们现实中的盒子有大有小，大的装的东西比较多，小的装的东西比较小，如果我们用大的容器装很少的东西我们会觉得很浪费，如果用小容器装很大的东西又装不下，计算机也是一样，它能装的东西有限，所以C语言作者给每个变量都设置了一定的大小。

|    变量名     |   变量翻译   |  占用内存   |
| :-----------: | :----------: | :---------: |
|    **int**    |   **整形**   | **4个字节** |
| **long long** |  **长整形**  | **8个字节** |
|   **float**   | **单浮点数** | **4个字节** |
|  **double**   | **双浮点数** | **8个字节** |
|   **bool**    |   **布尔**   | **1个字节** |
|   **char**    |   **字符**   | **1个字节** |

**那么到底什么是字节呢，字节就是最小的单位吗？其实计算机中最小的单位是位，1个字节(Byte) =8位(Bit)**。**什么是位**？就是我们在数字中的个位十位，这种位。

在计算机中数据全都是跟二进制有关来存储的，那么我们先来讲讲二进制这些事。

首先要讲二进制的话，我们首先就要谈到我们的十进制数字也就是我们平常使用的个十百千万这种数字。十进制的数字每一位有十种状态，从0~9，一共有十个数字，十进制逢十进一。首先我们来看一个例子：

12345 = 1 * 10^4^ + 2 * 10^3^ + 3 * 10^2^ + 4 * 10^1^ + 5 * 10^0^   （x^y^称作x的y次幂，也就是 y 个 x 相乘的结果，x^0^是1）

一般来说我们对于数字从右往左分别称作第一位，第二位….. 那么12345的第一位就是 5，第二位就是 4 …..。

那么二进制就很简单，也就是每一位有两种状态，0~9，一共有两个数字，逢2进 1，我们来看一个例子：

101001 = 1 * 2^5^ + 0 * 2^4^ + 1 * 2^3^ + 0 * 2^2^ + 0 * 2^0^ + 0 * 2^1^ = 41

其实41 和 101001 的本质是一样的，只不过表示形式不一样，所以  $41_{10} / x$ 和 $101001_{2} / x$ 产生的答案是一样的。

二进制转换成十进制其实很简单，就按照我们上述方法即可，大家可能会对十进制转换成二进制比较难以接受。

**方法：**

​			我们可以先把值转换成二进制的第一位，再通过逢2进1的方法慢慢向更高位进。例如：

​			41 -> 00000(41) -> 0000(20)(1) -> 000(10)(0)(1) -> 00(5)(0)(0)(1) -> 0(2)(1)(0)(0)(1) -> (1)(0)(1)(0)(0)(1)

​			也就是第一位拿到数后对 2 取模，剩下的就是第一位的数，商就是需要进位的数，同样的第二位对 2 取模，剩下的就是第二位的数，商就是需要进位					以此类推我们最终可以得到最终答案。

​			那么这种方式也可以这么看：我们直接一步到位从最高开始，依次降低每一位。

二进制的运算其实也很简单就是逢二进一就好了举个例子：

$101011_{2} + 1110_{2}$，和十进制一样，位数不够的可以补0，也就是说左边的式子可以变为 $101011_{2} + 001110_{2}$ ，随后从第一位开始进行加法即可，但是我们要		注意一个点也就是，二进制下是逢二进一。运算如下：


![image-20230227201940904](C:%5CUsers%5CAdmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230227201940904.png)



二进制的乘法与十进制也是一样，只不过乘起来的数也是逢二进一。

$101011_{2} * 1110_{2}$，和十进制一样，位数不够的可以补0，也就是说左边的式子可以变为 $101011_{2} * 001110_{2}$ 

![image-20230227223745773](C:%5CUsers%5CAdmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230227223745773.png)


讲完二进制后，我们就开始讲与我们计算机有渊源的三个码：**原码、反码、补码**。

首先就是二进制为什么不能当计算机的码，最直接的原因就是，二进制无法直接表示负数，需要加上负号。

### 原码

原码是在二进制的基础上发明的，原码在二进制的基础上新增了一个叫做符号位，将二进制下的最高位变成了符号位，因为正号负号刚好两种状态，由于 （-1）^0^为 1 ，(-1)^1^ 为 -1，所以在原码中也是这么定义的最高位为 1 的时候表示这个数是负数，最高位为 0 的时候表示这个数为负数。

举个例子： 

​		$(10011)_{原}$ = -3，$(01101)_{原}$ = 13。

那么我们十进制转换成原码有一个好方法，就是先可以把这个十进制的绝对值 (负数的绝对值为相反数0，正数不变) 用二进制先写出来，最后再加上符号位。 

例如：

​		$-15_{10}$ 的绝对值是 $15_{10}$，$15_{10} = 1111_{2}$ ，因为 $-15_{10}$ 是负数，所以符号位应该为1，最终答案就是 $11111_{2}$

不过原码是一个有缺陷的码，原码在做加法运算的时候，假如符号位不同，符号位如何改变我们无法通过加减直接得出，不过乘法运算是正确的。

例如：

​		$(1011)_{原}$ + $(0111)_{原}$ = $(10010)_{原}$，但是这明显是错误的 $(1011)_{原}$ = -3，$(0111)_{原}$ = 7，$10010_{原}$ = -2，所以运算结果不正确

### 反码

为了解决原码这种运算错误的情况，我们发明了补码，反码是在原码的基础上改进的，反码的定义：：正数的反码与其原码相同，负数的反码是对正数逐位取反（0变成1,1变成0）

举个例子：

​		$(10011)_{原}$ = $(11100)_反$，$(01111)_原$ = $(01111)_反$

那么我们最重要的问题就是，当原码转换成反码后运算是否正确。

例如：

​		$(1011)_{原}$ + $(0111)_原$ ，$(1011)_原$ = $(1100)_反$ $(0111)_原$ = $(0111)_反$，$(1100)_反$ + $(0111)_反$ = $(11011)_{反}$ = $(10100)_{原}$ = -4，答案正确

但是像这种拥有符号位的码还是有一个缺陷比如: $(1000)_原 $= -0   $(0000)_原 $= 0，但是正0，负0是毫无意义的，所以我们就舍弃了带有符号位的码

### 补码

为了解决+0 -0 的问题，我们创造了新的码叫补码，补码是直接在二进制的基础上进行改变，补码的定义：除最高位为负数位，其他位正常。

举个例子：

​		$10110_{2}$ = 0 * 2^0^ + 1 * 2^1^ + 1 * 2^2^ + 0 * 2^3^ + 1 * 2^4^

​		$10110_{补}$ = 0 * 2^0^ + 1 * 2^1^ + 1 * 2^2^ + 0 * 2^3^ + 1 * -2^4^

我们也可以从补码的定义看出一些性质：当补码最高位为1的时候一定为负数，否则为非负数。

假设现在有一个二进制是正数，那么原反补的符号位都为 0，因为其他位都没有改变，所以**正数的 原码 = 反码 = 补码**

假设现在有一个二进制是负数，原反补的符号位都为 1 ，我们已知 原码 = 反码符号位不变其他位取反，我们现在来讨论一下补码与他们的关系。

假设这是一个 5 位负数，$1ABCD_{原}$ = -(D * 2^0^ + C * 2^1^ + B * 2^2^ + A * 2^3^)首先我们能确定补码最高位一定为 1 ，也就是说补码现在是 $1EFGH$ =  (H * 2^0^ + G * 2^1^ + F * 2^2^ +E * 2^3^ - 2^4^)  =  -(D * 2^0^ + C * 2^1^ + B * 2^2^ + A * 2^3^) = (-D * 2^0^ - C * 2^1^ - B * 2^2^ -  A * 2^3^) ，这里需要用到我们二进制的一个性质了， 2^0^ + 2^1^ + 2^2^ + … + 2^k^ = 2^k+1^ - 1。

现在原式变成 (H * 2^0^ + G * 2^1^ + F * 2^2^ +E * 2^3^ - 2^0^ - 2^1^ - 2^2^ - 2^3^ - 2^0^) =  (-D * 2^0^ - C * 2^1^ - B * 2^2^ -  A * 2^3^)

(H + D - 1 - 1) * 2^0^ + (G + C - 1) * 2^1^ + (F - B - 1) * 2^2^ + (E - A - 1) * 2^3^ = 0

上述一组答案就是 H + D  = 2，G + C = 1，F + B = 1，E + A = 1。

所以我们很容易看出来，A 和 E 相反，B 和 F 相反，G 和 C相反，D = 2 - H。

也就是说当 D 为 1的时候 H 为 1，D 为 0 的时候 H 为 2，也就是进位，总体来说 H 是 D 的 相反 + 1。

那么最终来说，每一位都是相反最后一位需要 + 1，所以补码 = 反码 + 1

**最终补码解决了所有问题，所以我们选用补码为机器码**

### **总**结

**计算机做的运算都是以补码形式进行运算**

**正数 : 原码 = 反码 = 补码**

**负数 : 原码 ，反码 = 原码符号位不变其他位取反，补码 = 反码 + 1**

### 推导

通过以上分析我们就可以知道，**每一个类型的变量都是由一定的数据范围以及内存的**，我们可以通过每个变量类型的占用内存来算出他们的范围。

8个字节的：-2^63^ ~ 2^63^ - 1

4个字节的：-2^31^ ~ 2^31^ - 1

1个字节的:   -2^15^~2^15^ - 1

**注意：**做符号运算的时候最终结果的类型会选择字节数最高的那个，例如整形和长整型运算，最后答案的结果是长整型。

<div STYLE="page-break-after: always;"></div>

## 4.2ASCII

上面题到存储数据是使用二进制的，那么英文字母，奇奇怪怪的字符，中文都是怎么存的?

为了解决这个问题，人们发明了ASCII表，当我们使用字符的时候C语言自动发生翻译产生我们想要的东西。

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

### 4.3强制转换

我们在第2章说了当我们 左值的变量类型和右值的变量类型不同的时候，我们会把右边的变量类型变成左边的变量类型，做运算的时候会选择字节数较大的变量类型作为最终结果，那么假如我们就像要选择特定的变量类型该怎么办，这个时候就要用到我们的强制转换。

举例：

```
int a = 9000000000,b = 9000000000;
printf("%lld",a * b);
```

上述代码想要按照长整型输出最终答案，但是因为 a 是整形，b 也是整形，所以 a * b 最终结果也是 整形，我们想要按照长整型输出是不对的，所以我们需要把其中的 a 或者 b 转换成长整型，他们最终相乘的结果也是长整型，所以我们可以这么写：

```
int a = 9000000000,b = 9000000000;
printf("%lld",(long long)a * b); //写法1： (转换后的变量类型)变量名 
printf("%lld",long long(a) * b); //写法2： 转换后的变量类型(变量名) 
```

### **练习**：

1. C语言中运行的机器码是原码还是补码还是反码?

2. 以下哪个选项会溢出（）（多选）

   A. int a = 10000000000;		B.char a = 256	C.long long a = 1000000000

   D.long long a; int b = 10000000;int c = 1000000000; a = b * c;

   E.long long a; long long b = 10000000;int c = 1000000000; a = b * c;

   F.long long a; int b = 10000000;long long c = 1000000000; a = b * c;

3. $(123)_{10}$ = $(~~~~~~~~)_原$ = $(~~~~~~~~)_{反} $= $(~~~~~~~~)_{补}$

4. $(-17)_{10}$ = $(~~~~~~~~)_原$ = $(~~~~~~~~)_{反} $= $(~~~~~~~~)_{补}$

5. $(~~~~~~~~~)_{10}$ = $(101110)_原$ = $(~~~~~~~~)_{反} $= $(~~~~~~~~)_{补}$

6. $(~~~~~~~~~)_{10}$ = $(000110)_原$ = $(~~~~~~~~)_{反} $= $(~~~~~~~~)_{补}$

7. $(~~~~~~~~~)_{10}$ = $(~~~~~~~~~)_原$ = $(100110)_{反} $= $(~~~~~~~~)_{补}$

8. $(~~~~~~~~~)_{10}$ = $(~~~~~~~~~)_原$ = $(011000)_{反} $= $(~~~~~~~~)_{补}$

9. $(~~~~~~~~~)_{10}$ = $(~~~~~~~~~)_原$ = $(~~~~~~~~)_{反} $= $(111001)_{补}$

10. $(~~~~~~~~~)_{10}$ = $(~~~~~~~~~)_原$ = $(~~~~~~~~)_{反} $= $(011100)_{补}$

11. 10 % 3 = (  )，11 % 3 = (  ) ， 12 % 3 = （ ）， -5 % 3 = (  )，-10 % 4 = (  )， -100 % 13 = （ ）

    

12. 字符存储的形式是什么？是利用什么存储的？

    

13. 以下代码会输出什么？

    ```
    int a = 120;
    char b = (int)a; 
    printf("%d",(int)b); 
    ```

    ```
    int a = 1200;
    char b = (int)a;
    printf("%d",(int)b);
    ```

    ```
    int a = 65;
    printf("%c",a);
    ```

    ```
    char a = 'A';
    printf("%d",a);
    ```

<div STYLE="page-break-after: always;"></div>

# 5.字符串

字符串其实在前几章用的多，`""`引起来的叫做字符串，用`''`引起来的叫做字符，字符串是由任意个字符组成的，可以是0个也可以是100个。

大家最不好理解的其实是 **空字符串**：双引号里面什么都没有的就是空字符串 `""`，有些同学会认为`" "`加了空格的是空字符串，其实空格也算一个字符。

还要讲的就是我们的 `\n` 到底是什么，其实在我们计算机中去表示换行这类是很难得一件事情，所以我们就发明了转义字符，就是说在一个字符前加上`\`就能改变他的意思。

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

<div STYLE="page-break-after: always;"></div>

# 6.一维数组

## 6.1一维数组的定义

如果数据多了的话其实我们取名字是件很麻烦的事情，就像我们人类取名字就是件麻烦的事情，很多人会重名，倘若一个班中有两个孩子叫做小明，老师此时叫小明，两个小明都会回答，所以就会造成一些错乱。

在计算机中也是这样，我们无法声明两个相同名字的变量，倘若标识符相同，计算机就会导致错乱，在计算机中取名其实挺简单，比如字母和数字的组合，像a1，a2，a3…..这样就解决了起名问题，因为数字是无穷无尽的，不过假如说你现在需要100个整形变量，int a1，a2，a3，a4….. 这是一件很困难的事情，所以我们就发明了数组。

**一维数组的定义格式如下**：

变量类型 数组名[常量表达式]

说明：①数组名的明明规则与变量的命名规则一样

​			②常量表达式表示数组元素的个数，可以是常量和符号常量，但不能是变量

`[ ]` 这个符号代表数组，可以写成 `int a[10]`，念作声明了一个大小为 10 的数组，数组里的每个元素都是整形，其中a是这个数组的名字。

创建了 10 个整形元素，他们的名字分别为 `a[0]`，`a[1]`….`a[9]`，记住 `a[10]` 并没有被创建

## 6.2一维数组的引用

通过给出的数组名称和这个元素在数组中的位置编号(即下标)，程序可以引用这个数组中的任何一个元素

一维数组的引用格式： 数组名[下标] 。例如：

```
#include<stdio.h>

int a[10];
int main(){ 

	scanf("%d %d %d %d,&a[0],&a[1],&a[2],&a[3]);
	a[0] = 10;
	printf("%d %d %d %d",a[0],a[1],a[2],a[3]);
	return 0; //返回0
}
```

一维数组的特点：

1. 一维数组的内存是一起申请的，比如`int a[10]`，那么就是会向计算机申请 40 字节大小的内存。
2. 一维数组里面的元素是连续的，也就是类似于他们这么多元素申请了一栋房，分别住在各自的隔壁
3. 一维数组的下标从 0 开始
4. C语言只能逐个引用数组的元素，而不能一次性引用整个数组
   例如： int a[100]，b[100]。 a = b，这样子是错的。

## 6.3一维数组的初始化

初始化是一个C语言的编程术语，就是把变量赋为默认值，把控件设为默认状态，把没准备的准备好，也就是说我们创建数组的时候，数组里面每个元素的值我们并不知道，所以我们可以采用初始化将他们变为我们想要的一写值。

数组的初始化可以在定义时一并完成。格式：
		变量类型  数组名[常量表达式] = {值1，值2，….}
		例如：

​			int   a[5] = {1,2,3,4,5}； 这样写等价于 a[0] = 1，a[1] = 2，a[2] = 3，a[3] = 4，a[4] = 5；

说明：
				①在初值列表中可以写出全部数组元素的值，也可以写出部分。例如：以下方式也可以对数组进行初始化
					int   a[10] = {1,2,3,4,5};  这样写等价于 a[0] = 1，a[1] = 2，a[2] = 3，a[3] = 4，a[4] = 5，a[5] = 0，a[6] = 0…… a[9] = 0；
					也就是说我们也可以对一部分初始化，剩下的全都自动变为0
				②对数组元素全部初始化为0，可以简写为 { } 例如：
					int   a[10] = { }；

## 6.4数组越界

C语言规定，使用数组时，要注意：

①数组元素的下标值一定要为非负整数
		②在定义元素个数的下标范围内使用
		然而，在程序中把下标写成负数，大于数组元素个数的时候，程序是可以正常运行的
		例如：

``` 
int a[10];
a[-3] = 5;
a[20] = 15;
a[10] = 20;
int k = a[30]
```

虽然这些语句是合法的，但是他们访问的元素所在的内存，我们并没有申请，所以在使用的时候是不合法的，这种现象叫做数组越界。

### 练习：

1. 一个大小为100的整形数组 如果我们想要使用的话，以下哪个选项合法( ) （多选）

   A.a[0]			B.a[-1]			C.a[99]			D.a[100]

2. 想要给大小为3的整形数组中每个位置都输入一个数，以下哪个选项正确(  )

   A.scanf("%d %d %d",&a[0],&a[1],&a[2])

   B.scanf("%d %d %d",&a[1],&a[2],&a[3])

   C.scanf("%d %d %d",a[0],a[1],a[2])

   D.scanf("%d %d %d",a[1],a[2],a[3])

3.  char a[100]，float b[10000]，char c[1123] 分别怎么念

   


4. 想要把大小为3的整形数组中存的每个数都输出出来，以下哪个选项正确(  )

   A.printf("%d %d %d",&a[0],&a[1],&a[2])

   B.printf("%d %d %d",&a[1],&a[2],&a[3])

   C.printf("%d %d %d",a[0],a[1],a[2])

   D.printf("%d %d %d",a[1],a[2],a[3])
   
5. int a[10]数组里面的每个元素是什么？每个元素的属性是否一样？

6. 请用代码写出以下题目

   - 输入5个整数(不超过整形范围)，输出 第2个输入的，第3个输入的。
   - 输入5个整数(不超过整形范围)，将这5个整数按倒序输出出来

7. 请问以下操作是否合法

   ```
   int a[10];
   scanf("%d",&a[11]);
   ```

   ```
   int a[100];
   scanf("%d %d %d",&a[12],&a[12],&a[99]);
   ```

   ```
   int a[10];
   a[1] = 1;
   a[2] = 2;
   scanf("%d %d",&a[3],&a[2]);
   printf("%d %d",a[2],a[3]);
   ```

   ```
   float a[10];
   a[1] = 1;
   a[2] = 2;
   a[3] = a[4] = a[5] = 7;
   ```
   
   <div STYLE="page-break-after: always;"></div>

# 7.顺序结构

顺序结构的程序设计是最简单的，只要按照解决问题的顺序写出相应的语句就行，它的执行顺序是自上而下，依次执行。

**例1：**输入一个三位数，要求把这个数的百位数和个位数进行对调，输出对调后的数

【分析】先求出自然数的个位，十位，百位，然后将个位和百位对调

程序如下：

```
#include<stdio.h>
int main(){
	int m;
	cin >> m;
	int a = m / 100; //百位数
	int b = (m / 10) % 10; //十位数
	int c = (m % 10); //个位数
	int n = c * 100 + b * 10 + a; //重新组合对调后的数
	printf("%d",n);
}
```

运行结果：
		输入：10 20    输出：85.6667

**例2：**已知某班有男同学 x 位，女同学 y 位，x 位男生平均分是 87 分，y 位女生的平均分是 85，问全体同学平均分是多少分？

【分析】男女生的人数需要用户输入，然后根据题意 (x * 87 + y * 85 ) / (x + y) 求出全体同学的平均分。

程序如下：

```
#include<stdio.h>
int main(){
	int x,y;
	scanf("%d %d",&x,&y);
	printf("%.4f",1.0 * (x * 87 + y * 85) / (x + y));
}
```

运行结果：
		输入：10 20   输出：432

**例3：**歌手大奖赛上 6 名评委给一位参赛者打分，6个人打分的平均分为 9.6 分，如果去掉一个最高分，这名参赛者的平均分为 9.4 分；如果去掉一个最低分，这名参赛者的平均分为9.8分；如果去掉一个最高分和一个最低分，这名参赛者的平均分是多少？

【分析】首先求出 6 名评委的总分，然后根据去掉最高分的总分和最低分的总分，求出最高分的分值和最低分的分值，最后总分减去最高分和最低分除以4即是答案。

程序如下：

```
#include<stdio.h>
int main(){
	float sc_all = 6 * 9.6; //求6名评委的总分
	float sc_high = 5 * 9.4; //求去掉最高分后的总分
	float sc_low = 5 * 9.8; //求去掉最低分后的总分
	float high = sc_all - sc_high //求最高分
	float low = sc_all - sc_low； //求最低分
	float ans = (Sc_all - high - low) / 4; //求平均分
	printf("%5.2f\n",ans);
}
```

运行结果：9.60

<div STYLE="page-break-after: always;"></div>

# 8.程序的控制结构

## 8.1概述

程序由若干条语句组成，各语句按照顺序一条一条地执行，这种顺序结构是简洁的。但 在现实世界中，在解决问题的过程中，不可避免地遇到需要进行选择或需要循环工作的情 况。这时，程序执行的顺序需要发生变化，而非从前向后逐一执行。因此，程序中除了顺序 结构以外，通常还有选择结构、循环结构以及转移机制。

C+ +为了支持这些控制结构，提供了丰富、灵活的控制语句。从结构化程序设计的观 点看，所有程序都可用3种控制结构即顺序结构、选择结构和循环结构实现。C+ +在默认 的情况下采取顺序结构，除非特别指明，计算机总是按语句顺序一条一条地执行。为使程序 更清晰、更易调试与修改，并且不容易岀错，结构化编程要尽量少用或不用goto等跳转 语句。

选择类语句包括if语句和switch语句，用它们来解决实际应用中按不同的情况进行不 同处理的问题。如根据学生的成绩，对学生做出不同的等第评价。if选择结构称为单分支 选择结构，选择或忽略一个分支的操作。if-else选择结构称为双分支选择结构，在两个不同 分支中选择。switch选择结构称为多分支（或多项）选择结构，以多种不同的情况选择多个 不同的操作。

循环类语句包括for循环语句、while循环语句和do循环语句三种，用它们来解决实际 应用中需要重复处理的问题。如当统计全班同学总分时，就需要重复地做加法，依次把每个 人的分数累加起来。

if、else、switch、while、do和for等都是C+ +关键字。这些关键字是该语言保留的，用 于实现C+ +控制结构的不同特性。关键字不能作为变量名等一些标识符。注意，将关键 字while的拼写变为“While”是个语法错误，因为C+ +是区分大小写的语言。while、if和 else等所有C+ +保留关键字只能包含小写字母。

<div STYLE="page-break-after: always;"></div>

## 8.2 if选择结构

C语言提供三种选择结构，即 if 选择结构、if-else 选择结构 和 switch 选择结构。

### if语句(单分支机构)

**格式 1：**

```
if (条件表达式) 
	语句1;
```

**功能：**如果条件表达式的值为真，则条件成立，语句 1 会被执行。否则，语句 1 就会被忽略，程序将按照顺序从整个选择结构之后的下一条语句继续执行。

**说明：**格式中的 ”条件表达式“ 必须用圆括号括起来

**例1：**读入一个整数 a ，如果 a 为偶数在屏幕上输出 yes。

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	if(a % 2 == 0) printf("yes");
	return 0;
}
```

**注意：**关系运算符 == 用来表示该符号的左右两边是否相等，不要写成赋值号 = 。

若题目改成 读入一个整数 a ，若 a 为奇数在屏幕上输出 no 该怎么写？

**例2：**读入一个整数，若这个数大于 1 并且小于 100 ，则输出 yes 。

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	if((a > 1) && (a < 100)) printf("yes");
	return 0;
}
```

**注意：**此程序的条件表达式为 (a > 1) && (a < 100)，根据要求 "条件表达式" 必须用圆括号括起来，否则运行会出错。

**格式2：**

```
if(条件表达式){
	语句1;
	语句2;
	...
}
```

若条件成立时，要执行的操作由多个句子构成，我们必须把这些句子括在一对花括号{ }内，我们称这种形式为语句块或复合语句。

**例3：**输入三个整数，按从大到小的顺序输出。

【分析】输入的三个整数放在 a、b、c 中， 设想让 a 为三数中最大数，怎么办呢？如果 a < b，那么让 a 和 b 的值交换，保证 a >= b; 如果a < c，那么让 a 和 c 的值交换，就保证了 a >= c; 设想让 b 为第二大的数，c 为第三大的数，怎么做呢？如果 b < c，那么让 b 和 c 的值交换，就保证 b >= c，最后输出 a，b，c的值。程序如下：

```
#include<stdio.h>
int main(){
	int a,b,c,temp;
	scanf("%d %d %d",&a,&b,&c);
	if(a < b){
		temp = a;
		a = b;
		b = temp;
	}
	if(a < c){
		temp = a;
		a = c;
		c = temp;
	}
	if(b < c){
		temp = b;
		b = c;
		c = temp;
	}
	printf("%d %d %d",a,b,c);
}
```

### if-else语句(双分支结构)

if 单分支选择结构只在条件为 true 时采取操作，条件 false 时则忽略这个操作。利用 if-else 双分支选择结构则可以在条件为 true 时和条件为 false 时采取不同操作。

**格式1：**

```
if(条件表达式)
	语句1;
else 
	语句2;
```

功能：如果(条件表达式)的值为 “真”，即条件成立，则执行语句 1，执行完语句 1 后继续执行整个 if-else 语句的后继语句。如果(条件表达式)的值为 “假”，即条件不成立，那么跳过语句 1 选择执行 语句 2，执行完语句 2 后继续执行整个 if-else 语句的后继语句。也就是说 if-else 语句总是根据(条件表达式)的结果，选择 语句 1 和 语句 2 中的一个执行，执行完以后，整个 if-else 就算执行完了。

程序设计风格提示：书写 if-else 语句时，if 和 else 要对齐，而分支的语句要缩进两格。

**例4：**输入温度 t 的值，判断是否适合晨练。(25 <= t <= 30)，适合晨练输出 ok，否则输出 no

代码如下：

```
#include<stdio.h>
int main(){
	int t;
	scanf("%d",&t);
	if((t >= 25) && (t <= 30))
		printf("ok");
	else 
		printf("no");
}
```

**格式2：**

```
if(条件表达式){
	语句1;
	语句2;
	...
}else{
	语句1;
	语句2;
	...
}
```

若分支语句由多个句子构成，我们必须把这些句子括在一对花括号 {  }内。

**例5：**乘坐飞机时，当乘客行李小于等于 20 公斤时，按每公斤 1.68 元收费，大于 20 公斤时，桉每公斤 1.98 元收费，编程计算收费(保留两位小数)。

代码如下：

```
#include<stdio.h>
int main(){
	float w,s;
	scanf("%f",&w);
	if(w <= 20){
		s = w * 1.68;
		printf("%.2f\n",s);
	}else{
		s = w * 1.98;
		printf("%.2f\n",s);
	}
	return 0;
}
```

if 语句允许嵌套，即语句 1 和 语句 2 还可以时 if 语句，当 if 语句嵌套时，约定 else 总是和最近一个 if语句配对。

**例6：** 

```
if(a > b)
	if(b > c) y = a;
		else y = c;
```

else 部分否定的是条件 b > c，即它与第二个 if 语句配对; 若想要让 else 语句与第一个 if 语句配对，则要引入一个复合语句，将上述语句写成如下形式：

```
if(a > b){
	if(b > c) y = a;
}else y = c;
```

**例7：**输入三个整数，输出其中最大的数。

【方法1】设 maxn 用于存放三个数中最大的数，输入的三个数存放在 a，b，c 中，那么如果 a 比 b 和 c 大，则最大数是 a，否则，如果 b 比 a 和 c 大，则最大数是 b，否则，最大数是 c。

代码如下：

```
#include<stdio.h>
int main(){
	float a,b,c,maxn;
	scanf("%f %f %f",&a,&b,&c);
	if(a > b && a > c) maxn = a;
	else if(b > a && b > c) maxn = b;
	else maxn = c;
	printf("%f",maxn);
}
```

【方法2】设 maxn 用于存放三个数中最大的数，输入的三个数存放在 a、b、c 中，初值 maxn = a，即假设 a 为最大，那么如果 b > maxn，则此时的最大数应该是 b 即 maxn = b，如果 c > maxn，则最大数应该是 c ，即 maxn = c。

代码如下：

```
#include<stdio.h>
int main(){
	float a,b,c,maxn;
	scanf("%f %f %f",&a,&b,&c);
	if(b > maxn) maxn = b;
	if(c > maxn) maxn = c;
	printf("%f",maxn);
}
```

### if-else if语句

if-else 语句是很绝对的，只有两种情况，但是我们对于 if-else if 我们可以书写多种情况

**格式1：**

```
if(条件表达式1)
	语句1;
else if(条件表达式2)
	语句2;
else if(条件表达式3)
	语句3;
	.....
```

【功能】如果(条件表达式 1 )的值为 “真”，即条件成立，则执行语句 1，执行完语句 1 后继续执行整个 if-else if 语句的后继语句。如果(条件表达式)的值为 “假”，即条件不成立，那么跳过语句 1 选择判断 (条件表达式 2 )，如果为 "真" ，则条件成立，则执行语句 2 ，执行完语句 2 后继续执行整个 if-else if 语句的后继语句。如果(条件表达式2)为假，那么就会跳过语句 2，去执行(条件表达式 3 ) ，如果为真则执行语句 3 ……，也就是说 if-else  if语句会先按照条件表达式的先后顺序来一直判断是否为真，一旦确定一个条件表达式为真则执行对应的语句，后续的不再进行。

**例子8：**输入一个整数 a，假设 a 整除 6 输出 yes，假设 a 整除 3 但不整除 2 则输出 no，假设 a 整除 2 但不整除 3 则输出 all right。

【分析】整除就是余数为 0 ，你不能以商来判断

代码如下：

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	if(a % 6 == 0)
		printf("yes");
	else if((a % 3 == 0) && (a % 2 != 0))
		printf("no");
	else if((a % 2 == 0) && (a % 3 != 0))
		printf("all right");
}
```

**格式2：**

```
if(条件表达式1){
	语句1;
	语句2;
	....
}else if(条件表达式2){
	语句3;
	语句4;
	....
}else if(条件表达式3){
	语句5;
	语句6;
	....
}
	.....
```

若分支语句由多个句子构成，我们必须把这些句子括在一对花括号 {  }内。

**例9：**输入一个整数 a，假设 a 整除 6 输出 yes 和 a / 6，假设 a 整除 3 但不整除 2 则输出 no 和 a / 3，假设 a 整除 2 但不整除 3 则输出 all right 和 a / 2。

【分析】整除就是余数为 0 ，你不能以商来判断

代码如下：

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	if(a % 6 == 0){
		printf("yes\n");
		printf("%d",a / 6);
	}else if((a % 3 == 0) && (a % 2 != 0)){
		printf("no\n");
		printf("%d",a / 3);
	}else if((a % 2 == 0) && (a % 3 != 0)){
		printf("all right\n");
		printf("%d",a / 2);
	}
}
```

### if-else if-else

**格式1：**

```
if(条件表达式1)
	语句1
else if(条件表达式2)
	语句2
	....
else
	语句3
```

【功能】先判断条件语句1，假设为”真“则运行语句 1，接着继续执行整个 if-else if-else 的后继语句，否则运行条件表达 3，如果为”真“则运行语句 2 ，接着继续执行整个 if-else if-else 的后继语句….如果前面的条件表达式都不符合则运行语句 3，也就是说 if-else if-else 一定有一个语句会被运行，但是 if-else if 不一定。

**例子10：**输入一个整数 a，假设 a 整除 6 输出 yes，假设 a 整除 3 但不整除 2 则输出 no，假设 a 整除 2 但不整除 3 则输出 all right，否则输出 ok。

【分析】整除就是余数为 0 ，你不能以商来判断

代码如下：

```
#include<stdio.h>
int main(){
	int a;
	scanf("%d",&a);
	if(a % 6 == 0)
		printf("yes");
	else if((a % 3 == 0) && (a % 2 != 0))
		printf("no");
	else if((a % 2 == 0) && (a % 3 != 0))
		printf("all right")
	else 
		printf("ok");
}
```

**格式2:**

```
if(条件表达式1){
	语句1
	语句2
	....
}else if(条件表达式2){
	语句3
	语句4
	....
}
....
else{
	语句5
	语句6
	....
}
```

### 练习

1. 下面的运算是真是假？

   1. 正整数 >= 负数
   2. 整数 >= 负数
   3. 1 >= 2
   4. 2 >= 2
   5. -2 >= -1
   6. -2 < -1
   7. 1 == 2
   8. 1 != 2
   9.  2 > 1 > 1
   10.  10 < 1 < 1
   11.  10 != 2 != 1
   12.  10 != 2 != 0
   13.  2 >= 1 >= 1
   14.  5 > 1 > 2 > 1 > 1 != 0
   15.  2 == 1 == 2 == 3 == 0
   
2. 下面的这个分支有可能输出什么

   ```
   if(a >= 100){
   	printf("我是大聪明");
   }else if(a >= 110){
   	printf("我是小聪明");
   }else if(a >= 80){
   	printf("小聪明是我");
   }else{
   	printf("大聪明是我");
   }
   ```

4. 请用代码形式写出 ：输入一个整数，若是奇数则输出YES，否则就输出NO

   

5. 请用代码形式写出 : 输入一个整数，若这个数能够整除 3就输出 aaa，不然如果能整除 2 就输出 cccc，否则输出 dddd

   

6. 请用代码形式写出 ：输入一个整数，若这个数能够整除3并且能够整除2就输出aaa，否则不输出

   

   

7. 以下代码合法吗？若合法会产生什么结果？

   ```
   int a = 1;
   if(a >= 1) printf("%d",1);
   else printf("%d",2);
   ```

   ```
   int a = 2,b = 1,c = 1; 
   if(a > b > c) 
   	printf("aaa"); 
   ```

   ```
   int a = 1;
   if(a >= 1); 
   else;printf("%d",1);
   ```

   ```
   int a = 1;
   if(a >= 1); printf("%d",2);
   else;printf("%d",1);
   ```

   ```
   int a = 1,b = 2;
   if(a != 1) printf("%d",b);
   else printf("%d",a);
   ```

   ```
   int a = 1,b = 2;
   if(a != 1) printf("%d",b);
   else if(a != 2) printf("%d",b);
   else printf("%d",a);
   ```

   ```
   int a = 1,b = 2;
   if(a != 1){
   	printf("YES");
   	printf("%d",b);
   }else if(b != 2){
   	printf("%d",b);
   }else{
   	printf("NO");
   }
   ```

   ```
   int a = 105;
   if(a % 3 == 0){
   	if(a % 3 == 0){
   		printf("YES\n");
   	}else if(a % 5 == 0){
   		printf("NO\n");
   	}else{
   		printf("AAA\n");
   	}
   	if(a % 5 == 0){
   		printf("YES\n");
   	}else if(a % 7 == 0){
   		printf("NO\n");
   	}else{
   		printf("III\n");
   	}
   	if(a % 5 == 0){
   		if(a % 7 == 0){
   			printf("YES\n");
   		}else{
   			printf("NO\n");
   		}
   	}
   }
   ```

   ```{
   if(1 > 2 > 0){
   	printf("YES\n");
   }else if(2 > 1 > 3 > 0){
   	printf("NO\n");
   }else if(2 < 1 < 3 != 0){
   	printf("AAAA\n");
   }else{
   	printf("DDDD\n");
   }
   ```

   ```
   if(1 > 2 > 0){
   	printf("YES");
   }else{
   	printf("Asdsa");
   }else{
   	printf("asddd");
   }
   ```

   ```
   int a = 1;
   if(13){
   	int a = 2;
   	printf("%d",a);
   }
   ```

   ```
   int a = 1;
   {
   	int a = 3;
   	printf("%d",a);
   }
   ```

8. 对于以下代码请分析每一句话是什么意思，如果有运算请写出先运算什么，用什么结果进行下一步运算
   例如 1 > 2 > 3 先运算 1 > 2，再运算(1 > 2的结果) > 3

   ```
   if(a != 1 > 2){
   	printf("%d",2);
   }else if(a != 1 < 2){
   	printf("%c",65);
   }else{
   	printf("DDD!");
   }
   ```

   ```
   if(a * 2){
   	printf("YES\n");
   	if(a / 2) printf("YES2\n");
   	else if(a % 2) printf("YES3\n");
   }else if(a % 2 == 0){
   	printf("YES3\n");
   	if(a % 3 == 0){
   		printf("YES4\n");
   	}
   	if(a % 4 == 0){
   		printf("YES5\n");
   	}
   }
   ```

9. 请问以下代码是否一定输出YES

   ```
   已知 a % 4 == 0
   if(a % 2 == 0){
   	printf("YES");
   }
   ```

   ```
   已知 a > 1 <= 2 为真
   if(a > 1){
   	printf("YES");
   }
   ```

   ```
   已知a > 1 <= 0 为真
   if(a > 1);
   else{
   	printf("YES");
   }
   ```

   ```
   已知 1 > ((2 > a) > 3) 为真
   if(a < 2){
   	printf("YES");
   }
   ```

10. 请以代码形式写出以下描述（写出最简答案）

    ```
    如果整形a能够整除3并且整形a能够整除5则输出YES
    否则如果整形a能够整除3则输出NO
    否则输出DDDD
    ```

    ```
    如果整形a能够整除3并且能够整除5并且能够整除7并且能够整除11并且能够整除13并且能够整除39则输出YES
    ```

    <div STYLE="page-break-after: always;"></div>

## 8.3 switch语句

应用条件语句可以很方便地使程序实现分支，但是出现分支比较多的时候，虽然可以用嵌套的 if 语句来解决，但是程序结构会显得复杂，其至凌乱。为方便实现多情况选择，C语言提供了一种 switch 开关语句

**1.语句格式**

```
switch(表达式){
	case 常量表达式1:
		语句序列1;
		break;
	case 常量表达式2:
		语句序列2;
		break;
		....
	case 常量表达式n:
		语句表达式n;
		break;
	default:
		语句表达式n + 1;
}
```

该语句可以使用一次或多次 case 标号，但只能使用一次 default 标号，或者省略整个 default 部分;多个 case 标号也允许使用在同一个和语句序列的前面;每个语句标号由保留字 case 和后面的常量表达式及冒号组成，每个常量表达式通常为字面常量，如常数或字符。

**2.语句执行过程**

switch 语句执行过程分为以下 3 步描述。

①计算出 switch 后面圆括号内表达式的值，假定为 M，若它不是整形，系统将自动舍去其小数部分，只取其整数部分作为结果值。

②依次计算出每个 case 后常量表达式的值，假定它们为 M1、M2、…，同样，若它们的值不是整形，则自动转换为整形。

③让 M 依次同 M1 、M2、… 进行比较，一旦遇到 M 与某个值相等，则就从对应标号的语句开始执行; 在碰不到相等的情况下，若存在 default 子句，则就执行其冒号后面的语句序列，否则不执行任何操作; 当执行到复合语句最后的花括号时就结束整个 switch 语句的执行。

在实际使用 switch 语句时，通常要求当执行完某个 case 后的一组语句序列后，就结束整个语句的执行，而不让它继续执行下一个 case 语句后面的语句序列，为此，可通过使用 break 语句（结束语句）来实现。该语句只有保留字 break，而没有其他任何成分。它时一条跳转语句，在 switch 中执行到它时，将结束该 switch 语句，系统接着向下执行其他语句。

在使用 switch 语句时，还应注意以下几点：

① case 语句后的各常量表达式的值不能相同，否则会出现错误码

②每个 case 或 default 后，可以包含多条语句，不需要使用 "{" 和 "}"括起来。

③各 case 字句的先后顺序可以变动，这不会影响程序执行结果。

④default 字句可以省略，default 后面的语句末尾可以不必写 break。

程序设计风格提示：写 switch 语句时，switch (表达式) 单独一行，各 case 分支和 default 分支要缩进两格并对齐，分支处理语句要相对再缩进两格，以体现不同层次的结构。

**3.语句格式举例**

(1) 左右两边的书写格式是等价的

```
switch(a){                                   switch(a){
	case 1: x++; break;							case 1:
	case 2: y++; break;								x++; break;
	case 3: z++; break;							case 2:
	default: printf("Error");						y++; break;
}												case 3:
													z++; break;
												default:
													printf("Error");
												}
```

(2) 

```
switch(ch){
	case 'a':
	case 'A':
		d1 = (x + y) / 2;
		d2 = x * y - 2;
		break;
	case 'b':
	case 'B':
		d1 = (a + b) / 2;
		d2 = a * b - 2;
		break;
	default:
		printf("input error!");
}
```

【说明】1.每个 case 后面的语句可以写在冒号后的同一行或换到新行写。

​			2.<语句序列1> … <语句序列 n + 1> 都时一组语句，有时可为空。如 (2)。

**例1：**根据从键盘上输入的表示星期几的数字，对应输出它的英文名字。

```
#include<stdio.h>
int main(){
	int weekday;
	scanf("%d",&weekday);
	switch(weekday){
		case 1: printf("Monday\n"); break;
		case 2: printf("Tuesday\n"); break;
		case 3: printf("Wednesday\n"); break;
		case 4: printf("Thursday\n"); break;
		case 5: printf("Friday\n"); break;
		case 6: printf("Saturday\n"); break;
		case 7: printf("Sunday\n"); break;
		default：printf("input error\n");
	}
}
```

**例2：** 一个最简单的计算器支持四种运算。输入只有一行：两个参加运 算的数和一个操作符(+, —，*,/)。输出运算表达式的结果。考虑下面两种情况：

(1) 如果出现除数为0的情况，则输出:Divided by zero!

(2) 如果出现无效的操作符(即不为, * ,/之一)，则输出：Invalid operator! 输入样例：

34 56 + 

输出样例：

90

【分析】设 num1、num2 存放两个参加运算的操作数，op存放操作符。

① 当op为" + ”号时，实现加法操作。

② 当op为“一”号时，实现减法操作。

③ 当op为“ * ”号时，实现乘法操作。

④ 当op为“/”号时，判断b值，如果不为0,则实现除法操作，如果为0,则输岀:Divided by zero!

⑤ 当op不是上面四种操作符时，输出：”Invalid operator！“

程序如下：

```
#include<stdio.h>
int main(){
	float num1,num2;
	char op;
	scanf("%f %f %c",&num1,&num2,&op);
	switch(op){
		case '+': printf("%f",num1 + num2); break;
		case '-': printf("%f",num1 - num2); break;
		case '*': printf("%f",num1 * num2); break;
		case '/': 
			if(num2 != 0) printf("%f",num1 / num2); break;
			else printf("Divided by zero"); break;
		default: printf("Invalid operator!");
	}
	return 0;
}
```

**例3：**期末来临了，班长小 Q 决定将剩余班费 x 元钱，用于购买若干支钢笔奖励给 一些学习好、表现好的同学。已知商店里有三种钢笔，它们的单价分别为 6元、5 元和4 元。 小 Q 想买尽量多的笔（鼓励尽量多的同学），同时他又不想有剩余钱。请你编一程序，帮小 Q 制订岀一种买笔的方案。

【分析】 对于以上的实际问题，要买尽量多的笔，易知都买4元的笔肯定可以买最多 支笔。因此最多可买的笔为 x / 4 支。由于小 Q 要把钱用完，故我们可以按以下方法将钱 用完：若买完 x / 4 支 4 元钱的笔，还剩 1 元，则 4 元钱的笔少买 1 支，换成一支 5 元笔即可； 若买完 x / 4 支 4 元钱的笔，还剩 2 元，则 4 元钱的笔少买 1 支.换成一支 6 元笔即可；若买 完 x / 4 支 4 元钱的笔，还剩 3 元，则 4 元钱的笔少买 2 支，换成一支 5 元笔和一支 6 元笔 即可。

从以上对买笔方案的调整，可以看出笔的数目都是 x / 4 ,因此该方案的确为最优方案。

程序如下：

```
#include<stdio.h>
int main(){
	int a,b,c,x,y;
	scanf("%d",&x);
	c = x / 4;
	y = x % 4;
	switch(y){
		case 0: a = 0; b = 0; break;
		case 1: a = 0; b = 1; c--; break;
		case 2: a = 1; b = 0; c--; break;
		case 3: a = 1; b = 1; c -= 2; break;
	}
	printf("%d %d %d",a,b,c);
}
```

### 练习：

**1.** 晶晶赴约会

晶晶的朋友贝贝约晶晶下周一起去看展览，但晶晶每周的 1、3、5 有课必须上课，请帮晶 晶判断她能否接受贝贝的邀请，如果能输出 YES ；如果不能则输出N0注意 YES 和 NO 都是大写字母！

**2.** 骑车与走路

在清华校园里.没有自行车，上课办事会很不方便。但实际上。并非去办任何事情都是 骑车快，因为骑车总要找车、开锁、停车、锁车等，这要耽误一些时间。假设找到自行车，开锁 并车上自行车的时间为 27 秒；停车锁车的时间为 23 秒；步行每秒行走 1. 2 米，骑车每秒行走 3.0 米。请判断走不同的距离去办事，是骑车快还是走路快。如果骑车快，输出一行 “Bike”；如果走路快，输出一行 “Walk”；如果一样快，输出一行 “All”。

**3.** 分段函数

编写程序，计算下列分段函数y=f(x)的值。结果保留到小数点后三位。

y = -x + 2.5；	0 <= x < 5

y = 2 -1. 5(x-3)(x-3) ；	5 <= x < 10

y = x / 2 - 4.5; 			10 <= x < 20

**4.** 计算邮资

根据邮件的重量和用户是否选择加急计算邮费。计算规则：重量在 1000 克以内(包括 1000 克)，基本费 8 元。超过 1000 克的部分，每 500 克加收超重费 4元，不足 500 克部分按 500 克计算；如果用户选择加急，多收 5 元。

**5.** 最大数输岀

输入三个整数•数与数之间以一个空格分开。输出一个整数，即最大的整数。

**6.** 三角形判断

给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。如 果能构成三角形，则输出“yes”，否则输出“no” °

**7.** 判断闰年

判断某年是否是闰年。如果公元a年是闰年输出Y,否则输岀N。

**8.** 点和正方形的关系

有一个正方形，四个角的坐标 (x,y) 分别是 (1, -1), (1,1) , ( -1,-1) , ( -1,1), x 是横轴，y 是纵轴。写一个程序，判断一个给定的点是否在这个正方形内(包括正方形边界)。如 果点在正方形内，则输出yes,否则输出no。

**9.** 简单计算器

一个最简单的计算器，支持+，一，*，/四种运算。仅需考虑输入输出为整数的情况， 数据和运算结果不会超过int表示的范围。然而：

1. 如果出现除数为0的情况，则输出:Divided by zero!
2. 如果出现无效的操作符(即不为 +、-、*、/，之一)，则输出Invalid operator!

## 8.4三目运算符

C语言有一个常用来代替if-else语句的操作符，这个操作符被称为三目运算符( ？：)，它 是C语言中唯一一个需要3个操作数的操作符。该操作符的通用格式如下：

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {
	int a = 10;
	int b = 20;
	int c = 0;
	c = a > b ? a : b;
	cout << "c = " << c << endl;
	//C++中三目运算符返回的是变量,可以继续赋值
	(a > b ? a : b) = 100;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰

<div STYLE="page-break-after: always;"></div>

# 9.循环结构

第四章循环结构

前面我们学习了顺序结构与分支结构的程序设计。在实际应用中，会经常遇到许多有 规律性的重复运算，这就需要掌握循环结构程序设计。C++语言提供三种循环结构for、 while 和 do一while。

## 9.1for循环

### 语句格式

**格式1：**

```
for （控制变量初始化表达式；条件表达式；增量表达式） 语句1;
```

【说明】语句1是for循环语句的循环体，它将在满足条件的情况下被重复执行。 

**格式2：**

```
for （控制变量初始化表达式；条件表达式；增量表达式{
	语句1;
	语句2;
	...
}
```

【说明】循环体部分由多个语句构成，应由一对花括号括起来，构成一个语句块的形式。 程序风格提示：写for循环语句时，循环体的语句相对于for缩进两格。

### 语句执行过程

for语句的执行过程可由以下4步来描述。

（1）	执行“控制变量初始化语句”，使控制变量获得一个初值。

（2）	判断控制变量是否满足“条件表达式”，若满足条件则执行一遍循环体，否则结束整 个for语句，继续执行for循环下面的句子。

（3）	根据增量表达式，计算出控制变量所得到的新值。

（4）	自动转到第（2）步。

大家可以使用以下方法记住这几个语句：

控制变量初始化表达式：相当于运动会的开幕式，开幕式只开一次，且在最开始的时候开。

条件表达式：判断运动会有没有下雨，每天都要判断，且在最开始的时候判断，如果下雨就停止运动会，否则继续。

增量表达式：运动会结束后的扫垃圾行为，每天都要扫，且在运动会项目全部结束后。

花括号中的语句：运动会的项目，每天都会有项目进行。

### 语句格式举例

- 将控制变量从1变到100,增量为1

```
for(i= 1; i < = 100; i ++)
```

- 将控制变量从100变到1,增量为一1

```
for(i= 100; i > = 1; i–-)
```

- 控制变量从7变到77,增量为7

```
for(i = 7; i <= 77; i += 7)
```

- 控制变量从20变到2,增量为一2

```
for(int i = 20; i >= 2; i -= 2)
```

- 按所示数列改变控制变量值：99、88、77、66、55、44、33、22、11、0,

```
for(int i = 99; i >= 0; i -= 11)
```

- 控制变量i和j共同进行循环控制，i从1变到99,j从2变到100,增量均为2

```
for(int i = 1,j = 2; i <= 99 && j <= 100; i += 2,j += 2)
```

**需要说明的是：**可以在for循环“控制变量初始化语句”中声明变量(如上面最后3个例子)，这些变量只在for循环结构中有效，离开了该for结构，变量就无效了

### 示例程序

**例1：**利用for循环，计算输出1 + 2 + … + 100的和。

```
#include<stdio.h>
int main(){
	int sum = 0;
	for(int i = 1; i <= sum; i++){
		sum += i;
	}
	printf("%d",sum);
	return 0;
}
```

**例2：**输出 1 ~ 100 之间所有偶数。

```
#include<stdio.h>
int main(){
	int sum = 0;
	for(int i = 2; i <= 100; i += 2){
		sum += i;
	}
	printf("%d",sum);
	return 0;
}
```

**例3：**利用for循环，分别计算 1 ~ 100 中奇数的和、偶数的和。

【方法1】：根据例2的方法很容易找到所有的偶数和奇数，继而计算其和。假设用变量 sum1 和 sum2 分别存放偶数与奇数和，累加就是在 sum1 或 sum2 的基础上，加上一个数字，改变累加变量的值；再加上一个数字，改变累加变量的值；……；如此重复下去

```
#include<stdio.h>
int main(){
	int sum1 = 0,sum2 = 0;
	for(int i = 2; i <= 100; i += 2){
		sum1 += i;
	}
	for(int i = 1; i <= 100; i += 2){
		sum2 += i;
	}
	printf("%d %d",sum1,sum2);
	return 0;
}
```

【方法2】：偶数从 2 开始每次递增 2 ,奇数从 1 开始每次递增 2 ,for语句的循环变量初始化和循环变量增量两部分都可以使用逗号语句序列。

```
#include<stdio.h>
int main(){
	int sum1 = 0,sum2 = 0;
	for(int i = 2,j = 1; i <= 100; i += 2,j += 2){
		sum1 += i;
		sum2 += j;
	}
	printf("%d %d",sum1,sum2);
	return 0;
}
```

**例4：**利用 for 循环计算 n! 的值。 (n! = 1 * 2 * 3 * … * n)

```
#include<stdio.h>
int main(){
	int sum = 1;
	for(int i = 1; i <= n; i++){
		sum *= i;
	}
	printf("%d",sum);
	return 0;
}
```

### 错误展示

【说明】错误的使用 逗号运算符 去当做逻辑运算符

```
#include<stdio.h>
int main(){
	for(int i = 1,j = 2; i <= 5,j <= 7; i++,j++){ //由于逗号运算符会把最后一个表达式当做语句结果，所以第二个语句相当于在写 j <= 7
	}
	return 0;
}
```

## 9.2while循环

### 语句格式

**格式1：**

```
while (条件表达式) 语句1;
```

【说明】语句 1 是while循环语句的循环体，它将在满足条件的情况下被重复执行。

 **格式2:**

```
while (条件表达式){
	语句1;
	语句2;
	....
}
```

【说明】循环体部分由多个语句构成，应由一对花括号括起来，构成一个语句块的形式。 程序风格提示：写while循环语句时，循环体的语句相对于while缩进两格。

 

### 语句执行过程

(1) 计算作为循环控制条件表达式的值，得到逻辑真或假，假定用 M 表示。

(2) 若 M 为真，则执行了一遍循环体，否则离开循环，结束整个while语句的执行。

(3) 循环体的所有语句执行结束后，自动转向第(1)步执行。

### 格式举例

(1) 

```
int i = 1;
while(i <= 10){
	i++;
}
```

【功能】当 i 的值小于 10 ,重复执行 i++ 语句

(2)

```
while(scanf("%d",&x),x < 0){ 
	
}
//相当于
scanf("%d",&x);
while(x < 0){
	scanf("%d",&x);
}
```

**功能：**当输入的数据小于 0 时，重复读数据。

**注:** while的括号中可以包含多个语句(中间用逗号隔开)，但是只判读最后一个语句 是否为真，如：

```
while (x>10,x == 10,x < 10) 
```

如果 x < 10，则继续执行循环，否则退出循环

**例1：**求s = 1 + 2 + 3 + …. + ,当加到第几项时，s的值会超过1000?

```
#include<stdio.h>
int main(){
	int s = 0,i = 1;
	while(s <= 1000){
		s += i;
		i++;
	}
	printf("%d",i);
}
```

**例2：**求两个正整数 m、n 的最大公约数。

【分析】：求任意两个自然数 m 和 n 的最大公约数，可以想到其最大的可能就是两个数 中的较小者 min ,最小可能是 1 。所以，可以设最大公约数 gcd 从min 开始进行判断，若 gcd > 1 并且没有同时整除 m 和 n ,那么就 gcd - 1 ,重复判断是否整除。

```
#include<stdio.h>
int main(){
	int n,m,gcd;
	scanf("%d %d",&m,&n);
	if(m > n) gcd = n;
	else gcd = m;
	while(gcd > 1 && (m % gcd != 0 || n % gcd != 0)){
		gcd--;
	}
	printf("%d\n",gcd);
	return 0;
}
```

**例3**： 编一程序求满足不等式 1 + 1 / 2 + 1 / 3 + … + 1 / n >= 5的最小 n 值。

【分析】此题不等式的左边是一个求和的算式，该和式中的数据项个数是未知的，也正是要求出的。对于和式中的每个数据项，对应的通式为 1 / i，i = 1,2,3…n。所以可釆用循环累加的方法来计算出它的值。设循环变量为 i ,它应从 1 开始取值，每次增加 1 ,直到和式的值不小于 5 为止，此时的 i 值就是所求的 $n_0$ 设累加变量为 s ,在循环体内把 1/ i 的值累加到 s 上。

根据以上分析，采用while循环编写出程序如下：

```
#include<stdio.h>
int main(){
	int i = 0;
	float s = 0;
	while(s < 5){
		++i;
		s += 1.0 / i;
	}
	printf("%d",i);
	return 0;
}
```

若采用for循环来写，则如下所示：

```
#include<stdio.h>
int main(){
	int i;
	float s = 0;
	for(i = 1; i < s; i++){
		s += 1.0 / i;
	}
	printf("%d",i);
	return 0;
}
```

## 9.3do-while循环

### 格式语句

**格式1：**

```
do 
	语句1;
while(条件表达式);
```

【说明】语句 1 是do—while的循环体，条件表达式是继续执行下去的条件。

 **格式2：**

```
do {
	语句1;
	语句2;
	....
}while(条件表达式);
```

### 语句执行过程

（1）	执行一遍循环体。

（2）	求出作为循环条件的“条件表达式”的值，若为逻辑值真，则自动转向第（1）步，否则 结束 do 循环的执行过程，继续执行其后面的语句。

在 do 语句的循环体中也可以使用 break 语句，用它来非正常结束循环的执行。

也就是说不管怎么样，do-while 都会至少执行一遍循环体里面的语句。

### 示例程序

**例1：**求10个1111的乘积的末两位数是多少？

【分析】倘若我们直接去乘会超出长整型的限制，但是积的个位与十位数只与被乘数和乘数的个位与十位数字有关，所以本题相当 于求 10个 11 相乘，而且本次的乘积是下一次相乘的被乘数，因此也只需取末两位参与运算就可以了。

```
#include<stdio.h>
int main(){
	int a = 1,t = 0;
	do{
		++t;
		a = (a * 11);
	}while(t != 11);
	printf("%d",a);
}
```

**例2：**校体操队到操场集合，排成每行 2 人，最后多出 1 人；排成每行 3 人，也多出 1 人；分别按每行排 4、5、6 人，都多出 1 人；当排成每行 7 人时，正好不多。求校体操队至少多少人？

【分析】 

①设校体操队为 x 人，根据题意 x 应是 7 的倍数，因此 x 的初值为 7 ,以后用 x + = 7 改变 x 值；

② 为了控制循环，用逻辑变量 yes 为真 (true) 使循环结束；

如果诸条件中有一个不满足，yes 的值就会为假 (false) ,就继续循环

```
# include<stdio.h>
int main(){
	int x = 0;
	do{
		bool yes = true;
		x += 7;
		if(x % 2 !=1 || x % 3 != 1 || x % 4 != 1 || x % 5 != 1 || x % 7 != 1) yes = false;
	}while(yes == true);
	printf("%d",x);
}
```

程序中对每个 x 值，都先给 yes 赋真值，只有在循环体各句对 x 进行判断时，都得到“通 过”(此处不赋假值)才能保持真值。

### 练习：

1. 请用代码形式写出: 输入字符填上字符数组a的1~10个位置

   
   
2. 请用代码形式写出:  输入10个整数若是奇数则输出YES否则输出NO，每输出一行换一行

   

   

3. 请思考如何在C语言中判断是否为质数，请用代码形式写出

   
   
   
   
4. 给你1000个整数，从这1000个数中找到其中的最小值，最大值并且输出出来

   
   
5. 《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 *a* 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍的长度会变为 1？

   
   
6. 以下代码循环几次？转换成while循环怎么写或者转换成for循环怎么写；

   ```
   for(int i = 1; i <= 10; i = i + 1);
   ```

   ```
   for(int i = 0; i < 10; i = i + 1);
   ```

   ```
   for(int i = 1; i <= 9; i = i + 2);
   ```

   ```
   for(int i = 1; i <= 9; i = i * 2);
   ```

   ```
   for(int i = 1; i < 9;i = i + 1, i = i * 3);
   ```

   ```
   int i = 1;
   while(i <= 5){
   	i = i + 1;
   	i = i * 2;
   }
   ```

7. 以下操作是否合法？若合法输出的结果又是什么？转换成while循环怎么写？

   ```
   for(int i = 1,j = 1; i <= 10, j <= 11; i = i + 1, j = j + 1){
   	printf("%d\n",j);
   }
   ```

   ```
   for(int i = 1,j = 1; i <= 10 && j <= 11; i = i + 1, j = j + 1){
   	printf("%d\n",j);
   }
   ```

   ```
   for(int i = 1,j = 1; i <= 10 || j <= 11; i = i + 1, j = j + 1){
   	printf("%d\n",j);
   }
   ```

   ```
   int i = 1;
   for(printf("Hello"); i <= 5,printf("LL"); i = i + 1);
   ```

   ```
   int i = 1;
   for(printf("Hello"); i <= 5; i = i + 1,printf("LLL"));
   ```

   ```
   for(int i = 1,printf("LLLL"); i <= 2; i = i + 2);
   ```

   ```
   int i = 1,j = 1,h = 1;
   for(; i <= 100,j <= 100,h <= 2;){
   	h = h * 2;
   	printf("Hello");
   }
   ```

   ```
   for(int i = 1; i <= 5; i = i + 1);
   printf("%d",i);
   ```

   ```
   for(int i = 1; i <= 10; i = i + 1){
   	i = i + 1;
   	printf("%d\n",i);
   }
   ```
   
8. 以下操作是否合法？若合法输出的结果又是什么？转换成for循环怎么写？

   ```{
   int i = 1;
   while(i <= 5){
   	printf("%d",i);
   	i = i + 1;
   }
   ```

   ```
   int i = 1;
   while(i <= 5)
   	printf("%d",i);
   	i = i + 1;
   ```

   ```
   int i = 1,j = 1;
   while(i <= 5,j <= 10){
   	printf("%d",i);
   	i = i + 1;
   	j = j + 1;
   }
   ```

   ```
   int i = 1;
   while(i <= 5 && j <= 10){
   	printf("%d",i);
   	i = i + 1;
   	j = j + 1;
   }
   ```

   ```
   int i = 1;
   while(i <= 5 || j <= 10){
   	printf("%d",i);
   	i = i + 1;
   	j = j + 1;
   }
   ```

   ```
   int i = 1;
   while(i <= 5,i++){
   	printf("%d\n",i);
   }
   ```

   ```
   int i = 1;
   while(i++,i <= 6){
   	printf("%d\n",i);
   }
   ```

<div STYLE="page-break-after: always;"></div>

# 10.循环中的关键词

有两个我们常用的关键词一个是continue，一个是break

1. continue是跳过的意思，也就是说跳过此次循环的意思。举个例子

   ```
   for(int i = 1; i <= n; i = i + 1){
   	sum += 1;
   	continue;
   	sum += 2;
   }
   //这个代码，sum += 2不会执行，因为每次遇到了continue就跳过了此次循环
   ```

2. break是结束的意思，也就是说结束循环。举个例子

   ```
   for(int i = 1; i <= n; i = i + 1){
   	sum += 1;
   	break;
   	sum += 2;
   }
   //这个代码，sum += 1只会执行一次，因为遇到了break，所有循环结束
   ```

   **注意：**continue 和 break 无法在 if 等语句中使用，只能存在于选择 (switch) 和循环的语句中

### 练习：

1. 以下代码会输出什么?

   ```
   for(int i = 1; i <= 5; i = i + 1){
   	sum += 1;
   	break;
   	sum += 2;
   }
   printf("%d",sum);
   ```

2. 以下代码会输出什么？

   ```
   for(int i = 1; i <= 5; i = i + 1){
      	sum += 1;
      	continue;
      	sum += 2;
   }
   printf("%d",sum);
   ```

3. 输入一个整数，如果这个整数不是1，继续输入，重复这个动作。

<div STYLE="page-break-after: always;"></div>

# 11.变量的作用域和生命周期

## 11.1变量分类

1. 定义在外部，没有被花括号括起来的变量称为**全局变量**.
2. 定义在内部，被花括号括起来的变量称为**局部变量**.

举例： 如下代码 g，h 是全局变量，其他的就是局部变量

```
#include<stdio.h>
int g,h;
int main(){
	int a,b;
	{
		int c,d;
	}
}
```

## 11.2作用域

作用域，程序设计概念，通常来说，一段代码中所用到的名字并不总是有效 / 可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域

### 全局变量作用域

全局变量的作用域是从变量定义的位置开始到文件结束。由于全局变量是在外部定义的，因此对所有函数而言都是外部的，可以在文件中位于全局变量定义后面的任何函数(参考 main )中使用。

**例1：**输入两个正整数.编程计算两个数的最小公倍数。

```
#include<stdio.h>
int n,m,gcd;
int main(){
	scanf("%d %d",&m,&n);
	if(m > n) gcd = n;  //由于 n,m,gcd 都是全局变量所以在哪都可以使用
	else gcd = m;
	while(gcd > 1 && (m % gcd != 0 || n % gcd != 0)){
		gcd--;
	}
	printf("%d\n",gcd);
	return 0;
}
```

在一个花括号内部，既可以使用本花括号定义的局部变量，也可以使用在此花括号前定义的全局变量。

- 全局变量的作用是使得花括号内部和外部间多了一种传递信息的方式。如果在一个程序中多个花括号内部都要对同一个变量进行处理，即共享，就可以将这个变量定义成全局变量，使用非常方便，但副作用也不可低估。

- 过多地使用全局变量，会增加调试难度。因为多个花括号内部都能改变全局变量的值，不易判断某个时刻全局变量的值。

- 过多地使用全局变量，会降低程序的通用性。如果将一个花括号移植到另一个程序中，需要将全局变量一起移植过去，同时还有可能出现重名问题。

- 全局变量在程序执行的全过程中一直占用内存单元。

- 全局变量在定义时若没有赋初值，其默认值为0。

### 局部变量作用域

-  局部变量的作用域是在定义该变量的花括号内部。换句话说，局部变量只在定义它的花括号内有效。局部变量的存储空间是临时分配的，当花括号执行 完毕，局部变量的空间就被释放,其中的值无法保留到下次使用。

-  由于局部变量的作用域仅局限于本花括号内部，所以，在不同的函数中变量名可以相同，它们分别代表不同的对象，在内存中占据不同的内存单元，互不干扰。

- 一个局部变量和一个全局变量是可以重名的，在相同的作用域内局部变量有效时全局变量无效，即局部变量可以屏蔽全局变量。

- 在代码块中定义的变量的存在时间和作用域将被限制在该代码块中。如for(int i； i <= n；i+ + ) {sum+=i} 中的 i 是在该for循环语句中定义的，存在时间和作用域只能被限制在该for循环语句中。

- 这里需要强调的是，主函数main中定义的变量也是局部变量，这一点与其他程序设计语言不同。

-  **全局变量数组初始全部为0,局部变量值是随机的**，要初始化初值，局部变量受栈空 间大小限制，大数组需要注意。通俗说，局部变量的数组不能开很大，全局变量随便。

## 11.3生命周期

变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段

1. 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。通过作用域的学习，我们发现不管是循环语句，判断语句里面写的变量只能在他们内部使用。所以我们出了他们内部，我们再也不会用他们的这些变量，所以系统会判断他为垃圾，自动销毁回收了
2. 全局变量的生命周期是：整个程序的生命周期。只有总程序结束了才会销毁

### 练习:

1. 以下哪些操作是合法的，并且说出每个变量的生命周期和作用域

```
#include<stdio.h>
int b = 1;
int main(){
	int a = 1;
	{
		printf("%d",b);
		printf("%d",a);
	}
}
```

```
#include<stdio.h>
int main(){
	{
		int a = 1;
		printf("%d",a);
	}
	printf("%d",1);
}
```

```
#include<stdio.h>
int main(){
	{	
		int a = 1;
	}
	printf("%d",a);
}
```

```
#include<stdio.h>
int main(){
	if(1){	
		int a = 1;
	}
	printf("%d",a);
}
```

```
#include<stdio.h>
int main(){
	for(int i = 1; i <= 10; i = i + 1){	
		int a = 1;
	}
	printf("%d",i);
	printf("%d",a);
}
```

```
#include<stdio.h>
int main(){
	{
		int a = 1;
	}
	for(int i = 1; i <= 10; i = i + 1){	
		a = a + 1;
	}
	printf("%d",a);
}
```

```
#include<stdio.h>
int main(){
	for(int i = 1; i <= 10; i = i + 1){	
		int a = 1;
		{
			a = a + 1;
		}
		printf("%d",a);
	}
}
```

<div STYLE="page-break-after: always;"></div>

# 12.循环嵌套

### 示例程序

**例1：**求 S =1! + 2! + 3!  +….+ 10!  (x！ = 1 * 2 * … * x - 1 * x)

【分析】这个问题是求10以内自然数的阶乘之和，可以用for循环来实现。我们发现 1！，2！…，n ! 之间改变的只是继续执行的条件如下：

```
//1!
int x = 1;
for(int i = 1; i <= 1; i++){
	x *= i;
}
//2!
int x = 1;
for(int i = 1; i <= 2; i++){
	x *= i;
}
//n!
int x = 1;
for(int i = 1; i <= m; i++){
	x *= i;
}
```

假如我们可以使得 m 从 1 变成 n 的话不断地重复上述代码即可。程序最终如下：

```
#include<stdio.h>
int main(){
	int sum = 0;
	for(int m = 1; m <= n; m++){
		int x = 1;
		for(int j = 1; j <= m; j++){
			x *= j;
		}
		sum += x;
	}
	printf("%d",sum);
	return 0;
}
```

以上程序是一个 for 循环的嵌套。这种方法是比较容易想到的，但实际上对于求 i! ,我 们可以根据求出的 (i - 1)! 乘上 i 即可得到，而无需重新从 1 再累乘到 i 

因此程序可改为：

```
#include<stdio.h>
int main(){
	int sum = 0;
	for(int m = 1; m <= n; m++){
		x *= i;
		sum += x;
	}
	printf("%d",sum);
	return 0;
}
```

显然第二个程序的效率要比第一个高得多。第一个程序要进行1 +2 + 3 +… + 10 = 55 次循环，而第二程序进行10次循环。若题目中求的是1! +2! +- + 1000!,则两个程序的效率区别更明显。

**例2：**对于给定的自然数 n(n<20), 在屏幕上输出仅由 “ ^” 构成的 n 行的直角三 角形。

例如：当 n = 5 时候 输出：

^

^ ^

^ ^ ^

^ ^ ^ ^

^ ^ ^ ^ ^

【分析】在计算机中从左往右为 第 1 列，第 2 列 ….，从上往下为第 1 行，第 2 行，倘若我们想打印如上图像我们便要从第 1 行开始打印每 1 列，其次是第 2 行。本题要重复n行操作，对于每一行，又重复若干次输出操作。于是，构成了一个两层循环：外层循环是 1 至 n 行的处理，而内层循环，则是输出同一行上的每一列。分析样例，不难发现，每一行上 ^ 的个数恰好是行数。因此对于第 i 行，内层循环可以设置重复 i 次。

```
# include<stdio.h>
int main (){
	int i,j,n；
    scanf("%d",&n);
    for(int i = 1; i <=n; i++){
    	for(int j = 1; j <= i; j++){ //打印第 i 行的每 一 列
    		printf("^");
    	}
    	printf("\n"); //打印完一行换一行
    }
    return 0；
    }
}
```

**例3：**求100 ~ 999中的水仙花数。若三位数 ABC ,ABC = A^3^ + B^3^ + C^3^ ,则称 ABC 为水仙花数。例如153,1^3^ + 5^3^ + 3^3^ = 1 + 125 + 27 = 153，则 153 是水仙花数。

【分析】在数学中解决这个问题，我们通常会列出一个方程组，设第 1 个数为 A，第 2 个数为 B，第 3 个数为 C

A * 100 + B * 10 + C * 1 = A^3^ + B^3^ + C^3^

同时满足上述方程的 A、B、C 值就是所求。根据这个思路，问题就转化为求解方程组，我们列举 A、B、C 的所有可能解，然后判断这 些可能解是否能使方程组成立。能使方程组成立的，就是直正的解。进一步分析 A 的值一定是 1 ~ 9，B 的值是 0 ~ 9，C的值是 0 ~ 9，假设我们通过循环列举了 A 的值，我们希望在 A 的值被确定的基础上去确定 B 的值….我们思考作用域，我们知道循环变量的作用域就是在循环体内，所以想在 A 的基础上确定 B ，我们就需要把 B 的循环体写在 A 的循环体内。程序如下：

```
include <stdio.h>
int main(){
	for(int A = 1; A <= 9; A++){  
		for(int B = 0; B <= 9; B++){
			for(int C = 0; C <= 9; C++){
				if(A * 100 + B * 10 + C * 1 == A * A * A + B * B * B + C * C * C){
					printf("%d %d %d\n",A,B,C);
				}
			}
		}
	}
}
```

同时也可以采用一个 for 循环来求解，表面上看好像优于三重循环，实际上却比上面的程序效率低，请同学们自己分析

程序如下：

```
#include<stdio.h>
int main(){
    for (int m = 100; m <= 999; m++){
        int a = m / 100; //m 的百位
        int b = (m % 100) / 100 //m 的十位
        int c = m % 10 // m 的个位
        if(a * a * a + b * b * b + c * c * c == m){
            printf("%d %d %d",a,b,c);
        }
    }
}
```

**例4： **输出100~200中所有的素数。

【分析】 我们可对100~200之间的每一个整数进行判断，若它是素数，则输出。而对于任意整数 i 根据素数定义，我们从2开始到 i - 1，倘若找到约数则不是素数。

程序如下：

```
#include<stdio.h>
int main(){
	for(int i = 100; i <= 200; i++){
		bool flag = true;//判断是否是素数，true 表示是的
		for(int j = 2; j <= i - 1; j++){
			if(i % j == 0){ //i 整除 j
				flag = false;
			}
		}
		if(flag == true){
			printf("%d\n",i);
		}
	}
}
```

**例5：**aabb 的四位完全平方数(即前两位数字相等，后两位数字也相等)。

【分析】分支和循环结合在一起时威力特别强大：我们枚举所有可能的 aabb ,然后判断它们是否为完全平方数。注意：a的范围是 1~9, b可以是 0 。

【方法1】可以循环 a 所有可能的值，b所有可能的值，程序如下：

```
#include<stdio.h>
int main(){
    for (int a = 1; a <= 9; a++){
        for (int b = 0; b <= 9; b++){
            int s = a * 1000 + a * 100 + b * 10 + b * 1;
            bool flag = false;
            for(int i = 1;; i++){
                if(i * i == s){
                    flag = true;
                    break;
                }
                if(i * i > s){
                    break;
                }
            }
            if(flag == true){
                printf("%d\n",s);
            }
        }
    }
}
```

此方法用到了 break 来控制循环结束。另外，注意到这里的 for 语句是“残缺”的：没有指定循环条件。事实上，3个部分都是可以省略的。没错，for( ；；)就是一个死循环——如果不采取措施(如break),它就永远不会结束。

【方法2】直接去枚举平方根，去判断它的 2 次幂是否为 aabb 形式的四位数

```
# include<stdio.h>
int main(){
	for (int x = 1;; x++){
        int n = x * x；
        if (n<1000) continue; //跳过当前循环
        if (n>9999) break; //结束整个忙
        int hi = n / 100; //前两位数
        lo = n % 100; //后两位数
        if (hi / 10 == hi % 10 && lo / 10 == lo % 10) printf("%d\n ",n)；
    	return 0；
    }
}
```

# 13.数组嵌套

### 二维数组的定义

当一维数组元素的类型也是一维数组时，便构成了“数组的数组”，即二维数组。二维数 组定义的一般格式：

数据类型 数组名[常量表达式1] [常量表达式2]；

例如：`int a[4][10]`；

读作 a 是一个大小为 4 的数组，内部的元素是大小为 10 的整形数组。

也就是说 a[0]、a[1]、a[2]、a[3]、a[4] 都是大小为 10 的数组，a[0]、a[1]….只是这些大小为 10 的数组的名字

a 数组实质上是一个有 4 行、10 列的表格，表格中可储存 40 个元素。第 1 行第 1 列对 应a数组的`a[0][0]` ,第 n 行第 m 列对应数组元素`a[n—l][m—1]`。

说明：当定义的数组下标有多个时，我们称为多维数组，下标的个数并不局限在一个或 两个，可以任意多个，如定义一个三维数组 a 和四维数组 b ：

`int a[100][3][5]`；

`int b[100][100][3][5]`；

多维的数组引用赋值等操作与二维数组类似。

### 二维数组元素的引用

二维数组的数组元素引用与一维数组元素引用类似，区别在于二维数组元素的引用必须给出两个下标。

引用的格式为：

`数组名 [下标1][下标2]`

说明:显然,每个下标表达式取值不应超出下标所指定的范围，否则会导致致命的越界错误。

例如，设有定义：`int a[3][5]`；

则表示 a 是二维数组（相当于一个3 * 5的表格），共有 3 * 5 = 15个元素，它们是：

` a[0][0] a[0][1] a[0][2] a[0][3] a[0][4]`

`a[2][0] a[2][2] a[2][3] a[2][4]`

因此可以看成一个矩阵（表格），`a[2][3]`即表示第 3 行第 4 列的元素。

### 二维数组的初始化

二维数组的初始化和一维数组类似。可以将每一行分开来写在各自的括号里，也可以把所有数据写在一个括号里。

例如：

```
int direct[4][2] = {{1,0},{0,1},{—1,0},{0,-1}}
int direct[4][2] = {l,0,0,1,— 1,0,0,—1}	//尽量不要用
```

### 二维数组程序设计

**例1：**设有一程序

```
#include<stdio.h>
int a[5][5];
int main(){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
}
```

程序的输入：

2 1 3

3 3 1

1 2 1

程序的输出：

2 3 1

1 3 2

3 1 1

**例2：**已知一个6 * 6的矩阵(方阵)，把矩阵二条对角线上的元素值加上 10 ,然后输 出这个新矩阵。

【分析】 矩阵即表格，是一个二维数组，有 6 行 6 列共 36 个元素，每个矩阵都有二条对角线，本题难点在于对角线的元素怎么确定。

```
#include<stdio.h>
int a[7][7];
int main(){
	for(int i = 1; i <= 6; i++){
		for(int j = 1; j <= 6; j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i = 1; i <= 6; i++){
		for(int j = 1; j <= 6; j++){
			if((i == j) || (i + j == 7)) a[i][j] = 10; //左下对角线就是 i,j 相同，右下对角线就是 i + j == 7
		}
	}
	for(int i = 1; i <= 6; i++){
		for(int j = 1; j <= 6; j++){
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

**例3：**大部分元素是 0 的矩阵称为稀疏矩阵，假设有 k 个非 0 元素，则可把稀疏矩阵 用 k * 3 的矩阵简记之，其中第一列是行号，第二列是列号，第三列是该行、该列下的非元素的值。如:

0 0 0 5

0 2 0 0

0 1 0 0

简记成：

1 4 5  〃第1行第4列有个数是5

2 2 2   〃第2行第2列有个数是2

3 2 1   〃第3行第2列有个数是1

试编程读入一稀疏矩阵，转换成简记形式，并输出。

【分析】本题中需要解决的主要问题是查找非零元素并记忆位置。将原始矩阵存于数 组a。转换后的矩阵存于数组b,当然b数组的行数可以控制在一个小范围内。

```
#include<stdio.h>
int n,m,a[10][10],b[10][10];
int main(){
	scanf("%d %d",&n,&m);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			if(a[i][j] !== 0){ //找到非0的值去存储
				k++;
				b[k][1] = i;
				b[k][2] = j;
				b[k][3] = a[i][j];
			}
		}
	}
	for(int i = 1; i <= k; i++){
		for(int j = 1; j <= 3; j++){
			printf("%d ",b[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

运行结果：

输入： 

3 5

0 0 0 0 5

0 0 4 0 0

1 0 0 0 1

输出：

1 5 5

2 3 4

3 1 1

3 5 1

**例4：**打印杨辉三角形的前10行。杨辉三角形如下图：

​	  1                             1

​    1 1                            1 1

   1 2 1                          1 2 1

 1 3 3 1                         1 3 3 1

1 4 6 4 1                       1 4 6 4 1

​	图1  							 图2

【分析】 观察图 1， 大家不容易找到规律，但是如果将它转化为图 2 ,不难发现杨辉三角形其实就是一个二维表的小三角形部分，假设通过二维数组 a 存储,每行首尾元素为 1 ,且其中任意一个非首位元素 a[i] [j] 的值其实就是 a[i - 1] [j - 1] 与 a[i - 1] [j] 的和，另外每一行的元素个数刚好等于行数。有了数组元素的值，要打印杨辉三角形，只需要控制好输出起始位置就行了。

```
#include<stdio.h>
int main(){
	int a[11][11];
	a[1][1] = 1; //设置第一行为1
	for(int i = 2; i <= 10; i++){ //从第二行开始推
		a[i][1] = 1;a[i][i] = 1; //设定每一行的首尾值为1
		for(int j = 2; j <= i - 1; j++){
			a[i][j] = a[i - 1][j - 1] + a[i - 1][j]; //每个数等于上一行的两个数之和
		}
	}
	for(int i = 1; i <= 10; i++){
		for(int j = 1; j <= i; j++){
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

<div STYLE="page-break-after: always;"></div>

# 14.字符类型和字符数组

无论数组的下标有几个，类型如何，但数组中全体元素的类型必须相同。数组元素的类型可以是任何类型，当它是字符型时，我们称它为字符数组。由于字符数组与字符串的应用是计算机非数值处理的重要方面之一，所以我们把它们两个放在一起进行讨论。

## 14.1字符类型

### 定义

字符类型为由一个字符组成的字符常量或字符变量。 

字符变量定义 ： `char 字符变量名`;

字符类型是一个有序类型，字符的大小顺序按其ASCII代码的大小而定。

字符常量：`'字符'`，平常用单引号直接引起来的就是字符常量

### 示例程序

**例1：**按字母表顺序和逆序每隔一个字母打印。即打印出： acegikmoqsuwyzxrvtpnljhfdb

程序如下：

```
#include<stdio.h>
int main(){
    for (char letter = ' a '; letter< = ' z '; letter+ = 2){
        printf("%c",letter);
    }

    for(char letter = 'z'; letter >= 'a'; letter -= 2){
    	printf("%c",letter);
    }
	return 0;
}
```

【说明】程序中，我们利用了字符类型是顺序类型这一特性，灵活利用字符变量当作循 环变量，使程序处理起来比较直观。

## 14.2字符数组

### 定义

字符数组是指元素为字符的数组。字符数组是用来存放字符序列或字符串的。字符数组也有一维、二维和三维之分。 

字符数组定义格式同于一般数组，所不同的是数组类型是字符型，第一个元素同样是从 ch1[0] 开始，而不是 ch2[1] 具体格式如下：

[存储类型] char 数组名[常量表达式1]…

例如：

`char ch1[5]`；	〃数组chi是一个具有 5 个字符元素的一维字符数组

`char ch2[3][5]`； 〃数组ch2是一个具有 15 个字符元素的二维字符数组(ch2 是一个大小为 3 的数组，里面的元素是大小为 5 的字符数组)

### 字符数组的赋值

字符数组赋值类似于一维数组，赋值分为数组的初始化和数组元素的赋值。初始化的 方式有用**字符初始化**和用**字符串初始化**两种，也有用初始值表进行初始化的。

(1) 用字符初始化数组

例如：`char ch[5] = {'a','b','c','d','e'};`

初始值表中的每个数据项是一个字符，用字符给数组ch的各个元素初始化。当初始值个数少于元素个数时，从首元素开始赋值，剩余元素默认为空字符。

字符数组中也可以存放若干个字符，也可以来存放字符串。两者的区别是字符串有一结束符（'\0'）。反过来说，在一维字符数组中存放着带有结束符的若干个字符称为字符串。 字符串是一维数组，但是一维字符数组不等于字符串。

例如：

`char ch[5]={'a ','b ','c ','d ','\0'}`；即在数组 ch 中存放着一个字符串 abcd。

(2) 用字符串初始化数组

用一个字符串初始化一个一维字符数组，可以写成下列形式：

` char ch[5] = "abcd"`； 即在数组 ch 中存放着一个字符串 abcd，上下两个语句等价。

使用此格式均要注意字符串的长度应小于字符数组的大小或等于字符数组的大小减1。 同理，对二维字符数组来讲，可存放若干个字符串。可使用由若干个字符串组成的初始值表给二维字符数组初始化。

例如：

`char ch[3][4] = {"abc","mno","xyz"}`

(3) 数组元素赋值

字符数组的赋值是给该字符数组的各个元素赋一个字符值。

例如：

`char ch[3]; ch[0]= 'a'; ch[1] = 'b'; ch[2] = 'c';`

对二维、三维字符数组也是如此。当需要将一个数组的全部元素值赋予另一数组时，不 可以用数组名直接赋值的方式，要使用字符串拷贝函数来完成。

### 字符常量和字符串常量

① 两者的定界符不同，**字符常量由单引号**括起来，**字符串常量由双引号**括起来。

② 字符常量只能是单个字符，字符串常量则可以是任意多个字符。

③ 可以把一个字符常量赋给一个字符变量，但不能把一个字符串常量赋给一个字符变量

④ 字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加 1 。增加的一个字节中存放字符串结束标志 ’\0‘，。例如：字符常量 'a' 占一个字节，字符串常量 "a" 占两个字节。

### 字符串的输入与输出

字符串可以作为一维字符数组来处理，那么字符串的输入和输出也可以按照数组元素来处理。

#### 输入

从键盘输入一个字符数组可以使用 `scanf` 语句 和` gets` 语句。

(1)` scanf` 语句

格式：` scanf("%s",字符串名称)`；

说明：

① 这里的字符串名称之前不加&这个取地址符。例如：`scanf("%s",&x)` 是错误的。

② 系统会自动在输入的字符串常量后添加 '\0' 标志，因此输入时，仅输入字符串的内容即可。

③ 输入多个字符串时，以空格分隔。

例如: `scanf("%s%s%s”,s1,s2,s3);` 从键盘分別输入Let us go,则三个字符串分别获取了三个单词。反过来可以想到，如果仅有一个输入字符串名称的情况下，字符串变量仅获取空格前的内容。

例如：`scanf("%s",s);`从键盘分别输入Let us go,则仅有第一个单词被获取，即 s 变 量仅获取第一个单词 Let 。

(2) `gets` 语句

格式: `gets(字符串名称);`

说明：

使用 `gets` 只能输入一个字符串。

例如：`gets(s1 ,s2)；`是错误的。使用` gets `,是从光标开始的地方读到换行符也就是说读入的是一整行，而使用 scanf 是从光标开始的地方到空格，如果这一行没有空格，才读到行尾。

例如`:scanf("%s ”,s1);gets(s2);`对于相同的输入Hello World !  s1 获取的结果仅仅 是Hello,而 s2 获取的结果则是Hello World!

#### 输出

向屏幕输出一个字符串可以使用 `printf `语句或 `puts` 语句。

(1) printf 语句

格式：`printf("%s "，字符串名称);`

说明：

① 用 ％s 格式输出时, printf 的输出项只能是字符串(字符数组)名称，而不能是数组元 素。例如：`printf("%s ” ,a[5]);`是错误的。

② 输出字符串不包括字符串结束标志符 '\0'

(2) puts 语句

格式:`puts(字符串名称);`

说明：puts 语句 输出一个字符串和一个换行符。对于已经声明过的字符串 a , `printf("%s\n",a)` 和 `puts(a)` 是等价的。

#### 示例程序

**例1：**输入一个字符串，求字符串的长度。

【分析】 当使用 scanf 输入字符串的时候自动会把最后一个位置替换成 '\0'

程序如下：

```
#include<stdio.h>
int main(){
	char a[100];
	scanf("%s",a);
	int i = 0; 
	while(a[i] != '\0') i++;
	printf("%d",i);
}
```

**例2：**过滤多余的空格

一个句子中也许有多个连续空格，过滤掉多余的空格，只留下一个空格。

输入：

一行，一个字符串(长度不超过200),句子的头和尾都没有空格。

输出：

过滤之后的句子。

样例输入：

Hello    world.    This    is    c    language.

样例输出：

Hello world. This is c language.

【分析】scanf 只能一个一个读"单词"，不读空格，这里我们可以使用 scanf 的特性，倘若文件结束返回 -1 ，`while(scanf("%s",&a) != -1)`的功能就是循环读入字符串，直到读不到字符串

程序如下：

```
#include<stdio.h>
char a[1000];
int main(){
	while(scanf("%s",&a) != -1){
		printf("%s ",a); //%s后边要有一个空格
	}
}
```

<div STYLE="page-break-after: always;"></div>

# 15.复杂度

时间复杂度和空间复杂度是衡量一个算法效率的重要标准。

## 15.1基本操作数

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。

对基本操作的计数或是估测可以作为评判算法用时的指标。

## 15.2时间复杂度

### 定义

衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 **时间复杂度**。

### 引入

考虑用时随数据规模变化的趋势的主要原因有以下几点：

1.  现代计算机每秒可以处理数亿乃至更多次基本运算，因此我们处理的数据规模通常很大。如果算法 A 在规模为 $n$ 的数据上用时为 $100n$ 而算法 B 在规模为 $n$ 的数据上用时为 $n^2$，在数据规模小于 $100$ 时算法 B 用时更短，但在一秒钟内算法 A 可以处理数百万规模的数据，而算法 B 只能处理数万规模的数据。在允许算法执行时间更久时，时间复杂度对可处理数据规模的影响就会更加明显，远大于同一数据规模下用时的影响。
2.  我们采用基本操作数来表示算法的用时，而不同的基本操作实际用时是不同的，例如加减法的用时远小于除法的用时。计算时间复杂度而忽略不同基本操作之间的区别以及一次基本操作与十次基本操作之间的区别，可以消除基本操作间用时不同的影响。

当然，算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：

1.  最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。
2.  平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。

所谓「用时随数据规模而增长的趋势」是一个模糊的概念，我们需要借助下文所介绍的 **渐进符号** 来形式化地表示时间复杂度。

## 15.3渐进符号的定义

渐进符号是函数的阶的规范描述。简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。

一个简单的记忆方法是，含等于（非严格）用大写，不含等于（严格）用小写，相等是 $\Theta$，小于是 $O$，大于是 $\Omega$。大 $O$ 和小 $o$ 原本是希腊字母 Omicron，由于字形相同，也可以理解为拉丁字母的大 $O$ 和小 $o$。

在英文中，词根“-micro-”和“-mega-”常用于表示 10 的负六次方（百万分之一）和六次方（百万），也表示“小”和“大”。小和大也是希腊字母 Omicron 和 Omega 常表示的含义。

### 大 Θ 符号

对于函数 $f(n)$ 和 $g(n)$，$f(n)=\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0>0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$。

也就是说，如果函数 $f(n)=\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。

例如，$3n^2+5n-3=\Theta(n^2)$, 这里的 $c_1, c_2, n_0$ 可以分别是 $2, 4, 100$。$n\sqrt {n} + n{\log^5 n} + m{\log m} +nm=\Theta(n\sqrt {n} + m{\log m} + nm)$，这里的 $c_1, c_2, n_0$ 可以分别是 $1, 2, 100$。

### 大 O 符号

$\Theta$ 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号。$f(n)=O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$。

研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。

需要注意的是，这里的「上界」和「下界」是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是「最坏时间复杂度」而非大 $O$ 记号。所以，使用 $\Theta$ 记号表示最坏时间复杂度是完全可行的，甚至可以说 $\Theta$ 比 $O$ 更加精确，而使用 $O$ 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 $O$ 在电脑上输入更方便一些。

### 简单的时间复杂度计算的例子

**例1：**

```
int n, m;
scanf("%d %d",&n,&m);
for (int i = 0; i < n; ++i) {
  for (int j = 0; j < n; ++j) {
    for (int k = 0; k < m; ++k) {
      printf("Hello World");
    }
  }
}
```

如果以输入的数值 $n$ 和 $m$ 的大小作为数据规模，则上面这段代码的时间复杂度为 $O(n^{2}m)$。

**例2：**

```
int n,m;
scanf("%d %d",&n,&m);
printf("%d\n",n + m);
```

如果以输入的数值 $n$ 和 $m$ 的大小作为数据规模，则上面这段代码的时间复杂度为 $O(1)$。

## 15.4空间复杂度

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。同样的用 O(）来表示

### 练习:

1. 求 $n$ 以内所有的质数时间复杂度是多少？能不能优化？

   

2. 以下代码实现复杂度是多少

   ```
   #include<stdio.h>
   int main(){
   	int n;
   	scanf("%d",&n);
   	for(int i = 1; i <= n; i++){
   		for(int j = 1; j <= i; j++){
   			printf("%d ",j);
   		}
   		printf("\n");
   	}
   	return 0;
   }
   ```

   <div STYLE="page-break-after: always;"></div>

# 16.函数

前面我们曾经学习了程序设计中的三种基本控制结构(顺序、分支、循环)，用它们可以 组成任何程序。但在应用中，还经常用到子程序结构。

通常，在程序设计中，我们会发现一些程序段在程序的不同地方反复出现，此时可以将 这些程序段作为相对独立的整体，用一个标识符给它起一个名字，凡是程序中出现该程序段的地方，只要简单地写上其标识符即可。这样的程序段，我们称之为子程序。

子程序的使用不仅缩短了程序，节省了内存空间及减少了程序的编译时间，而且有利于 结构化程序设计。因为一个复杂的问题总可将其分解成若干个子问题来解决，如果子问题 依然很复杂，还可以将它继续分解，直到每个子问题都是一个具有独立任务的模块。这样编 制的程序结构清晰，逻辑关系明确，无论是编写、阅读、调试还是修改，都会带来极大的好处。

在一个程序中可以只有主程序而没有子程序(本章以前都是如此)，但不能没有主程序， 也就是说不能单独执行子程序。

我们来看看下面一个例子：求：1!  + 2!  + 3!  +… + 10!  = ?

如果要编写程序，我们看到求阶乘的操作要执行 10 次，只不过每次所求的数不同。我 们不至于编写 10 遍求阶乘的程序吧！我们希望有一个求阶乘的函数，假设为 js(x) ,我们就可以这样求这道题了。

**例1：** 求：1! + 2! + 3! +…+10!

```
#include<stdio.h>
int main(){
	for(int i = 1; i <= 10; i++){
		sum += js(i);
	}
}
```

现在的问题是:C语言不提供 js(x) 这样一个函数，这个程序是通不过的，没关系，我们编写自己的函数。如果是C语言的标准函数，可以直接调用，如 scanf printf 等而 C 调用的标准函数需要在程序中通过 #include 指令加入相应的库即可。

### 函数的定义

```数据类型函数名（形式参数表）
数据类型 函数名（形式参数表）{
	函数体	//执行语句
}
```

关于函数的定义有如下说明：

- 函数的数据类型是函数的返回值类型（可以为 int ,char 等)（若数据类型为void ,则无返回值）。

- 函数名是标识符，一个程序中除了主函数名必须为 main 以外，其余函数的名字按照标识符的取名规则可以任意选取，最好取有助于记忆的名字。

- 形式参数（简称形参）表可以是空的（即无参函数），也可以有多个形参，形参间用逗号隔开，不管有无参数，函数名后的圆括号都必须有。形参必须有类型说明，形参可以是变量名、数组名或指针名，它的作用是实现主调函数与被调函数之间的关系。例如：

  ```
  int s(int x,y){} //这样是不被允许的，
  int s(int x,int y){} //每个变量必须有类型说明
  ```

- 函数中最外层一对花括号“ { } ”括起来的若干个说明语句和执行语句组成了一个函数的函数体。由函数体内的语句决定该函数功能。函数体实际上是一个复合语句.它可以没有任何类型说明，而只有语句，也可以两者都没有，即空函数。

- 函数不允许嵌套定义。在一个函数内定义另一个函数是非法的，但是允许嵌套使用。

函数在没有被调用的时候是静止的，此时的形参只是一个符号，它标志着在形参出现的位置应该有一个什么类型的数据。函数在被调用时才执行，也就是在被调用时才由主调函数将实际参数（简称实参）值赋予形参。这与数学中的函数概念相似，如数学函数：f(x) = x^2^ + x + 1。这样的函数只有当自变量被赋值以后，才能计算出函数的值。

#### 函数定义的例子

定义一个函数，返回两个数中的较大数。

```
int max（int x,int y）{
	if(x > y) return x;
	return y;
}
```

该函数返回值是整型，有两个整型的形参，用来接受实参传递的两个数据，函数体内的 语句是求两个数中的较大者并将其返回主调函数。

#### 函数的形式

函数的形式从结构上说可以分为三种：无参函数、有参函数和空函数。它们的定义形式 都相同。

①无参函数

​		无参函数顾名思义即为没有参数传递的函数，无参函数一般不需要带回函数值，所以函数类型说明为 void 。

②有参函数

​		有参函数即有参数传递的函数，一般需要带回函数值。例如 int max(int x,int y) 函数。

③空函数

​		空函数即函数体只有一对花括号，花括号内没有任何语句的函数。例如：函数名(){ }

空函数不完成什么工作，只占据一个位置。在大型程序设计中，空函数用于扩充函数功能。

编写一个阶乘的函数，我们给此函数取一个名字 js 。

```
int js(int n){
	int s = 1;
	for(int i = 1; i <= n; i++){
		s *= i;
	}
	return s;
}
```

在本例中，函数名叫 js ，只有一个 int 型的自变量 n ,函数 js 属 int 型。在本函数中，要用 到两个变量 i，s 。在函数体中，是一个求阶乘的语句，$n$ 的阶乘的值在 s 中，最后由 return 语句将计算结果 s 值带回, js() 函数执行结束.在主函数中 js() 值就是 s的值。

在这里，函数的参数 $n$ 是一个接口参数，说得更明确点是入口参数。如果我们调用函 数:  js(3) ，那么在程序里所有有 n 的地方，n​ 被替代成 3 来计算。在这里，3 就被称为实参。 又如：sqrt(4) , ln(5)，这里 4 , 5 叫实参。而 In (x),  sqrt (x) 中的 x，y 叫形参。完整的程序如下：	•

```
#include<stdio.h>
int js(int n);
int main(){
	int sum = 0;
	for(int i = 1; i <= 10; i++){
		sum += js(i);
	}
	printf("%d\n",sum);
}
int js(int n){
	int s = 1;
	for(int i = 1; i <= n; i++){
		s *= i;
	}
	return s;
}

```

### 函数的声明和调用

**1.函数的声明** 

调用函数之前先要声明函数原型。在主调函数中或所有函数定义之前，按如下形式声明：

`类型说明符  被调函数名(含类型说明的形参表);`

如果是在所有函数定义之前声明了函数原型，那么该函数原型在本程序文件中任何地方都有效，也就是说在本程序文件中任何地方都可以依照该原型调用相应的函数。如果是在某个主调函数内部声明了被调用函数原型，那么该原型就只能在这个函数内部有效，简而言之声明改变了函数的作用域。

下面对 js() 函数原型声明是合法的。

`int js(int n);`

也可以：

`int js(int);`

可以看到函数原型声明与函数定义时的第一行类似，只多了一个分号，成为了一个声明语句而已。

倘若没有写函数的声明也没有关系，因为直接写函数的定义，也相当于声明了。

**2.函数的调用**

声明了函数原型之后，便可以按如下形式调用函数：

`函数名(实参列表)`	〃例题中语句sum+=js(i)；

实参列表中应给出与函数原型形参个数相同、类型相符的实参。在主调函数中的参数 称为实参，实参一般应具有确定的值。实参可以是常量、表达式，也可以是已有确定值的变量、数组或指针名。函数调用可以作为一条语句，这时函数可以没有返回值。函数调用也可以出现在表达式中，这时就必须有一个明确的返回值。

**3.函数的返回值** 

在组成函数体的各类语句中，值得注意的是返回语句return。它的一般形式是：

`return (表达式);` 〃例题中语句return s；

其功能是把程序流程从被调函数转向主调函数并把表达式的值带回主调函数，或者说通过 return 控制当前函数结束。所以，在圆括号表达式的值实际上就是该函数的返回值。其返回值的类型即为它所在函数的函数类型。当一个函数没有返回值时，函数中可以没有 return 语句，直接利用函数体的右花括号 “}”，作为没有返回值的函数的返回。也可以有return语句，但 return 后 没有表达式。返回语句的另一种形式是：

`return;`

这时函数没有返回值，而只把流程转向主调函数。

### 函数的传值调用

函数传值调用的特点是将调用函数的实参表中的实参值依次对应地传递给被调用函数的形参表中的形参。要求函数的实参与形参个数相等，并且类型相同。函数的调用过程实际上是对栈空的操作过程，因为调用函数是使用栈空间来保存信息的。函数在返回时，如果有返回值，则将它保存在临时变量中。然后恢复主调函数的运行状态，释放被调用函数的栈空间，按其返回地址返回到调用函数。

在C语言中，函数调用方式分传值调用和传址调用。

**1.传值调用**

这种调用方式是将实参的数据值传递给形参，即将实参值拷贝一个副本存放在被调用函数的栈区中。在被调用函数中，形参值可以改变，但不影响主调函数的实参值。参数传递方向只是从实参到形参，简称单向值传递。举个例子：

```
#include<stdio.h>
void swap(int a,int b){
	int tmp = a;
	a=b;
	b=tmp;
}
int main(){
	int c = 1 ,d = 2;
	swap(c,d);
	printf("%d %d",c,d);
	return 0;
}
```

在此例中，虽然在swap函数中交换了 a,b 两数的值，但是在 main 中却没有交换。因为 swap 函数只是交换 c,d 两变量副本的值，实参值没有改变，并没有达到交换的目的。

**2.传址调用** 

这种调用方式是将实参变量的地址值传递给形参，这时形参是指针，即让形参的指针指向实参地址，这里不再是将实参拷贝一个副本给形参，而是让形参直接指向实参，这就提供了一种可以改变实参变量的值的方法。现在用传址调用来实现 swap：

```
#include<stdio.h>
void swap(int &a,int &b){
	int tmp = a;
	a=b;
	b=tmp;
}
int main(){
	int c = 1 ,d = 2;
	swap(c,d);
	printf("%d %d",c,d);
	return 0;
}
```

在此例中，因为swap函数的参数为传址调用，&a是指实参变量的地址值传递给形参， 所以，在函数 swap 中修改 a,b 的值相当于在主函数 main 中修改 c,d 的值。

### 函数的调用顺序

函数调用一般是这样例如

```
int add(int a,int b){
	return a + b;
}
int main(){
	add(1,2); //函数名字 + 需要传递的参数
	return 0;
}
```

注意，我们的函数底层使用的是数据结构中的栈实现，每次函数调用其实就是一个压入栈的过程，当函数运行结束后，会返回到上一个函数中(主调函数),这个过程我们称之为弹栈。比如说函数 A 调用函数 B ，那么程序的控制权由函数 A 传递给函数 B, 当函数 B 运行结束后，会从 函数 B 返回到函数 A, 下面演示了这个过程。

调用过程

```
操作系统 -> 主函数main() -> A() -> B() -> C() -> D()
```

返回过程

```
操作系统 <- 主函数main() <- A() <- B() <- C() <- D()
```

一句话总结就是,函数从哪儿调用，就会返回到哪儿。(从哪儿来，回哪儿去)，不过值得注意的是: 当函数返回的时候，可以携带结果返回，返回给主调函数。

### 函数的应用举例

**例1：** 定义一个函数 check(n,d) ，让它返回一个布尔值。如果数字 d 在正整数 n 的某位中出现则送回 true ，否则送回 false。

例如：check(325719,3) == true；check(77829,1) == false；

```
#include <stdio.h>
using namespace std；
bool check(int,int);
int main(){
    int a,b；
   	scanf("%d %d",&a,&b);
    if (check(a,b) == true) printf("true");
    else printf("false");
    return 0;
}
bool check(int n,int d){
	while(n){
		int e = n % 10;
		n /= 10;
		if(e == d) return true;
	}
	return false;
}
```

### 函数的空间

之前讲过在花括号中变量作用域只会在花括号内，函数可以被调用任意次，函数体之间的变量是没有影响的，也就是说函数相当于创建了一个新的空间

例如：

```
#include<stdio.h>
int Zen(int x,int y){
	x++;
	y++;
	printf("%d %d ",x,y);
}
int main(){
	Zen(1,1); //创建新的空间
	Zen(1,1); //创建新的空间
}
```

会输出: 2 2 2 2，说明两者之间的空间没有任何关系

### 函数的综合应用

**例1：**写一个判断素数的函数，输入一个数，判断它是否是素数，是输出 yes，不是输出 no 。

【分析】对于任意整数 i ，根据素数定义，我们从2开始，到 i - 1，找 i 的第一个约数，若找到第一个约数，则 i 必然不是素数

程序如下：

```
#include<stdio.h>
bool check(int x){
	for(int i = 2; i <= x - 1; i++){
		if(x % i == 0) return  false;
	}
	return true; 
}
int main(){
	int x;
	scanf("%d",&x);
	if(check(x)) printf("yes");
	else printf("no");
}
```

**例2：**编写一个给一个分数约分的程序。

程序如下：

```
#include<stdio.h>
int min(int x,int  y){
	if(x > y) return y;
    return x;
}
void YF(int &x,int &y){
    for(int i = 2; i < min(x,y); i++){
        while(x % i == 0 && y % i == 0){
        	x /= i;
        	y /= i;
        }
    }
}
int main(){
	int x,y;
	scanf("%d %d",&x,&y);
	YF(x,y);
	printf("%d %d",x,y);
	return 0;
}
```

<div STYLE="page-break-after: always;"></div>

# 17.函数递归

### 递归的概念

当函数的定义中，其内部操作又直接或间接地出现对自身的调用，则称这样的程序嵌套定义为递归定义。

递归通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述岀解题过程所需要的多次重复计算大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。用递归思想写出的程序往往十分简洁易懂。

例如：在数学上，所有偶数的集合可递归地定义为：

① 0是一个偶数；

② 一个偶数与 2 的和是一个偶数。

可见，仅需两句话就能定义一个由无穷多个元素组成的集合。在程序中，递归是通过函数的调用来实现的。函数直接调用其自身，称为直接递归；函数间接调用其自身，称为间接递归。

不过递归对于初学者来说是不友好的，现举以下例子帮助大家理解：

我们可以把递归当做**鸣人创造分身的一种行为**，鸣人创造的分身和鸣人长的一模一样，思想一模一样，并且能力也一模一样。

假如今天鸣人要去搬 500 根木头，他自己一次只能搬一根，他发现搬不完，那么他只能召唤他的一个分身 A 去搬剩下的 499 根木头，分身 A 也只能搬一根木头，所以分身 A 也召唤一个分身 B 去搬剩下的 498 根木头，分身 B 也只能搬一根木头……依次类推，直到有 499 个分身把木头搬完了，才停止。整个搬 500 根木头是一件困难的事情，但是通过召唤分身把搬木头变成一人搬 1 根就很简单了。并且大家想的都是一样的，我只能搬一根，搬了交给分身去搬….。程序如下：

```
void Take(int x){ //剩下 x 根木头
	if(x == 1){ //搬完了不需要分身了
		return;
	}
	Take(x - 1); //剩下 x - 1根交给分身去搬
}
```

### 递归的应用

**例1：**用递归算法求 x^m^。

【分析】 把 x^m^ 分解成 x^0^ = 1  (m = 0)

​										x^1^ = x * x^0^  (m = 1)

​										x^2^ = x * x^1^  (m > 1)

​										x^3^ = x * x^2^  (m > 1)

​										……

因此可以将 x^m^ 转化成：x * x^m-1^，其中 x^m-1^ 又用同样的方法去求解

①定义子程序 xn(int m) 求 x^m^；如果 m >= 1，则递归调用 xn(n - 1) 求 x^n-1^ ;

②当递归调用到达 m = 0 时终止调用，然后执行本 层 的后继语句；

③遇到子程序运行完后，就结束本次的调用，返回到上一层调用语句的地方，并执行后继语句

④继续执行步骤③，从调用中逐层返回，最后回到主程序。

程序如下：

```
#include<stdio.h>
int xn(int);
int main(){
	int n;
	scanf("%d",&n);
	printf("%d",xn(n));
}
int xn(int m){
	if(m == 0) return 1;
	else return x * xn(m - 1);
}
```

**例2：**用递归函数求 x!

【分析】把 x! 分解成 x! = 1   (x = 1)

​                                     x! = x * (x - 1)!  (x > 1)

假设用函数 Fac(x) 表示 x 的阶乘，当 x = 3时，Fac(3) 的求解方法课表示为 Fac(3) = Fac(2) * 3 = Fac(1) * 2 * 3 = 1 * 2 * 3 = 6

①定义函数：int fac(int n)

​	如果 n == 1 则 fac = 1；如果 n > 0，则继续调用函数 fac = n * fac(n - 1);

②返回主程序，打印 fac(x) 的结果。

它的执行流程如下：

->表示调用，-》表示返回

Fac(3)   ->   Fac(2)  ->  Fac(1)  -》 Fac(1) = 1  -》  Fac(1) * 2  -》  Fac(2) * 3  -》  Fac(3)

程序如下：

```
#include<stdio.h>
int Fac(int );
int main(){
	int n;
	scanf("%d",&n);
	printf("%d",Fac(n));
	return 0;
}
int Fac(int x){
	if(x == 1) return x;
	return Fac(x - 1) * x;
}
```

**例3：**求两个数的最大公约数，可以用枚举因子的方法，从两者中较小的数枚举到 能被两个数同时整除且是最大的约数的方法；也可以用辗转相除法，这里釆用递归实现辗转相除算法：

① 求 m 除以 n 的余数；

② 如果余数不为 0 ,则让 m = n, n = 余数 ，重复步骤①，即调用子程序；

③ 如果余数为 0 ,则终止调用子程序；

④ 输出此时的 n 值。

程序如下：

```
#include<stdio.h>
int gcd(int ,int );
int main(){
	int m,n;
	scanf("%d %d",&m,&n);
	printf("%d",gcd(m,n));
}
int gcd(int m,int n){
	return n == 0? m : gcd(n,m % n);
}
```

**例4：**已知一个一维数组 a[1..n] (n <= 25)，又已知一整数 m 。如能使数组 a 中任意几个元素之和等于 m ，则输岀 YES ，反之则为 NO

【分析】 对于一个已确定的数组 a[1. . n] 和一个确定的数 m ，判断能否使数组 a 中任意 几个元素之和等于 m ，等价于判断能否从数组 a 中取任意数使其和为m 。

对于 a 中任意元素 a[n] 只有取与不取两种情况：

(1) 取 a[n] ：

则此时问题转化为：对于一个已确定的数组 a[1. . n-1] 和一个确定的数判断能否使数组 a[1. . n-1] 中任意几个元素之和等于 m - a[n]。

(2) 不取 a[n] ：

则此时问题转化为：对于一个已确定的数组 a[1. . n-1] 和一个确定的数 m ,判断能否使 数组 a[1.. n—1] 中任意几个元素之和等于 m 。

若用函数 sum(n,m) 表示能否从数组 a[1. . n] 中取任意数使其和为 m ，只要 sum(n-1, m-a[n]) 和 sum(n-1 ,m) 当中有一个值为真，则 sum(n,m) 为真，否则为假。因此，可以用 

递归来解此题。

递归终止条件为：if (a[n] == m) sum = true； else if (n == 1) sum = false；

程序如下：

```
#include<stdio.h>
int a[100],n,m;
bool flag;
void sum(int ,int );
int main(){
	int n;
	scanf("%d",&n);
	flag = false;
	sum(n,m);
	if(flag) printf("YES");
	else printf("NO");
	return 0;
}
void sum(int n,int m){
	if(a[n] == m) flag = true;
	else if(n == 1) return;
	else{
		sum(n - 1,m - a[n]);
		sum(n - 1,m);
	}
}
```

简单地说，递归算法的本质就是自己调用自己，用调用自己的方法去处理问题，可使解 决问题变得简洁明了。

（1）递归程序在执行过程中，一般具有如下模式：

① 将调用程序的返回地址、相应的调用前的变量都保存在系统堆栈中；

② 执行被调用的函数；

③ 若满足退岀递归的条件，则退出递归，并从栈顶上弹回返回地址、取回保存起来的变量值，继续沿着返回地址，向下执行程序；

④ 否则继续递归调用，只是递归调用的参数发生变化：增加一个量或减少一个量，重复执行直到递归调用结束。

（2）能够用递归算法解决的问题，一般满足如下要求：

① 需要求解的问题可以化为子问题求解，其子问题的求解方法与原问题相同，只是规模上的增加或减少；

② 递归调用的次数是有限的；必须有递归结束的条件(称为递归边界)。

<div STYLE="page-break-after: always;"></div>

# 18.结构体

在实际问题中，一组数据往往具有不同的数据类型。例如，人口大普查时，我们需要记 录每一位公民的姓名、年龄、性别、住址、身份证号码。这些信息分别要用整型、字符型、字符串型来记录。为了解决问题，c语言给出了另一种构造数据类型——“结构体”，它在数 据存储方面相当于其他高级语言中的记录，但它有着面向对象的优势。

### 结构体的定义和操作

(1)定义结构体及结构体变量

结构体变量的定义有两种形式：

① 定义结构体类型的时候同时定义变量

```
struct 结构体类型名{   //struct 是关键字
	成员表;			//可以有多个成员变量
	成员函数;			//可以有多个成员函数也可以没有
}结构体变量表;		//可以同时定义多个结构体变量,用 ","隔开
```

例如：

```
struct Student{  //定义一个类型名叫 Student 的 struct 类型
	int Math;
	int Chinese;
	int English;
}a[110];			//同时定义了 a 数组变量
```

②先定义结构体在定义结构体变量

```
struct 结构体类型名{   //struct 是关键字
	成员表;			//可以有多个成员变量
	成员函数;			//可以有多个成员函数也可以没有
};		//可以同时定义多个结构体变量,用 ","隔开
结构体名  结构体变量表;
```

例如：

```
struct Student{  //定义一个类型名叫 Student 的 struct 类型
	int Math;
	int Chinese;
	int English;
};			//同时定义了 a 数组变量
Student a[110];
```

在定义结构体变量时注意，结构体变量名和结构体名不能相同。在定义结构体时，系统对其不分配实际内存。只有定义结构体变量时，系统才为其分配内存。

### 结构体变量的特点

（1）结构体变量可以整体操作，例如：

`swap(a[i],a[j]);`

（2）结构体变量的成员访问也很方便、清晰，例如：

`scanf("%d",&a[i].Math);`

（3）结构体变量的初始化和数组的初始化类似，例如：

`Student s = {123,99,12};`

### 成员调用

结构体变量与各个成员之间引用的一般形式为：

`结构体变量名.成员名`

对于上面定义的结构体变量，我们可以这样操作： `scanf("%d",&a[i].Math)`；	//—般情况下不能写 `scanf("%d",&a[i]);`

`a[i]. total = a[i]. chinese+a[i]. math`； //就像用整型变量一样 实际上结构体成员的操作与该成员类型所具有的操作是一致的。

成员运算符“.”在存取成员数值时使用，其优先级最高，并具有左结合性。在处理 包含结构体的结构体时，可记作：

`strua. strub. membb`

这说明结构体变量 strua 有结构体成员 strub ；结构体变量 strub 有成员 membb 。

### 成员函数调用

结构体成员函数调用的一般形式为：

`结构体变量名.成员函数`

结构体成员函数默认将结构体变量作为引用参数。

# 19.指针

指针是 C 语言中广泛使用的一种数据类型，运用指针编程是 C 语言最主要风格 之一。利用指针变量可以表示各种数据结构，能很方便地使用数组和字符串，并能像汇编 言一样处理内存地址，从而编出精炼而高效的程序，指针极大地丰富了 C 语言的功能。 学习指针是学习 C 语言最重要的一环，能否正确理解和使用指针是我们是否掌握 C 语言的一个标志。同时，指针也是 C 语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程、多上机调试，只要做到这些，指针也是不难掌握的。

## 19.1指针变量

### 指针变量的定义、赋值

在使用指针之前要先定义指针，对指针变量的类型说明，一般形式为：

`类型说明符 *变量名；`

其中，`*` 表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示该指针变量所指向的变量的数据类型。先通过例子看看指针与普通的变量有什么不同。

**1.** 普通变量定义

`int a = 3;`

定义了变量 a，是 int 型的，值为 30 内存中有一块内存空间是放 a 的值，对 a 的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放 3 的地址可以用取地址操作符 “&” 对 a 运算得到：&a。

**2.** 指针变量定义

`int *p = NULL;`

定义了一个指针变量 P，P 指向一个内存空间，里面存放的是一个**内存地址**。现在赋值为NULL（其实就是 0 ,表示特殊的空地址）。

**3.** 给指针变量 p 赋值

P= &a；

即把 a 变量的内存空间地址（比如：XXX）给了 p。显然，直接对 p 存取，操作的是地址。 通过这个地址间接地操作，才是整数 3  .如图。P的间接操作要使用指针操作符“ * ”, 即 *p 的值才是 30 设有指向整型变量的指针变量 P ，如要把整型变量 a 的地址赋予 p 可以 有以下两种方式：

![img](file:///C:\Users\Admin\AppData\Local\Temp\ksohtml1796\wps1.png) 



① 指针变量初始化的方法·

`int a; int * p = &a;`

② 赋值语句的方法

`int a; int * p; p=&a;`

不允许把一个数赋予指针变量，故如下的赋值是错误的：`int *p; p = 1000;`。被赋值的指针变量前不能再加 * 说明符，故如下的赋值也是错误的：`*p = &a;`。

### 指针的几个相关操作说明表

| 说明                                      | 样例                                 |
| ----------------------------------------- | ------------------------------------ |
| 指针定义：<br />类型说明符  *指针变量名； | int a = 10；<br />int  *p；          |
| 取地址运算符：                            | p = &a；                             |
| 间接运算符：*                             | * p = 20；                           |
| 指针变量直接存取的是内存地址              | printf("%d",p);  结果可能是：1234567 |
| 间接存取的才是储存类型的值                | printf("%d",*p)；结果是：20          |

指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋予具体的值，未经赋值的指针变量不能使用。如定义了 `int a; int *p = &a;`,则 *p 表示 p 指向的整型变量， 而 P 中存放的是变量 a 占用单元的起始地址，所以 *p 实际上访问了变量 a ,也就是说 *p 与 a等价。下面举一个简单的指针使用的例子：

**例1：**输入两个不同的数,通过指针对两个数进行相加和相乘，并输出。

```
#include<stdio.h>

int main(){

	int a,b,s,t,*pa,*pb;
	pa = &a,pb = &b;
	a = 10;
	b = 20;
	s = *pa + *pb;
	t = *pa * *pb;
	printf("a = %d,b = %d\n",*pa,*pb);
	printf("s = %d,t = %d",s,t);
}
```

输出：a = 10,b = 20

s = 30,t = 200

### 指针的引用与运算

一般的，我们可以这样看指针 (int * p) 与普通变量 (int a) 的对应关系:

 

|     p      |    &a     |
| :--------: | :-------: |
|   ***p**   |   **a**   |
| ***p = 3** | **a = 3** |

下面介绍指针的一些运算。

#### 指针变量的初始化

指针的几个初始化操作说明表

|      |         方法         |              说明              |
| ---- | :------------------: | :----------------------------: |
| 1    |   int *p = NULL；    |  NULL是特殊的地址0，叫零指针   |
| 2    | int a；int *p = &a； |      P 初始化为 a 的地址       |
| 3    | int *p = malloc(x)； | 申请一个空间给 P，*P内容不确定 |

要强调的是，对于定义的局部指针变量，其内容(地址)是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所以编程中指针变量要保证先初始化或赋值，给予正确的地址再使用。

#### 指针的 +、- 运算

指针变量的内容是内存地址.它有两个常用的运算：+、-，这两个运算一般都是配合数组操作的。

**例1：**输入N个整数，使用指针变量访问输出。

```
include<stdio.h>
int a[101],n;
int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
    	scanf("%d",&a[i]);
    }
    int *p = a[i];
    for(int i = 1; i <= n; i++){
    	printf("%d",*p);
    	p++; //p指向下一个数，详见说明
    }
    return 0；
}
```

输入：4

2 1 6 0

输出：2 1 6 0

【说明】“p+ + ”的意思是 “广义的加 1 ”，不是 P 的值(地址)加1,而是根据类型 int 增加 sizeof (int)，也就是增加当前代表元素的数据大小 ，即刚好 “跳过” 一个整数的空间，达到下一个整数。

类似的：

① “P— ”就是向前 “跳过” 一个整数的空间，达到前一个整数。

②  (p + 3) 就是指向后面第 3 个整数的地址。

#### 无类型指针

有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定 义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的 类型。

**例2：**无类型指针运用举例。

```
#include<stdio.h>
int a = 10；
double b = 3.5;

void *p;

int main(){
	p = &a; //p的地址赋值
	printf("%d ",*(int *)p); //必须明确p指向的空间的数据类型，详见说明
	p = &b;
	printf("%lf",*(double *)p);
	return 0；

}
```

输出：10 3.5

【说明】必须明确 P 指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。

如果把 因为 int * 是 4个字节，char * 是一个字节，所以他们对于首地址往后取多少个位会不同，最后产生的值会不同。

如果把 *(double *)p，改成 *(long long *)p，虽然字节数一样，但是转化方式不同，结果会输出：4615063718147915776。

#### 多重指针

既然指针是指向其他类型的，指针本身也是一种类型。

C 语言允许递归地指针指向指针的指针——多重指针。

**例1：** 双重指针运用举例。

```
#include<stdio.h>
int a=10;
int *p;
int **pp;	//定义双重指针
int main(){
	p = &a;	//将p指向a
	pp = &p;	//将 PP 指向 P
	printf(”%d = %d = %d\n ",a, *p, **pp);
	// **pp通过2次间接访问了 a的变量的值10
    return 0;
}
```

输出 10 = 10 = 10

【说明】多重指针除了可以多次“间接”访问数据。OI 上主要的应用是动态的多维数组，这个强大的功能将在后面专门介绍。

## 19.2指针与数组

### 指针与数组的关系

指向数组的指针变量称为数组指针变量。一个数组是一块连续的内存单元组成的，数组名就是这块连续内存单元的首地址。一个数组元素的首地址就是指它所占有的几个内存单元的首地址。一个指针变量既可以指向一个数组，也可以指向一个数组元素，可把数组名或第一个元素的地址赋予它。如要使指针变量指向第 i号元素，可以把 i 元素的首地址赋予它，或把数组名加 i 赋予它。

设有数组 a ,指向 a 的指针变量为 pa ，则有以下关系：pa、a、&a[0]均指向同一单元，是数组 a 的首地址，也是 0 号元素 a[0] 的首地址。pa +1、a +1、&a[1] 均指向 1 号元素a[1]。类推可知 pa + i、a + i、&a[i] 指向 i 号元素 a[i] 。pa 是变量，而 a ,  &a [i] 是常量，在编程时应予以注意。

大家必须知道，数组就像一栋楼，由这些元素组成，元素是单个的，数组是整个的，&a 和 a 代表的意义完全不同，虽然他们的地址相同。

a 代表的是 0 号元素的首地址，所以它代表的是单个元素，&a 代表的是数组的收地，所以它代表的是整个，a + 1 会跳过当前元素，&a + 1 会跳过当前数组。

### 指向数组的指针

数组指针变量说明的一般形式为：

`类型说明符 *指针变量名`

其中类型说明符表示所指数组的类型，从一般形式可以看出，指向数组的指针变量和指 向普通变量的指针变量的说明是相同的。

引入指针变量后，就可以用两种方法访问数组元素了，

例如定义了 `int a[5]; int *pa = a;`

第一种方法为下标法，即用 pa[i] 形式访问 a 的数组元素。

第二种方法为指针法，即采用 * (pa + i) 形式，用间接访问的方法来访问数组元素。

**例1：**scanf 使用数组名，用数组名或指针访问数组。

```
#include<stdio.h>
int main(){
    int a[5],i, *pa = a；	〃定义整型数组和指针，* pa = a可以在下一行pa = a；
    for (i = 0; i < 5; i++){
    	scanf("%d",a + i); //可写成 pa + i 和 &a[i]
    }
    for(int i = 0; i < 5; i++){
    	printf("a[%d] = %d\n",i, *(a + i)); //指针访问数组,可以写成 *(pa + i) 或者 pa[i] 或者 a[i]
    }
    return 0；
}
```

输出：

a[0] = 1

a[1] = 2

a[2] = 3

a[3] = 4

a[4] = 5

【说明】

①直接那 a 当指针用，a 指向数组的开始元素，a + i 是执行数组的第 i 个元素的指针

②指针变量 pa 是变量，可以变得，但数组 a 是静态的变量名，不可变，只能当做常量指针用。例如：pa = pa + 2；是合法的，a = a + 2；是非法的

③最早在使用标准输入 scanf 时就使用了指针技术，读入一个变量时要加取地址运算符 "&”传递给 scanf  一个指针。对于数组，可以直接用数组名当指针。

### 指针也可以看出数组名

指针可以动态申请空间，如果一次申请多个变量空间，系统给的地址是连续的，就可以 当成数组使用，这就是传说中的动态数组的一种。

**例1：**动态数组，计算前缀和数组。 b 是数组 a 的前缀和的数组定义：

b[i] = a[1] +a[2] + .. + a[i]，即 b[i] 是 a 的前 i 个元素之和

```
#include<stdio.h>
#include<malloc.h>
int main(){
	int n;
	int *a;
	a = (int *)malloc(sizeof (int) * n);
	a[0] = 0;
	for(int i = 1; i <= n; i++){
		scanf("%d",&a[i]);
		a[i] += a[i - 1];
		printf("%d ",a[i]);
	}
	free(p);
	return 0;
}
```

输入： 5 1 2 3 4 5

输出：1 3 6 10 15

【说明】上述代码用到了 malloc 函数，此函数就是用来向空间申请一段连续的内存用的，申请出来的内存是属于 (void *) 无类型指针类型的首地址，所以我们要强制转换成 (int *) 整形指针类型，把地址赋值给 a ，这样 a 就可以使用这一段代码。free 函数是用来释放这段空间的，我们自己申请的空间系统是不会主动帮我们回收的，需要我们手动释放，否则会造成内存泄漏！

## 19.3指针与字符串

### 字符串的表示形式

在C语言中，我们可以用两种方式访问字符串。

(1) 用字符数组存放一个字符串，然后输出该字符串。

```
int main(){
	char str[] = " I love China!";
	printf("%s\n ", str);
}
```

(2) 用字符指针指向一个字符串。可以不定义字符数组，而定义一个字符指针。用字符指针指向字符串中的字符。

```
int main(){
	char *str = " I love China!";
	printf("%s\n ”, str);
}
```

在这里，我们没有定义字符数组，而是在程序中定义了一个字符指针变量 str ,用字符串 常量 "I Love China!" 对它进行初始化。C 语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串常量。对字符指针变量初始化，实际上是把字符串第 1 个元素的地址(即存放字符串的字符数组的首元素地址)赋给 str 。有人认为 str 是一 个字符串变量，以为在定义时把 "I love China!” 这几个字符赋给该字符串变量是不对的。

实际上，`char * str=" I love China!`

等价于：` char * str; str= "I love China!";`

可以看到，str 被定义为一个指针变量，指向字符型数据，请注意它只是指向了一个字符变量或其他字符类型数据，不能同时指向多个字符数据，更不是把 "I Love China!” 这些字符存放到 str 中(指针变量只能存放地址)。只是把 "i Love China! " 的第一个字符的地址赋给指针变量 str 。

在输出时，要用：printf("％s\n", str)；

其中“％s”是输岀字符串时所用的格式符，在输出项中给出字符指针变量名，则系统先输岀它所指向的一个字符数据，然后自动使 str 加 1 ,使之指向下一个字符，然后再输出一个字符……如此直到遇到字符串结束标志 “\0” 为止。

**注意：可以通过字符数组名或者字符指针变量输出一个字符串。而对一个数值型数组， 是不能企图用数组名输出它的全部元素的。**

例如：

```
int i[10];
printf("%d\n”, i);
```

这样是不行的，只能逐个输出。显然％s，可以对一个字符串进行整体的输入和输出。

## 19.4指针与函数

### 指针作为函数参数

指针可以作为函数的参数。在函数章节中，我们把数字作为参数传入函数中，实际上就是利用了传递指针(即传递数组的首地址)的方法。通过首地址，我们可以访问数组中的任何一个元素。

对于指向其他类型变量的指针，我们可以用同样的方式处理。

例如，我们编写如下一个函数，用于将两个整型变量的值交换。

```
void swap(int * x,int * y){
	int t= * x;
	* x= * y;
	* y = t;
}
```

这时，我们在其他函数中可以使用这个函数：

```
int a = 5, b = 3 ;
swap(&a, &b);
printf("a= %d,b= %d",a,b);
```

输出：a = 3,b = 5

在这个过程中，我们先将 a 和 b 的地址传给函数，然后在函数中通过地址得到变量 a 和 b 的值，并且对它们进行修改。当退出函数时，a 和 b 的值就已经交换了。

这里有一点值得我们注意。看如下这个过程：

```
void swap(int x,int y){
    int t= x;
    x=y;
    y=t;
}
```

我们调用了 swap(a,b)；然而这个函数没有起作用，没有将 a 和 b 的值互换。

为什么呢？因为这里在传入变量 a 和 b 的时候，是将 a 的值赋值给函数中的形参 x ，将 b 赋值给形参 y 。这里接下来的操作就完全与 a 和 b 无关了，函数将变量 x 和 y 的值互换， 然后退出函数。这里没有像上面例子那样传入指针，所以无法对传进来的变量进行修改。

将指针传入函数与将变量传入函数的区别在于：前者是通过指针来使用或修改传入的变量；而后者是将传入的变量的值赋给新的变量，函数对新的变量进行操作。

同理，对 scanf 函数而言，读取变量的时候我们要在变量之前加&运算符，即将指针传入函数。这是由于 scanf 函数通过指针将读取的值返回给引用的变量，没有 & ,就无法进行正常的读取操作。

**例1：**	编写一个函数，将三个整型变量排序，并将三者中的最小值赋给第一个变量，次小值赋给第二个变量，最大值赋给第三个变量。

```
#include<stdio.h>
void swap(int * x,int * y){
	int t= * x;
	* x= * y;
	* y=t;
}
void sort(int * x,int * y,int * z){
	if ( * x> * y) swap(x,y);
	if ( * x> * z) swap(x,z)
	if ( * y> * z) swap(y,z);
}
int main(){
    int a,b,c;
    scanf("%d%d%d", &a, &b, &c);
    sort ( & a, & b, & c)；
    printf("%d %d %d",a,b,c)；
    return 0；
}
```

输入：2 3 1

输出：1 2 3

### 函数返回指针

一个函数可以返回整数值、字符值、实型值等，也可以返回指针联系的数据(即地址)。

返回指针值的函数的一般定义形式为：

`类型名 *函数名(参数列表);`

例如：

`int * a(int a,int b)`

a 是函数名，调用它后得到一个指向整型数据的指针(地址)。x 和 y 是函数 a 的形参， 为整型。

注意：在 *a 的两侧没有括号；在 a 的两侧分别为 * 运算符和 () 运算符，由 于 () 的优先级高于 * ，因此 a 先于 () 结合。在函数前面有一个 * ，表示此函数是返回指针类型的函数。最前面的 int 表示返回的指针指向整型变量。对初学 C 语言的人来说，这种定义形式可能不太习惯，容易弄错，用时要十分小心。

**例1：**编写一个函数，用于在一个包含 N 个整数的数组中找到第一个质数，若有则返回函数的地址；否则返回NULL（空指针）。

程序如下：

```
#include<stdio.h>
#include<math.h>
int n,a[10001];
bool isprime(int n){
	if(n < 2) return false;
	if(n == 2) return true;
	for(int i = 2; i <= sqrt(n); i++){
		if(n % i == 0) return false;
	}
	return true;
}
int * find(){
	for(int i = 1; i <= n; i++){
		if(isprime(a[i])) return &a[i];
	}
	return NULL;
}
int main(){
	scanf("%d",&n);
	for(int i = 1; i <= n; i++){
		scanf("%d",a + i);
	}
	int *p = find();
	if(p != NULL) printf("%d\n%d\n",p,*p);
	else printf("cant't find!");
	return 0;
}
```

输入：7 1 6 9 2 3 4 5

输出：(可能是)123456  2

### 函数指针和函数指针数组

一个指针变量通过指向不同的整数变量的地址，就可以对其他的变量操作。

程序中不仅数据是存放在内存空间中，代码也同样存放在内存空间里。具体讲 C 语言的函数也保存在内存中，函数的入口地址也同样可以用指针访问。

另一方面，有些函数在编写时对要调用的辅助函数尚未确定，在执行时才能根据情况为 其传递辅助函数的地址。比如 sort 函数的用：“sort(a,a+n,cmp)；”其中的比较函数 cmp 是我们根据需要转给 sort 的(也可能是 cmp1，cmp2 等)，其实就是传递了函数指针。

下面我们来看一个具体例子。

**例1：**使用函数指针调用函数示例。

```
#include<stdio.h>
int t(int a){
	return a;
}
int main(){
	printf("%d",t); //显示函数地址
	int (*p)(int a); //定义函数指针变量 p
	p = t;
	printf("%d %d",p(5),(*p)(10));
	//p(5)是C++的写法，(*p)(10)是C语言的做法。
	return 0；
}
```

输出：

1

5 10

函数指针的基本操作有3个：

(1) 声明函数指针。

声明要指定函数的返回类型以及函数的参数列表，和函数原型差不多。

例如，函数的原型是：`int test(int);`

相应的指针声明就是：`int (*fp)(int);`

要注意的是，不能写成：`int *fp(int);` 

这样计算机编译程序会处理成声明一个 fp(int) 的函数，返回类型是int *。

(2) 获取函数的地址。

获取函数的地址很简单，只要使用函数名即可，例如，fp = test；

这表明函数名和数组名一样，可以看做是指针。

(3) 使用函数指针来调用函数。

类似普通变量指针，可以用 (*fp) 来间接调用指向的函数。但 C 也允许像使用函数名一样使用 fp ,虽然有争议，但 C++ 确实是支持了。

函数指针还有另一种结合typedef的声明方式，如例 X 所示。

 **例2：**使用typedef定义函数指针示例。

```
#include<stdio.h>
int sum(int a,int b){
	return a+b;
}

typedef int ( * LP) (int,int); //定义了一个函数指针变量类型LP

int main(){
	Lp p = sum;			//定义了一个LP类型的函数指针LP，并赋值为sum
	printf("%d",(*p)(2,5)); 	//使用p来调用函数，实参为2和6，调用sum函数，输出返回值7
	return 0;
}
```

输出：7

在软件开发编程中，函数指针的一个广泛应用是菜单功能函数的调用。通常选择菜单 的某个选项都会调用相应的功能函数，并且有些软件的菜单会根据情况发生变化(上下文敏 感)。如果使用swith/case或if语句处理起来会比较复杂、冗长，不利于代码的维护，可以考 虑使用函数指针数组方便灵活地实现。

**例3：**使用函数指针数组，模拟菜单功能实现方法示例。

```
#include<stdio.h>
void tl() { printf("test1");}
void t2() { printf("test2");}
void t3() { printf("test3");}
void t4() { printf("test4");}
void t5() { printf("test5");}
typedef void( * LP)();	//定义了一个函数指针变量类型LP
int main(){
    LP a[]={tl,t2,t3,t4,t5}; //定义了一个LP类型的函数指针数组a,并初始化 int x;
    scanf("%d",&x);
    a[x]();	//使用a[x]()来调用选择的函数
    return 0；
}
```

输入：2

输出：test3

## 19.5结构体指针

### 结构体指针的定义与使用

当一个指针变量用来指向一个结构体变量时，称之为结构体指针变量。

结构体指针变量的值是所指向的结构体变量的起始地址。通过结构体指针即可访问该结构体变量，这与数组指针和函数指针的情况是相同的。

结构体指针变量定义的一般形式：

`结构体名 *结构体指针变量名`

当然也可以在定义结构体的同时定义这个结构体指针变量。

例如：（定义一个结构体（类型为自己定义的student）指针变量P）

```
struct student{
	char name[20];
	char sex;
	float score;
} * P;
```

也可写成

```
struct student{
	char name[20];
	char sex;
	float score;
};
student * p;
```

与前面讨论的各类指针变量相同，结构体指针变量也必须要赋值后才能使用。赋值是 把结构体变量的首地址赋予该指针变量，不能把结构名赋予该指针变量。

例如：如果 p 是被定义为 student 类型的结构体指针变量，boy 是被定义为 student 类型 的结构体变量，则：p = &boy 是正确的，而 p = &student 是错误的。

引用结构体指针变量指向的结构体变量的成员的方法如下：

①`指针名->成员名`

`(*指针名).成员名`

例如：

`(*p).score` 与` p->score` 是等价的。

**例1：**结构体指针运用举例。

```
#include<stdio.h>
struct student{
	char name[20];
	char sex;
	int score;
} s[3] = {{" xiaoming ",'f ',356},{" xiaoliang ",'f ',350},{" xiaohong ",'m ',0}};
int main(){
    student * p；
    printfC Name Sex Score\n ")；
    for (p = s; p < s + 3; p++){
    	printf("%s %c %d\n ”,p->name,p—>sex,p—>score);	
    }
    return 0
}
```

输出：

Name Sex Score

xiaoming f 356

xiaoliang f 350

xiaohong m 0

【说明】这里 p++ 起到移动指针的作用，随着 p 的变化，输出数组不同元素内容。

### 自引用结构

在一个结构体内部包含一个类型为该结构体本身的成员是否合法呢？

```
struct stu{ 
	char nae[20];
	int age,score;
	stu p;
}；
```

这种类型的自引用是非法的，因为成员 p 是另一个完整的结构，其内部还将包含它自己 的成员 p 这第 2 个成员又是一个完整的结构，它还将包含自己的成员 p 这样重复下去就永无止境了。这有点像永远不会终止的递归程序。但下面这个程序是合法的：

```
struct stu{
	char name[20];
	int age,score;
	stu *p;
};
```

这个声明和前面那个声明的区别在于 p 现在是一个指针而不是结构体。编译器在结构体的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的。

当一个结构体中有一个或是多个成员是指针，它们所指向的类型就是本结构体类型时， 通常这种结构体称为“引用自身的结构体”，即“自引用结构”。这种自引用结构是实现其他一些结构的基础。

自引用结构在动态数据结构中有重要作用，甚至可以说，自引用结构是 C/C+ +语言实现动态数据结构的基石。包括动态的链表、堆、栈、树，无不是自引用结构的具体实现。

<div STYLE="page-break-after: always;"></div>

# 20.剩余一些关键字

C 语言关键字如下：

| asm           | do           | if               | return      | typedef  |
| ------------- | ------------ | ---------------- | ----------- | -------- |
| auto（c++14） | double       | inline           | short       | typeid   |
| bool          | dynamic_cast | int              | signed      | typename |
| break         | else         | long             | sizeof      | union    |
| case          | enum         | mutable          | static      | unsigned |
| catch         | explicit     | namespace        | static_cast | using    |
| char          | export       | new              | struct      | virtual  |
| class         | extern       | operator         | switch      | void     |
| const         | false        | private          | template    | volatile |
| const_cast    | float        | protected        | this        | wchar_t  |
| continue      | for          | public           | throw       | while    |
| default       | friend       | register         | true        |          |
| delete        | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用 C 得关键字，否则会产生歧义。`



## 20.1 define宏定义

宏是在程序运行前的一个准备工作

### 无参宏

一种最简单的宏的形式如下：

 ` #define   宏名   替换文本 `每个#define行（即逻辑行）由三部分组成：第一部分是指令 #define 自身，“#”表示这是一条预处理命令，“define”为宏命令。第二部分为宏（macro），一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则。“替换文本”可以是任意常数、表达式、字符串等。在预处理工作过程中，代码中所有出现的“宏名”，都会被“替换文本”替换。这个替换的过程被称为“宏代换”或“宏展开”（macro expansion）。“宏代换”是由预处理程序自动完成的。在C语言中，“宏”分为两种：无参数 和 有参数。

无参宏是指宏名之后不带参数，上面最简单的宏就是无参宏。

```c
#define M 5                // 宏定义
#define PI 3.14            //宏定义
int a[M];                  // 会被替换为： int a[5];
int b = M;                 // 会被替换为： int b = 5;
printf("PI = %.2f\n", PI); // 输出结果为： PI = 3.14
```

注意宏不是语句，结尾不需要加 “;”，否则会被替换进程序中，如：

```c
#define N 10;               // 宏定义
int c[N];                   // 会被替换为： int c[10;]; 
//error:… main.c:133:11: Expected ']'
```

如果要写宏不止一行，则在结尾加反斜线符号使得多行能连接上，如：

```c
#define HELLO "hello \
the world"
```

注意第二行要对齐，否则，如：

```c
#define HELLO "hello the wo\
  rld"
printf("HELLO is %s\n", HELLO);
//输出结果为： HELLO is hello the wo  rld 
```

也就是行与行之间的空格也会被作为替换文本的一部分

而且由这个例子也可以看出：宏名如果出现在源程序中的“”内，则不会被当做宏来进行宏代换。

宏可以嵌套，但不参与运算：

```c
#define M 5                 // 宏定义
#define MM M * M            // 宏的嵌套
printf("MM = %d\n", MM);    // MM 被替换为: MM = M * M, 然后又变成 MM = 5 * 5
```

### **有参宏**

![img](https://pic3.zhimg.com/v2-7ff4fddbda10b9e006c707fe1812d41e_r.jpg)

宏调用：

宏名（实参表）；

printf(“MEAN = %d\n”, MEAN(7, 9)); // 输出结果： MEAN = 8

和函数类似，在宏定义中的参数成为形式参数，在宏调用中的参数成为实际参数。

而且和无参宏不同的一点是，有参宏在调用中，不仅要进行宏展开，而且还要用实参去替换形参。如：

```c
#define M 5                          //无参宏
#define COUNT(M) M * M               //有参宏
printf("COUNT = %d\n", COUNT(10));   // 替换为： COUNT(10) = 10 * 10
                                     // 输出结果： COUNT = 100
```

这看上去用法与函数调用类似，但实际上是有很大差别的。如：

```c
#define COUNT(M) M * M               //定义有参宏
int x = 6;
printf("COUNT = %d\n", COUNT(x + 1));// 输出结果： COUNT = 13
printf("COUNT = %d\n", COUNT(++x));  // 输出结果： COUNT = 56    
```

这两个结果和调用函数的方法的结果差别很大，因为如果是像函数那样的话，COUNT(x + 1) 应该相当于 COUNT(7) ，结果应该是 7 * 7 = 49，但输出结果却是21。原因在于，预处理器不进行技术，只是进行字符串替换，而且也不会自动加上括号（），所以 COUNT(x + 1) 被替换为 COUNT(x + 1 * x + 1) ，代入 x = 6，即为 6 + 1 * 6 + 1 = 13。而解决办法则是：尽量用括号把整个替换文本及其中的每个参数括起来：

```c
#define COUNT(M) ((M) * (M))  
```

但即使用括号，也不能解决上面例子的最后一个情况，COUNT(++x) 被替换为 ++x * ++x，即为 7 * 8 = 56，而不是想要 7 * 7 = 49，解决办法最简单的是：不要在有参宏用使用到“++”、“–”等。

### 练习：

1. 以下代码输出什么？

   ```
   #define x 5 + 1
   printf("%d",x * x);
   ```

   ```
   #define x (5 + 1)
   printf("%d",x * x);
   ```

   ``` 
   #define add(x,y) x + y
   printf("%d\n",add(1,2));
   ```

## 20.2 typedef

typedef是在计算机编程语言中用来为**复杂的声明定义简单的别名**，它与宏定义有些差异。它本身是一种存储类的关键字，与 auto、extern、mutable、static、register 等关键字不能出现在同一个表达式中。

我们一般用来给我们的变量取别名例如：

```
typedef long long ll;
typedef double db;
ll a;db b;
```

当然你也可以使用宏定义

```
#define ll long long 
#define db double
```

## 20.3 const

const 是一个C语言（ANSI C）的关键字，具有着举足轻重的地位。它限定一个变量不允许被改变，产生静态作用。使用c onst 在一定程度上可以提高程序的安全性和可靠性。另外，在观看别人代码的时候，清晰理解 const 所起的作用，对理解对方的程序也有一定帮助。
使用方法：

```
const int a = 1000;
```

但是以下方法不行：

```
const int a;
a = 1000;//后面赋值就错误
```

常量常常用来定义全局变量

以下写法编译是过不了的，因为全局变量的数组大小只能用常量定义

```
#include<stdio.h>
int a = 100;
int b[a]; 
int main(){
	return 0;
}
```

以下正确

```
#include<stdio.h>
const int a = 100;
int b[a]; 
int main(){
	return 0;
}
```

当然常量也可以用来定义指针

```
int a = 10;
const int *p = &a; 
```

但是大家觉得以下的代码正确吗？

```
int a = 10;
const int *p = &a; 
a = 100;
printf("%d",*p);
```

我们发现编译成功了，并且*p的值输出了100

但是我们直接修改*p是不可以的，所以指针常量的值还是可能会改变的

**还有一个要注意的点**:你们觉得以下代码对吗？

```
int a = 1,b = 2;
const int *p = &a;
p = &b;
printf("%d\n",*p);
```

我们发现是可以编译的，并且成功输出了2

所以我们发现 const int *p; 仅仅是不能改变 *p的值，但是p指向的地址可以改变。

所以我们想要 *p和地址都不改变我们需要这样子写

```
int a = 1,b = 2;
const int * const p = &a;
p = &b;
printf("%d\n",*p);
```

