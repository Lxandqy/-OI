# C++进阶

## 运算符重载

1. 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，简化操作 让已有的运算符 适应不同的数据类型。
2. 运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，运算符重载是通过函数实现的，它本质上是函数重载。
3. **语法：**函数的名字由关键字operator及其紧跟的运算符组成 ，比如：重载+运算符 ==>operator+ 重载=号运算 ==>operator =
4. **注意：**重载运算符 不要更改 运算符的本质操作（+是数据的相加 不要重载成相减）。

### 重载的限制 

多数C++运算符都可以重载，重载的运算符不必是成员函数，但必须至少有一个操作数是用户定义的类型。

1. 重载后的运算符必须至少有 一 个操作数是用户定义的类型，防止用户为标准类型重载运算符。如：不能将减法运算符(-)重载为计算两个 double 值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行。

2. 使用运算符时不能违反运算符原来的句法规则。例如，不能将二元操作数求模运算符(%)重载成使用一个操作数：

   ```
   int x;Time shiva;
   %x;
   %shiva;，
   ```

   且不能修改运算符的优先级。

3. 不能创建新运算符。例如，不能定义operator **()函数来表示求幂。

4. 不能重载以下运算符
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/cf9901d5d9054043861aa8e8b6bd946e.png)

5. 可以重载以下运算符
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/83bfef19aa4145889dc575ccd0970c8b.png)
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c8bc1510e5e428e9d44a490c2c39294.png)

### 如何重载？

```
#include<iostream>

using namespace std;

struct node{
	int x,y;
	node operator + (node p){ //这是两个操作数的，自己本身加上另一个操作数
		node a;
		a.x = x + p.x;
		a.y = y + p.y;
		return a;
	}//相当于一个函数，只不过要写上operator 重载的符号，然后重载的规则
	
	node operator < (node p){
		if(x == p.x){
			if(y > p.y) return *this;
			else return p;
		}else if(x > p.x) return *this;
		else return p;
	}//注意：因为我们这个运算符是在类中写的，所以是通过对象调用的，那么this指针会占一个参数，而且是第一个参数，也就是说我们重载一个运算符，是在类中，而这个运算符是个单元运算符，那么参数列表就不用写东西了，是双元运算符，那么就需要传另一个参数进来
	friend node operator > (node a,node b){ //倘若是有前面加了friend的就写两个变量，因为使用了friend就不能使用this指针
		if(a.x > b.x) return a;
		else return b;
	}
};

int main(){
	
	node x,y,t;
	x.x = 1;
	x.y = 1;
	y.x = 2;
	y.y = 3;
	t.x = 5;
	t.y = 6;
	node s = x + y + t;
	printf("%d %d\n",s.x,s.y);
	
	s = x < y;
	printf("%d %d\n",s.x,s.y);
	
	s = x > y;
	printf("%d %d",s.x,s.y);
	return 0;
} 
```

### 重载的妙用

在我们算法竞赛中，重载符一般用来排序使用的，当我们使用sort函数给结构体排序的时候，倘若我们没有写第三方排序函数，他就会遵循我们结构体的 < 来排序，倘若我们重载了，他就会遵循重载后的排序。
倘若我们使用重载来给sort排序的时候，我们重载符号一定要遵循：返回值一定要为 bool 值，因为是制定这样返回到底是真是假的规则

```
#include<iostream>
#include<algorithm>

using namespace std;

struct node{
	int x,y;
	bool operator < (node p){ 
		return x < p.x;
	} 
	
}a[100];

int main(){
	
	a[1] = {4,2};
	a[2] = {2,3};
	sort(a + 1,a + 2 + 1); //x作为关键词，从小到大排序
	
	for(int i = 1; i <= 2; i++){
		printf("%d ",a[i].x);
	}

	return 0;
} 
```

# 进阶排序

## 归并排序:

归并排序：基于分治的思想
**算法步骤**:对于排序 1 ~ n我们可以先排序 1 ~ n / 2,n / 2 + 1 ~ n以此类推再合并
**稳定性**: 稳定
**复杂度**：$O(nlogn)$
**空间复杂度** : $O(n)$

```
void merge(int l, int r) { //先每一次细分一半，等这一半排序完之后在排序
  if (r - l <= 1) return; //区间长度为1的时候细分完成
  int mid = l + ((r - l) >> 1);
  merge(l, mid), merge(mid, r);
  for (int i = l, j = mid, k = l; k < r; ++k) {
    if (j == r || (i < mid && a[i] <= a[j]))
      tmp[k] = a[i++];
    else
      tmp[k] = a[j++]; 
  }
  for (int i = l; i < r; ++i) a[i] = tmp[i];
}

```

### 思考:能不能在交换途中求出逆序对个数？

```
//a数组是需要排序的数组，tmp数组是临时数组
void merge(int l, int r) {
  if (r - l <= 1) return;
  int mid = l + ((r - l) >> 1);
  merge(l, mid), merge(mid, r);
  for (int i = l, j = mid, k = l; k < r; ++k) {
    if (j == r || (i < mid && a[i] <= a[j]))
      tmp[k] = a[i++];
    else{
    	cnt += mid - i;
      	tmp[k] = a[j++];
    }
  }
  for (int i = l; i < r; ++i) a[i] = tmp[i];
}
```

## 快速排序

快速排序：一个基于分治思想的排序
**算法步骤**:在当前序列中确定一个基准数，使得当前序列相对有序。
**稳定性**:不稳定
**时间复杂度**:$O(nlogn)$ 最坏复杂度$ O(n^2)$  最坏复杂度举例: 1 2 3 4 5 6 7 8
**空间复杂度**:$O(n)$

```
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;

    int x = q[l + r >> 1], i = l - 1, j = r + 1; 
    while (i < j) {  //前面的 do防止死循环
        do i ++ ; while (q[i] < x); //找到第一个小于x的
        do j -- ; while (q[j] > x); //找到第一个大于x的
        if (i < j) swap(q[i], q[j]);//交换
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

快速排序优化:
1.通过 三数取中（即选取第一个、最后一个以及中间的元素中的中位数） 的方法来选择两个子序列的分界元素（即比较基准）。这样可以避免极端数据（如升序序列或降序序列）带来的退化；
2.当序列较短时，使用 插入排序 的效率更高；
3.每趟排序后，将与分界元素相等的元素聚集在分界元素周围，这样可以避免极端数据（如序列中大部分元素都相等）带来的退化。

```
template <typename T>
// arr 为需要被排序的数组，len 为数组长度
void quick_sort(T arr[], const int len) {
  if (len <= 1) return;
  // 随机选择基准（pivot）
  const T pivot = arr[rand() % len];
  // i：当前操作的元素
  // j：第一个等于 pivot 的元素
  // k：第一个大于 pivot 的元素
  int i = 0, j = 0, k = len;
  // 完成一趟三路快排，将序列分为：
  // 小于 pivot 的元素｜ 等于 pivot 的元素 ｜ 大于 pivot 的元素
  // 每次把大于pivot的数从最后边开始放，
  while (i < k) { //如果当前操作数 >= k 因为k是第一个大于pivot的数，所以没必要比较，所以j ~ i的数一定都是pivot
    if (arr[i] < pivot) //如果当前的数比pivot小的话，我们就把他与第一个等于pivot的交换。
      swap(arr[i++], arr[j++]); //交换后我们明确 1~j都是小于pivot的数，j + 1~i是等于pivot的数
    else if (pivot < arr[i]) //如果当前操作数大于pivot我们就与k位置交换
      swap(arr[i], arr[--k]); //交换后我们并不知道交换过来的数与pivot的关系
    else  //如果相等直接++
      i++;
  }
  // 递归完成对于两个子序列的快速排序
  quick_sort(arr, j);
  quick_sort(arr + k, len - k);
}

```

### 思考:能不能在交换途中求出逆序对个数？

### 求第k大值

**基于快速排序的思想**
**算法步骤**：每次确定一个基准点，小于基准点的放在一个数组里，元素个数为x，等于基准点的放在一个数组里，元素个数为y，大于基准点的放在一个数组里，元素个数为z，若k大于 x + y那么 一定在x + y + 1 ~ z里面，否则一定在1 ~ x + y里面
**算法复杂度**: 最优复杂度$O(n)$，最坏复杂度$O(n^2)$
**空间复杂度**: $O(nlogn)$

```
template <typename T>
T find_kth_element(T arr[], int rk, const int len) {
  if (len <= 1) return arr[0];
  // 随机选择基准（pivot）
  const T pivot = arr[rand() % len];
  // i：当前操作的元素
  // j：第一个等于 pivot 的元素
  // k：第一个大于 pivot 的元素
  int i = 0, j = 0, k = len;
  // 完成一趟三路快排，将序列分为：
  // 小于 pivot 的元素 ｜ 等于 pivot 的元素 ｜ 大于 pivot 的元素
  // 每次把大于pivot的数从最后边开始放，
  while (i < k) { //如果当前操作数 >= k 因为k是第一个大于pivot的数，所以没必要比较，所以j ~ i的数一定都是pivot
    if (arr[i] < pivot) //如果当前的数比pivot小的话，我们就把他与第一个等于pivot的交换。
      swap(arr[i++], arr[j++]); //交换后我们明确 1~j都是小于pivot的数，j + 1~i是等于pivot的数
    else if (pivot < arr[i]) //如果当前操作数大于pivot我们就与k位置交换
      swap(arr[i], arr[--k]); //交换后我们并不知道交换过来的数与pivot的关系
    else  //如果相等直接++
      i++;
  }
  if (rk < j) return find_kth_element(arr, rk, j); //如果排名 < j，那就往左边找
  else if (rk >= k) 
    return find_kth_element(arr + k, rk - k, len - k); //如果排名 >= k那么左半边都不看了，所以总排名 - k
  return pivot;
}

```



## 计数排序:

**计数排序**：一种线性的排序算法
**算法步骤:**对原数组$a$来说建立一个新的数组$b$，$b[i]$表示的是 $a$数组中元素大小为$i$的个数，随后再创建一个数组$c$，$c[i]$表示的是$ b[1] - b[i]$的和。那么$c[i] - c[i - 1]$就是 a数组中元素大小为$i$的个数，并且我们知道 这个数排序后的下标在$c[i - 1] + 1 - c[i]$
**稳定性**：稳定
**时间复杂度**: $O(n + w)$  //w是值域
**空间复杂度** $O(n + w)$

```
void counting_sort() {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i]];
  for (int i = 1; i <= w; ++i) cnt[i] += cnt[i - 1];
  for (int i = n; i >= 1; --i) b[cnt[a[i]]--] = a[i];
}

```

### 思考:能不能在交换途中求出逆序对个数？

## 基数排序

**定义**：基数排序是基于位来选择其他排序算法进行排序的
算法步骤:分别将位数设置第一个关键字，第二关键字..第k关键词，然后先排序第一关键字再排序第二关键字....
**空间复杂度** $O(n)$
**时间复杂度** $O(k/x * (n + pow(10,x))$ $k$是位数，$x$是几位为一组
**稳定性**:稳定

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 5e6 + 5;
int n, a[maxn], maxx, k;
vector<int> v[maxn], v2[maxn];
signed main(){
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		maxx = max(maxx, a[i]); //最大的数字有几位
	}
	while (maxx){
		k++;
		maxx /= 10;
	}  //k就是位数
	for (int i = 1; i <= n; i++){
		for (int j = k; j >= 1; j--){
			v[i].push_back((a[i] / (int)pow(10, j - 1)) % 10); //把我数字的每一位存到vector里
		}	
	}
	//v[1][1]代表第一个数字的第一位，v[1][2]代表第一个数字的第二位
	for (int j = k - 1; j >= 0; j--){
		int cnt[10] = {};
		for (int i = 1; i <= n; i++){ //对于每个数字当前关键字存下来
			cnt[v[i][j]]++;
		}
		for (int i = 1; i <= 10; i++){  //求前缀和
			cnt[i] += cnt[i - 1];  //cnt[i]记录的是 关键字为 1~i的一个个数，所以cnt[i] - cnt[i - 1]他就是 i的个数，那么i的关键字排序的后的结果一定是在 cnt[i - 1] + 1 ~ cnt[i]
		}
		for (int i = n; i >= 1; i--){  //把我排序后的数组放进去
			v2[cnt[v[i][j]]--] = v[i];
		}
		for (int i = 1; i <= n; i++){
			v[i] = v2[i];
		}
	}
	for (int i = 1; i <= n; i++){
		for (int j = 0; j < v[i].size(); j++){
			cout << v[i][j];
		}
		cout << endl;
	}
	return 0;
}
```






### 思考:能不能在交换途中求出逆序对个数？

### 练习:

1. U248368 输入一个数n 和 n个整数,$a_1,a_2....,a_n$，将这些整数按照从小到大排序 n <= 5e6,$a_i$ <= 1e7

   

   

2. 51nod3236

   



## 桶排序

桶排序（英文：Bucket sort）是排序算法的一种，适用于待排序数据值域较大但分布比较均匀的情况，同样需要内置排序。
**算法步骤**:设置一个定量的数组当作空桶；遍历序列，并将元素一个个放到对应的桶中；对每个不是空的桶进行排序；从不是空的桶里把元素再放回原来的序列中。
**稳定性**:若内置函数是稳定的就是稳定的，一般使用插入排序
**空间复杂度**: $O(n)$
**时间复杂度**: $O(n + n^2/k + k)$

```
// C++ Version
const int N = 100010;

int n, w, a[N];
vector<int> bucket[N];

void insertion_sort(vector<int>& A) {
  for (int i = 1; i < A.size(); ++i) {
    int key = A[i];
    int j = i - 1;
    while (j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      --j;
    }
    A[j + 1] = key;
  }
}

void bucket_sort() {
  int bucket_size = w / n + 1;
  for (int i = 0; i < n; ++i) {
    bucket[i].clear();
  }
  for (int i = 1; i <= n; ++i) {
    bucket[a[i] / bucket_size].push_back(a[i]);
  }
  int p = 0;
  for (int i = 0; i < n; ++i) {
    insertion_sort(bucket[i]);
    for (int j = 0; j < bucket[i].size(); ++j) {
      a[++p] = bucket[i][j];
    }
  }
}
```

### 思考:能不能在交换途中求出逆序对个数？

## 希尔排序

希尔排序（英语：Shell sort），也称为缩小增量排序法，是 插入排序 的一种改进版本
由于插入排序的复杂度取决于序列的有序程度，所以希尔排序是先使得它相对有序，再进行最后的排序
**算法步骤**:排序对不相邻的记录进行比较和移动：

1. 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；
2. 对这些子序列进行插入排序；
3. 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 1。

**稳定性**:不稳定
**算法复杂度**: o(n^1.3)~o(n^2)

```
template <typename T>
void shell_sort(T array[], int length) {
  int h = 1;
  while (h < length / 3) {
    h = 3 * h + 1;
  }
  while (h >= 1) {
    for (int i = h; i < length; i++) {
      for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
        std::swap(array[j], array[j - h]);
      }
    }
    h = h / 3;
  }
}
```

### 思考:能不能在交换途中求出逆序对个数？

![1.png](https://cdn.acwing.com/media/article/image/2019/05/19/1130_0ce35b527a-1.png)

### 总结：交换不相邻的排序则为不稳定排序

# 进阶数据结构

## 堆

堆是一棵**完全二叉树**，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。

其中，如果父亲结点的值大于或等于孩子结点的值，那么称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值;如果父亲结点的值小于或等于孩子结点的值，那么称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。

以下都以小根堆为例子，给出一个序列 1， 5，7，3，2，4。小根堆可能就长这样。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230091918614.png" alt="image-20221230091918614" style="zoom:67%;" />
对于完全二叉树，我们是知道是可以用数组存储的，每个节点的编号从上到下从左到右依次增大，这样一个编号为$x$节点的左儿子编号是$x * 2$，右节点的编号是$x * 2 + 1$

### Down操作

堆里面最重要的两个操作一个是Down操作。Down操作可以在$O(logn)$的复杂度调整堆的结构。
比如我现在堆的样子长下面这样子
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230092309533.png" alt="image-20221230092309533" style="zoom: 67%;" />
它目前不满足我们小根堆的一个性质，所以我们要把 5 这个数字往底下放
那么 5 这个数字首先要和它的两个儿子 2，3做比较，如果我们把 5 和 3交换的话，如图
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230092443782.png" alt="image-20221230092443782" style="zoom:67%;" />
我们发现还是不满足堆的性质，所以我们一定要选择当前节点与最小的儿子节点进行交换。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230092616864.png" alt="image-20221230092616864" style="zoom:67%;" />
最后再拿 5 和 4进行交换即完成了我们的交换操作。
我们的Down操作也就是不停的拿父亲节点和两个子节点进行比较交换用的！

### Up操作

堆里最后一个重要操作也就是Up操作，大家通过名字就可以类比出来，Down是往下调整，Up就是往上调整。
假设现在的图长这样
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230093218725.png" alt="image-20221230093218725" style="zoom: 67%;" />
它并不满足小根堆的性质，我们需要把最下边的 1 往上调整。
1 只需要和 3做比较，因为 3 已经比 5 小了，所以如果 1 比 3 小的话，一定比 5 小。
交换后长这样
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230093554424.png" alt="image-20221230093554424" style="zoom:67%;" />
然后 1 再和 2做比较完成交换。

### 利用两大操作完成其他操作

1. 修改堆里面其中一个数字，我们只需要利用Up和Down就可以完成调整
2. 往堆里面增加一个数字，首先我们要满足他是一个完全二叉树，刚好我们是使用数组来存储的，所以我们直接往数组最后一个位置进行添加，添加完后我们再使用Up操作来调整堆的结构即可。
3. 删除堆里的元素。首先我们要满足他是一个完全二叉树，刚好我们是使用数组来存储的，倘若我们删除的元素在数组最后一个位置就好了，所以我们就交换最后一个元素和我们要删除的那个元素，然后交换后进行Up和Down操作就可以调整堆的结构
4. 求当前堆里面的最小值，我们直接拿到数组第一个位置即可

### 构建堆

其实最简单构建堆的方法就是，不断地插入，插入后进行Up操作，但是这样的时间复杂度是$O(nlogn)$。
这里要讲一个$O(n)$的做法。

```
//n代表堆的大小
//heap[] 代表堆里面的元素
for(int i = n / 2;i >= 1; i--) down(i);
```

为什么这样子写是$O(n)$的呢？
假如这个堆是一个满二叉树，他的节点数是$n$，那么它最后一层的节点数大约是$n / 2$倒数第二层的节点数大约是 $n / 4$。
<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230100406200.png" alt="image-20221230100406200" style="zoom:67%;" />

我们从倒数第二层开始一直到第一层往下Down，最后能完成树的结构调整。
对于倒数第二层来说往下Down一个点最多交换一次，那么所有点最多交换 $n / 4$次，对于倒数第三层来说往下一个点Down最多交换两次，那么所有点最多交换 $2 * n / 8$次，以此类推最终交换的次数为 $n / 4 + 2 * n / 8 + 3 * n / 16 + ... + x * n / 2^{x + 1}$
设 $S_n = n / 4 + 2 * n / 8 + 3 * n / 16 + ... + x * n / 2^{x + 1}$ 
那么$2S_n = $$n / 2 + 2 * n / 4 + 3 * n / 8 + .. + x *n / 2^x$
$2S_n - S_n = n / 2 + n / 4 + n / 8 + ... + n / 2^x - x * n / 2^{x + 1}$约等于 $n$
所以最终这样建堆的复杂度就是$O(n)$

## 并查集

### 概论

**定义：**
**并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。**

**主要构成：**
**并查集主要由一个整型数组pre[ ]和两个函数find( )、join( )构成。**
**数组 pre[ ] 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。**

**作用：**
**并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）**

### **并查集的现实意义**

故事引入：
话说在江湖中散落着各式各样的大侠，他们怀揣着各自的理想和信仰在江湖中奔波。或是追求武林至尊，或是远离红尘，或是居庙堂之高，或是处江湖之远。尽管大多数人都安分地在做自己，但总有些人会因为彼此的信仰不同而聚众斗殴。因此，江湖上常年乱作一团，纷纷扰扰。
这样长期的混战，难免会打错人，说不定一刀就把拥有和自己相同信仰的队友给杀了。这该如何是好呢？于是，那些有着相同信仰的人们便聚在一起，进而形成了各种各样的门派，比如我们所熟知的“华山派”、“峨嵋派”、“,崆峒派”、“少林寺”、“明教”……这样一来，那些有着相同信仰的人们便聚在一起成为了朋友。以后再遇到要打架的事时，就不会打错人了。

但是新的问题又来了，原本互不相识的两个人如何辨别是否共属同一门派呢?
这好办！我们可以先在门派中选举一个“大哥”作为话事人（也就是掌门人，或称教主等）。这样一来，每当要打架的时候，决斗双方先自报家门，说出自己所在门派的教主名称，如果名称相同，就说明是自己人，就不必自相残杀了，否则才能进行决斗。于是，教主下令将整个门派划分为三六九等，使得整个门派内部形成一个严格的等级制度（即树形结构）。教主就是根节点，下面分别是二级、三级、……、N级队员。每个人只需要记住自己的上级名称，以后遇到需要辨别敌友的情况时，只需要一层层往上询问（网上询问）就能知道是否是同道中人了。

![等级划分](https://img-blog.csdnimg.cn/20210222021354815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70)

数据结构的角度来看：
由于我们的重点是在关注两个人是否连通，因此他们具体是如何连通的，内部结构是怎样的，甚至根节点是哪个（即教主是谁），都不重要。所以并查集在初始化时，教主可以随意选择（就不必再搞什么武林大会了），只要能分清敌友关系就行。

备注：上面所说的“教主”在教材中被称为“代表元”。
即：用集合中的某个元素来代表这个集合，则该元素称为此集合的代表元。

### find( )函数的定义与实现

#### 故事引入：

子夜，小昭于骊山下快马送信，发现一头戴竹笠之人立于前方，其形似黑蝠，倒挂于树前，甚惧，正系拔剑之时，只听四周悠悠传来：“如此夜深，姑凉竟敢擅闯明教，何不下坐陪我喝上一盅？”。小昭听闻，后觉此人乃明教四大护法之一的青翼蝠王韦一笑，答道：“在下小昭，乃紫衫龙王之女”。蝠王轻惕，急问道：“尔等既为龙王之女，故同为明教中人。敢问阁下教主大名，若非本教中人，于明教之地肆意走动那可是死罪！”。小昭吓得赶紧打了个电话问龙王：“龙王啊，咱教主叫啥名字来着？”，龙王答道：“吾教主乃张无忌也！”，小昭遂答蝠王：“张无忌！”。蝠王听后，抱拳请礼以让之。
在上面的情境中，小昭向他的上级（紫衫龙王）请示教主名称，龙王在得到申请后也向他的上级（张无忌）请示教主名称，此时由于张无忌就是教主，因此他直接反馈给龙王教主名称是“张无忌”。同理，青翼蝠王也经历了这一请示过程。
在并查集中，用于查询各自的教主名字的函数就是我们的find()函数。find(x)的作用是用于查找某个人所在门派的教主，换言之就是用于对某个给定的点x，返回其所属集合的代表。

#### 实现：

首先我们需要定义一个数组：int pre[1000]; （数组长度依题意而定）。这个数组记录了每个人的上级是谁。这些人从0或1开始编号（依题意而定）。比如说pre[16]=6就表示16号的上级是6号。如果一个人的上级就是他自己，那说明他就是教主了，查找到此结束。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。
每个人都只认自己的上级。比如小昭只知道自己的上级是紫衫龙王。教主是谁？不认识！要想知道自己教主的名称，只能一级级查上去。因此你可以视find(x)这个函数就是找教主用的。
下面给出这个函数的具体实现：

```
int find(int x)					//查找x的教主{
	while(pre[x] != x)			//如果x的上级不是自己（则说明找到的人不是教主）
		x = pre[x];				//x继续找他的上级，直到找到教主为止
	return x;					//教主驾到~~~
}
```

### join( )函数的定义与实现

故事引入：
虚竹和周芷若是我个人非常喜欢的两个人物，他们的教主分别是玄慈方丈和灭绝师太，但是显然这两个人属于不同门派，但是我又不想看到他们打架。于是，我就去问了下玄慈和灭绝：“你看你们俩都没头发，要不就做朋友吧”。他们俩看在我的面子上同意了，这一同意非同小可，它直接换来了少林和峨眉的永世和平。

实现：
在上面的情景中，两个已存的不同门派就这样完成了合并。这么重大的变化，要如何实现？要改动多少地方？其实很简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先所有人员的教主就都变成了师太，于是下面的人们也就不会打起来了！反正我们关心的只是连通性，门派内部的结构不要紧的”。玄慈听后立刻就不乐意了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”。抗议无效，我安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个，join()函数的作用就是用来实现这个的。

join(x,y)的执行逻辑如下：
1、寻找 x 的代表元（即教主）；
2、寻找 y 的代表元（即教主）；
3、如果 x 和 y 不相等，则随便选一个人作为另一个人的上级，如此一来就完成了 x 和 y 的合并。
下面给出这个函数的具体实现：

```
void join(int x,int y)                     //我想让虚竹和周芷若做朋友
{
    int fx=find(x), fy=find(y);            //虚竹的老大是玄慈，芷若MM的老大是灭绝
    if(fx != fy)                           //玄慈和灭绝显然不是同一个人
        pre[fx]=fy;                        //方丈只好委委屈屈地当了师太的手下啦
}
```

###  路径压缩算法之一（优化find( )函数）

#### 问题引入：

前面介绍的 join(x,y) 实际上为我们提供了一个将不同节点进行合并的方法。通常情况下，我们可以结合着循环来将给定的大量数据合并成为若干个更大的集合（即并查集）。但是问题也随之产生，我们来看这段代码：

```
if(fx != fy)  
	pre[fx]=fy;
```

这里并没有明确谁是谁的前驱（上级）的规则，而是我直接指定后面的数据作为前面数据的前驱（上级）。那么这样就导致了最终的树状结构无法预计，即有可能是良好的 n 叉树，也有可能是单支树结构（一字长蛇形）。试想，如果最后真的形成单支树结构，那么它的效率就会及其低下（树的深度过深，那么查询过程就必然耗时）。
而我们最理想的情况就是所有人的直接上级都是教主，这样一来整个树的结构就只有两级，此时查询教主只需要一次。因此，这就产生了路径压缩算法。
设想这样一个场景：两个互不相识的大将夏侯惇和许褚碰面了，他们都互相看不惯，想揍对方。于是按照江湖规矩，先打电话问自己的上级：“你是不是教主？” 上级说：“我不是呀，我的上级是***，我帮你问一下。” 就这样两个人一路问下去，直到最终发现他们的教主都是曹操。具体结构如下：
![img](https://img-blog.csdnimg.cn/20210219181523922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70)

“失礼失礼，原来是自己人，在下军机处前将军夏侯惇!”
“幸会幸会，不打不相识嘛，在下军情处上将许褚！”
紧接着，两人便高高兴兴地手拉手喝酒去了。
“等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩：“还要做路径压缩！”
两人醒悟，夏侯惇赶紧打电话给他的上级郭嘉：“军师啊，我查过了，我们的教主都是曹丞相。不如我们直接拜在丞相手下吧，省得级别太低，以后找起来太麻烦。”郭嘉答道：“所言甚是” 。
许褚接着也打电话给刚才拜访过的荀彧，做了同样的事。于是此时，整个曹操阵营的结构如下所示：
![img](https://img-blog.csdnimg.cn/20210219181523911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70)

实现：
从上面的查询过程中不难看出，当从某个节点出发去寻找它的根节点时，我们会途径一系列的节点（比如上面的例子中，从夏侯惇→郭嘉→曹植→曹操），在这些节点中，除了根节点外（即曹操），其余所有节点（即夏侯惇、郭嘉、曹植）都需要更改直接前驱为曹操。
因此，基于这样的思路，我们可以通过递归的方法来逐层修改返回时的某个节点的直接前驱（即pre[x]的值）。简单说来就是将x到根节点路径上的所有点的pre（上级）都设为根节点。下面给出具体的实现代码：

```
int find(int x)     				//查找结点 x的根结点 {
    if(pre[x] == x) return x;		//递归出口：x的上级为 x本身，即 x为根结点        
    return pre[x] = find(pre[x]);	//此代码相当于先找到根结点 rootx，然后pre[x]=rootx 
}

```

###  路径压缩算法之二（加权合并）

备注：
不要一看到“加权标记”这种比较高大上的名词就害怕，其实他也是属于路径压缩算法，不同的是其思想更加高级（更不容易想到）罢了。不过我还是说一下，掌握了前面几点内容就能应对绝大多数ACM问题，下面的“加权标记法”供有兴趣的同学学习交流。

主要思路：
加权标记法需要将树中所有节点都增设一个权值，用以表示该节点所在树中的高度（比如用rank[x]=3表示 x 节点所在树的高度为3）。这样一来，在合并操作的时候就能通过这个权值的大小来决定谁当谁的上级（玄慈哭了：“正义终会来到，但永不会缺席”）。
在合并操作的时候，假设需要合并的两个集合的代表元（教主）分别为 x 和 y，则只需要令pre[x] = y 或者pre[y] = x 即可。但我们为了使合并后的树不产生退化（即：使树中左右子树的深度差尽可能小），那么对于每一个元素 x ，增设一个rank[x]数组，用以表达子树 x 的高度。在合并时，如果rank[x] < rank[y]，则令pre[x] = y；否则令pre[y] = x。
举个例子，我们对以A，F为代表元的集合进行合并操作（如下图所示）：
![img](https://img-blog.csdnimg.cn/20210222022013234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210222022013189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70)

可以看出，合并前两个树的最大高度为3，合并后依然是3，这也就达到了我们的目的。但如果令pre[A]= F，那么就会使得合并后的树的总高度增加，这里我就不上图了，同学们不信可以自己画出来看看。
我们常说，鱼和熊掌不可兼得，同理，时间复杂度和空间复杂度也很难兼得。由于给每个节点都增加了一个权值来标记其在树中的高度，这也就意味着需要额外的数据结构来存放权重信息，所以这将导致额外的空间开销。

实现：
加权标记法的核心在于对rank数组的逻辑控制，其主要的情况有：
1、如果rank[x] < rank[y]，则令pre[x] = y；
2、如果rank[x] == rank[y]，则可任意指定上级；
3、如果rank[x] > rank[y]，则令pre[y] = x；
在实际写代码时，为了使代码尽可能简洁，我们可以将第1点单独作为一个逻辑选择，然后将2、3点作为另一个选择（反正第2点任意指定上级嘛），所以具体的代码如下：

```
void union(int x,int y){
    x=find(x);							//寻找 x的代表元
    y=find(y);							//寻找 y的代表元
    if(x==y) return ;					//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑
    if(rank[x]>rank[y]) pre[y]=x;		//如果 x的高度大于 y，则令 y的上级为 x
    else								//否则{
        if(rank[x]==rank[y]) rank[y]++;	//如果 x的高度和 y的高度相同，则令 y的高度加1
        pre[x]=y;						//让 x的上级为 y
    }
}

```

## 单调队列

### 引入

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230161218427.png" alt="image-20221230161218427" style="zoom:67%;" />
【数据范围】
对于 $50\%$的数据，$1 \le n \le 10^5$；
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$
**思路：**最暴力的想法很简单，对于每一段 $i \sim i+k-1$ 的序列，逐个比较来找出最大值（和最小值），时间复杂度约为 $O(n \times k)$。很显然，这其中进行了大量重复工作，除了开头 $k-1$ 个和结尾 $k-1$ 个数之外，每个数都进行了 $k$ 次比较，而题中 $100\%$ 的数据为 $n \le 1000000$，当 $k$ 稍大的情况下，显然会 TLE。

这时所用到的就是单调队列了。

### 定义

顾名思义，单调队列的重点分为「单调」和「队列」。

「单调」指的是元素的「规律」——递增（或递减）。

「队列」指的是元素只能从队头和队尾进行操作。

Ps. 单调队列中的 "队列" 与正常的队列有一定的区别，稍后会提到

### 例题分析

#### 解释

有了上面「单调队列」的概念，很容易想到用单调队列进行优化。

要求的是每连续的 $k$ 个数中的最大（最小）值，很明显，当一个数进入所要 "寻找" 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。

也就是说——当满足以上条件时，可将前面的数 "弹出"，再将该数真正 push 进队尾。

这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。

显而易见的是，在这样的算法中，每个数只要进队与出队各一次，因此时间复杂度被降到了 $O(N)$。

而由于查询区间长度是固定的，超出查询空间的值再大也不能输出，因此还需要 site 数组记录第 $i$ 个队中的数在原数组中的位置，以弹出越界的队头。

### 过程

例如我们构造一个单调递增的队列会如下：

原序列为：

```text
1 3 -1 -3 5 3 6 7
```

因为我们始终要维护队列保证其 **递增** 的特点，所以会有如下的事情发生：

| 操作                                             | 队列状态  |
| ------------------------------------------------ | --------- |
| 1 入队                                           | `{1}`     |
| 3 比 1 大，3 入队                                | `{1 3}`   |
| -1 比队列中所有元素小，所以清空队列 -1 入队      | `{-1}`    |
| -3 比队列中所有元素小，所以清空队列 -3 入队      | `{-3}`    |
| 5 比 -3 大，直接入队                             | `{-3 5}`  |
| 3 比 5 小，5 出队，3 入队                        | `{-3 3}`  |
| -3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队 | `{3 6}`   |
| 7 比 6 大，7 入队                                | `{3 6 7}` |

### 写法

1. 为新元素在队列中找到合适的位置，剔除旧元素
2. 加入新元素
3. 查看队首元素是否超出区间，若超出则剔除
4. 使用队首元素

```
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#define maxn 1000100
using namespace std;
int q[maxn], a[maxn];
int n, k;

void getmin() {  // 得到这个队列里的最小值，直接找到最后的就行了
  int head = 1, tail = 0;
  for (int i = 1; i < k; i++) {
    while (head <= tail && a[q[tail]] >= a[i]) tail--;
    q[++tail] = i;
  }
  for (int i = k; i <= n; i++) {
    while (head <= tail && a[q[tail]] >= a[i]) tail--; //如果新元素比之前的还要小，那么就把旧元素踢掉
    q[++tail] = i;
    while (q[head] <= i - k) head++; //判断是否超出K了
    printf("%d ", a[q[head]]);
  }
}

void getmax() {  // 和上面同理
  int head = 1, tail = 0;
  for (int i = 1; i < k; i++) {
    while (head <= tail && a[q[tail]] <= a[i]) tail--;
    q[++tail] = i;
  }
  for (int i = k; i <= n; i++) {
    while (head <= tail && a[q[tail]] <= a[i]) tail--;
    q[++tail] = i;
    while (q[head] <= i - k) head++;
    printf("%d ", a[q[head]]);
  }
}

int main() {
  scanf("%d%d", &n, &k);
  for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
  getmin();
  printf("\n");
  getmax();
  printf("\n");
  return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221230162733645.png" alt="image-20221230162733645" style="zoom:67%;" />
$1\leq N \leq 100000 , 1 \leq D \leq 1000000, 0 \leq x,y\leq 10^6$

**思路1：**将所有水滴按照 $x$ 坐标排序之后，题意可以转化为求一个 $x$ 坐标差最小的区间使得这个区间内 $y$ 坐标的最大值和最小值之差至少为 $D$。我们发现这道题和上一道例题有相似之处，就是都与一个区间内的最大值最小值有关，但是这道题区间的大小不确定，而且区间大小本身还是我们要求的答案。对于区间来说，区间越大区间的最大值一定越大，区间的最小值一定越小。我们要求最大值 - 最小值 >= D，倘若花盆的长度小的不满足答案，我们肯定扩大。当满足条件后，我们肯定缩小去尝试更小的，很容易想到这就是一个二分答案。对于二分答案，我们如何去查看那么多区间是否有一个区间满足最大值 - 最小值 >= D，那就是使用单调队列即可。

**思路2：**我们依然可以使用一个递增，一个递减两个单调队列在 $R$ 不断后移时维护 $[L,R]$ 内的最大值和最小值，不过此时我们发现，如果 $L$ 固定，那么 $[L,R]$ 内的最大值只会越来越大，最小值只会越来越小，所以设 $f(R) = \max[L,R]-\min[L,R]$，则 $f(R)$ 是个关于 $R$ 的递增函数，故 $f(R)\geq D  \Rightarrow f(r)\geq D,R\lt r \leq N$。这说明对于每个固定的 $L$，向右第一个满足条件的 $R$ 就是最优答案。
所以我们整体求解的过程就是，先固定 $L$，从前往后移动 $R$，使用两个单调队列维护 $[L,R]$ 的最值。当找到了第一个满足条件的 $R$，就更新答案并将 $L$ 也向后移动。随着 $L$ 向后移动，两个单调队列都需及时弹出队头。这样，直到 $R$ 移到最后，每个元素依然是各进出队列一次，保证了 $O(n)$ 的时间复杂度。

```
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
typedef long long ll;
int mxq[N], mnq[N];
int D, ans, n, hx, rx, hn, rn;

struct la {
  int x, y;

  bool operator<(const la &y) const { return x < y.x; }
} a[N];

int main() {
  scanf("%d%d", &n, &D);
  for (int i = 1; i <= n; ++i) {
    scanf("%d%d", &a[i].x, &a[i].y);
  }
  sort(a + 1, a + n + 1);
  hx = hn = 1;
  ans = 2e9;
  int L = 1;
  for (int i = 1; i <= n; ++i) {
    while (hx <= rx && a[mxq[rx]].y < a[i].y) rx--;
    mxq[++rx] = i;
    while (hn <= rn && a[mnq[rn]].y > a[i].y) rn--;
    mnq[++rn] = i;
    while (L <= i && a[mxq[hx]].y - a[mnq[hn]].y >= D) {
      ans = min(ans, a[i].x - a[L].x);
      L++;
      while (hx <= rx && mxq[hx] < L) hx++;
      while (hn <= rn && mnq[hn] < L) hn++;
    }
  }
  if (ans < 2e9)
    printf("%d\n", ans);
  else
    puts("-1");
  return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230106105934638.png" alt="image-20230106105934638" style="zoom:67%;" />
数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

**思路：**倘若没有这个$m$的限制无非就是一个找最大连续子串的题目，有了$k$这个限制后我们无非就是要对于当前的最长子串判断长度是否大于$k$。假设区间$[1,i]$的和为$x$，区间$[1,j]$的和为$y$，区间$[1,l]$的和为$z$，满足$z < y < x，l < j < i$，假设$i$超出限定长度$j,l$并没有，那么我们想要缩小$[1,i]$左端点缩小到哪比较好呢？那么需要判断如果缩小到$j$的话，值要缩小$y$，如果缩小到$l$的话，值要缩小$z$，所以一定是缩小到$y$最优，对于所有点满足这种情况，我们维护一个单调队列即可。

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10,INF=1e9;
int sum[N],q[N];
int main()
{
	int n,m;scanf("%d%d",&n,&m);
	for (register int i=1;i<=n;++i)
	{
		int x;scanf("%d",&x);
		sum[i]=sum[i-1]+x;//求前缀和 
	}
	int head=1,tail=1,ans=-INF;q[1]=0;//注意有可能有负数 
	for (register int i=1;i<=n;++i)
	{
		while (head<=tail&&q[head]<i-m) head++;//已经不在范围内要出队 
		ans=max(ans,sum[i]-sum[q[head]]);
		while (head<=tail&&sum[i]<=sum[q[tail]]) tail--;//维护单调递增的队列 
		q[++tail]=i;
	}
	printf("%d\n",ans);
	return 0;
}
```

## 单调栈

### 引入

何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。

### 过程

### 插入

将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 $\{0,11,45,81\}$。

![img](https://oi-wiki.org/ds/images/monotonous-stack-before.svg)


插入元素 $14$ 时为了保证单调性需要依次弹出元素 $0,11$，操作后栈变为 $\{14,45,81\}$。

![img](https://oi-wiki.org/ds/images/monotonous-stack-after.svg)


用伪代码描述如下：

```
insert x
    while !sta.empty() && sta.top()<x
        sta.pop()
    sta.push(x)
```

### 使用

自然就是从栈顶读出来一个元素，该元素满足单调性的某一端。

例如举例中取出的即栈中的最小值。

## 应用

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230105201827450.png" alt="image-20230105201827450" style="zoom:67%;" />
【数据规模与约定】

对于 $30\%$的数据，$n\leq 100$

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6，1\leq a_i\leq 10^9$

**思路：**对于$a[i]$来说，倘若$a[i + 1]$大于$a[i]$那么$f(i) = i + 1$，复杂度为$O(1)$，倘若$a[i + 1] <= a[i]$，那么$f(i)至少也是f(i + 1)$，所以对于$f(i) - f(i + 1)$的地方都无需再看，这一部分的复杂度为$O(n)$，假设$a[i] <= a[i - 1]$，那么$f(i - 1)$至少为$f(i)$，对于$f(i)$来说，假设已经遍历了$f(i + 1) - f(i)$的数组，那么对于$f(i - 1)$来说，只需要遍历$f(i) - f(i - 1)$的数组，所以每个数字最多遍历一次。

```
#include<cstdio>
#include<stack>
using namespace std;
int n,a[3000005],f[3000005];//a是需要判断的数组（即输入的数组），f是存储答案的数组
stack<int>s;//模拟用的栈
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=n;i>=1;i--)
	{
		while(!s.empty()&&a[s.top()]<=a[i]) s.pop();//弹出栈顶比当前数小的
		f[i]=s.empty()?0:s.top();//存储答案，由于没有比她大的要输出0，所以加了个三目运算
		s.push(i);//压入当前元素
	}
	for(int i=1;i<=n;i++) printf("%d ",f[i]);//输出
	return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230105225752466.png" alt="image-20230105225752466" style="zoom:67%;" />
对于全部的数据，满足 $2 \le N \le 10^5$，$1 \le h_i <2^{31}$

**思路：**倘若条件没有出现中间的数字和两边的数字不相同，那么就是一个最简单的单调栈，我们要对数字不相同做一个处理，我们思考如果$f(i)$求的是不和中间的数字$a[i]$相同且第一个大于$a[i]$的下标，$f(i - 1)$和$f(i)$有无关系，显然没有关系，因为确定不了$i-f(i)$中有无$a[i - 1]$，所以只能寻找其他方法。假设我们现在已经求完区间$[1,i - 1]$所有点选择哪个点最优我们通过一些例子来发现一些规律当$a[i] >= a[i - 1]$的时候对于区间$[1,i],[1,i + 1]...[1,n]$来说显然$a[i - 1]$对比$a[i]$当左端点会更优，如果后续出现第一个下标$k$满足$a[k] <= a[i - 1]$，那么$a[i]$和$a[i - 1]$，对于所有下标$>=k$的点都做不了右端点了，但是下标<= $k - 1$的点，如果满足下标$j，a[j] > a[i]$，一定满足$a[j] > a[i - 1]$，对于区间$[1,i]$来说$a[i]$当右端点更优，因为倘若存在一个下标 $k$ ，满足$a[k] < a[i - 1]$，那么$a[k] < a[i]$，同样的如果存在$a[i] > a[i - 1] > a[i - 2]$亦是如此，满足单调性质 。倘若$a[i] < a[i - 1]$的话，对于区间$[1,i],[1,i + 1]...[1,n]$来说$a[i]$当左端点更优因为已经可以确认$a[i - 1]$和$a[i]$产生长度为$2$的贡献。对于区间$[1,i - 1]$，$a[i - 1]$当右端点更合适。同样的如果存在$a[i] < a[i - 1] < a[i - 2]$亦是如此，所以对于值变小，值变大都满足单调性质，我们可以分别用两个单调栈去维护最大值的下标用$q1$代表和最小值的下标$q2$代表，我们每次把最新的点当作右端点，加入最新的点是$j$，他要去$q2$数组中踢出比他小的元素，直到找到一个$k$满足$a[q2[k]] >= a[j]$因为我们去$q1$找最优左端点下标不能小于$q2[k]$。随后去$q1$数组二分最优点即可。

```
#include <cstdio>
#include <set>
#include <algorithm>

const int maxn = 100005;

int n, ans, tx, tn;
int a[maxn], sx[maxn], sn[maxn];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", a + i);
  for (int i = 1; i <= n; ++i) {
    while (tn && a[sn[tn]] >= a[i]) --tn; //递增栈
    while (tx && a[sx[tx]] < a[i]) --tx; //递减栈
    int k = std::upper_bound(sn + 1, sn + 1 + tn, sx[tx]) - sn;
    if (k != (tn + 1)) {
      ans = std::max(ans, i - sn[k] + 1);
    }
    sn[++tn] = i;
    sx[++tx] = i;
  }
  printf("%d\n", ans);
  return 0;
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230106095152880.png" alt="image-20230106095152880" style="zoom:67%;" />
对于 $100\%$ 的数据，保证 $2\le n\le 3\times 10^5$，$1\le a_i\le 10^8$。

**思路：**首先我们可以分解为求区间最大值的和减去区间最小值的和，同样的通过例子找规律，假设现在有一个下标$i，j$满足$a[j] > a[i]，j > i，j$与$i$中间的值都比他们小，什么时候为最大值呢，我们需要知道第一个比他大的左端点的下标假设为$k$那么对于左端点下标$[k + 1,i]$右端点下标$[i,j - 1]$他都为最大值，所以我们需要维护每个点的第一个比他大的左端点也就是一个递减单调栈，$a[i]$作为最小值的情况$a[j + 1]$并没有产生任何影响，反而是中间的值产生了影响。现在讨论$i,j$满足$a[j] < a[i],j > i，j$与$i$中间的值都比他们大，那么$a[i]$什么时候为最小值呢？我们需要知道他的第一个左边比他小的端点假设为$k$那么对于左端点下标$[k + 1,i]$右端点下标$[i,j - 1]$他都为最小值，所以我们需要维护每个点的第一个比他小的左端点也就是一个递增单调栈。

```
#include<iostream>
using namespace std;
const int N = 3e5 + 10;
long long q[N],a[N];long long ans;
int main(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++){
		int x;
		scanf("%lld",&a[i]);
	} 
	int st = 1,ed = 0;
	q[0] = 0;
	for(int i = 1; i <= n; i++){
		while(st <= ed && a[q[ed]] < a[i]){
			ans += (i - q[ed])  * a[q[ed]] * (q[ed] - q[ed - 1]);
			ed--;
		}
		q[++ed] = i;
	}
	while(st <= ed){
		ans += (n + 1 - q[ed])  * a[q[ed]] * (q[ed] - q[ed - 1]);
		ed--;
	}
	st = 1,ed = 0;
	for(int i = 1; i <= n; i++){
		while(st <= ed && a[q[ed]] > a[i]){
			ans -= (i - q[ed])  * a[q[ed]] * (q[ed] - q[ed - 1]);
			ed--;
		}
		q[++ed] = i;
	}
	while(st <= ed){
		ans -= (n + 1 - q[ed])  * a[q[ed]] * (q[ed] - q[ed - 1]);
		ed--;
	}
	printf("%lld",ans);
	return 0;   
}
```



## Trie树

### 定义

字典树，英文名 trie。顾名思义，就是一个像字典一样的树。

### 引入

先放一张图：

<img src="https://oi-wiki.org/string/images/trie1.png" alt="trie1" style="zoom:67%;" />

可以发现，这棵字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子，$1\to4\to 8\to 12$ 表示的就是字符串 `caa`。

trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（$c$ 的取值范围和字符集大小有关，不一定是 $0\sim 26$。）

有时需要标记插入进 trie 的是哪些字符串，每次插入完成时在这个字符串所代表的节点处打上标记即可。

### 实现

    int cnt = 0;
    int trie[100000][25]; //空间换时间
    void insert(string a){ //往字典里插入字符串a
    	int node = 1;
    	for(int i = 0; i < a.length(); i++){
    		int x = a[i] - 'a';
    		if(trie[node][x]){ //已经有过了
    			node = trie[node][x]; //进入这个节点
    		}else{
    			trie[node][x] = ++cnt;//否则插入一个节点
    		}
    	}
    }
    bool find(string a){ //查看有无字符串a
    	int node = 1;
    	for(int i = 0; i < a.length(); i++){
    		int x = a[i] - 'a';
    		if(trie[node][x]){ //已经有过了
    			node = trie[node][x]; //进入这个节点
    		}else{
    			return false;
    		}
    	}
    	return true;
    }

### 例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230106135952711.png" alt="image-20230106135952711" style="zoom:67%;" />
**思路:**只需要在trie树的基础上记录一个数组代表当前字符串出现过几次即可。

```
#include<iostream>
#include<cstring>
using namespace std;
const int maxn = 3000010;
int son[maxn][150],cnt[maxn],idx;char a[maxn];
void insert(char ch[]){
    int p = 0;
    for(int i = 0; ch[i]; i++){
        int s = ch[i] - '0';
        if(!son[p][s]) son[p][s] = ++idx;
        cnt[p]++;
        p = son[p][s];
    }
    cnt[p]++;
    return;
}

int query(char ch[]){
    int p = 0;
    for(int i = 0; ch[i]; i++){
        int s = ch[i] - '0';
        if(!son[p][s]) return 0;
        p = son[p][s];
    }
    return cnt[p];
}

int main(){
    int t;
    cin >> t;
    while(t--){
    	int n,m;
    	cin >> n >> m;
    	for(int i = 0; i <= idx; i++){
    		for(int j = 0; j < 150; j++) son[i][j] = 0;
    		cnt[i] = 0;
		}
		idx = 0;
    	for(int i = 1; i <= n; i++){
    		scanf("%s",a);
    		insert(a);
		}
		for(int i = 1; i <= m; i++){
			scanf("%s",a);
			printf("%d\n",query(a));
		}
    }
    
    return 0;
}
```

## 哈希表

### 引入

![img](https://oi-wiki.org/ds/images/hashtable.svg)
哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。

### 哈希函数

要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。举个例子，如果键值是一个人的身份证号码，哈希函数就可以是号码的后四位，当然也可以是号码的前四位。生活中常用的“手机尾号”也是一种哈希函数。在实际的应用中，键值可能是更复杂的东西，比如浮点数、字符串、结构体等，这时候就要根据具体情况设计合适的哈希函数。哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。

能为 key 计算索引之后，我们就可以知道每个键值对应的值 value 应该放在哪里了。假设我们用数组 a 存放数据，哈希函数是 f，那键值对 `(key, value)` 就应该放在 `a[f(key)]` 上。不论键值是什么类型，范围有多大，`f(key)` 都是在可接受范围内的整数，可以作为数组的下标。

在 OI 中，最常见的情况应该是键值为整数的情况。当键值的范围比较小的时候，可以直接把键值作为数组的下标，但当键值的范围比较大，比如以 $10^9$ 范围内的整数作为键值的时候，就需要用到哈希表。一般把键值模一个较大的质数作为索引，也就是取 $f(x)=x \bmod M$ 作为哈希函数。

另一种比较常见的情况是 key 为字符串的情况，由于不支持以字符串作为数组下标，并且将字符串转化成数字存储也可以避免多次进行字符串比较。所以在 OI 中，一般不直接把字符串作为键值，而是先算出字符串的哈希值，再把其哈希值作为键值插入到哈希表里。关于字符串的哈希值，我们一般采用进制的思想，将字符串想象成一个 $127$ 进制的数。那么，对于每一个长度为 $n$ 的字符串 $s$，就有：

$x = s_0 \cdot 127^0 + s_1 \cdot 127^1 + s_2 \cdot 127^2 + \dots + s_n \cdot 127^n$

我们可以将得到的 $x$ 对 $2^{64}$（即 `unsigned long long` 的最大值）取模。这样 `unsigned long long` 的自然溢出就等价于取模操作了。可以使操作更加方便。

这种方法虽然简单，但并不是完美的。可以构造数据使这种方法发生冲突（即两个字符串的 $x$ 对 $2^{64}$ 取模后的结果相同）。  
我们可以使用双哈希的方法：选取两个大质数 $a,b$。当且仅当两个字符串的哈希值对 $a$ 和对 $b$ 取模都相等时，我们才认为这两个字符串相等。这样可以大大降低哈希冲突的概率。

### 冲突

如果对于任意的键值，哈希函数计算出来的索引都不相同，那只用根据索引把 `(key, value)` 放到对应的位置就行了。但实际上，常常会出现两个不同的键值，他们用哈希函数计算出来的索引是相同的。这时候就需要一些方法来处理冲突。在 OI 中，最常用的方法是拉链法。

### 拉链法

拉链法也称开散列法（open hashing）。

拉链法是在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。如果索引的范围是 $1\ldots M$，哈希表的大小为 $N$，那么一次插入/查询需要进行期望 $O(\frac{N}{M})$ 次比较。

#### 实现

    void insert(int x){
        int k  = (x % N + N) % N;
        to[cnt] = x;
        last[cnt] = head[k];
        head[k] = cnt++;
    }
    bool query(int x){
        int k = (x % N + N) % N;
        for(int i = head[k]; i != -1; i = last[i]){
            if(to[i] == x) return true;
        }
        return false;
    }

### 闭散列法

闭散列方法把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。

#### 线性探查法

线性探查法：如果在 `d` 处发生冲突，就依次检查 `d + 1`，`d + 2`，`d + 3`……

**线性探测优点：实现简单
线性探测缺点：哈希冲突容易堆积，使得寻找某关键码需要多次比较，搜索效率低**

#### 实现

```cpp
const int N = 360007;  // N 是最大可以存储的元素数量

class Hash {
 private:
  int keys[N];
  int values[N];

 public:
  Hash() { memset(values, 0, sizeof(values)); }

  int& operator[](int n) {
    // 返回一个指向对应 Hash[Key] 的引用
    // 修改成不为 0 的值 0 时候视为空
    int idx = (n % N + N) % N, cnt = 1;
    while (keys[idx] != n && values[idx] != 0) {
      idx = (idx + cnt) % N;
      cnt += 1;
    }
    keys[idx] = n;
    return values[idx];
  }
};
```

#### 二次探测法

如果在 `d` 处发生冲突，就依次检查 `d + 1`，`d - 1`，`d + 4`，`d - 4`……

**二次探测缓解了冲突堆积的问题，但是闭散列都有的缺点就是空间利用率低**

**闭散列需要额外存储哈希表每个位置的状态**，如果不这样做，发生哈希冲突的元素删除掉，会影响其他元素的查找，例如：
![在这里插入图片描述](https://img-blog.csdnimg.cn/33cf881f0b51425f86e9650a96928e68.png)
如果删除4，查找44时认为44不存在

状态有三种：空，满，已删除

如果查找时状态为已删除，不能认为元素不存在插入时状态不为满就插入在闭散列中查找某元素，若找到空认为不存在，所以闭散列也不允许哈希表为满**解决方法就是通过扩容控制载荷因子**：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3ec2cc8406c44d058739f6b33c473cab.png)

# 字符串

## 字符串基础

![image-20220928224618142](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928224618142.png)


![image-20220928224629858](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928224629858.png)


![image-20220928224640352](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928224640352.png)




## 字符串匹配

![image-20220928224821232](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928224821232.png)




```
// C++ Version
/*
 * s：待匹配的主串
 * t：模式串
 * n：主串的长度
 * m：模式串的长度
 */
std::vector<int> match(char *s, char *t, int n, int m) {
  std::vector<int> ans;
  int i, j;
  for (i = 0; i < n - m + 1; i++) {
    for (j = 0; j < m; j++) {
      if (s[i + j] != t[j]) break;
    }
    if (j == m) ans.push_back(i);
  }
  return ans;
}
```

![image-20220928225009361](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928225009361.png)




## 字符串哈希(Hash)

### **定义**:

我们定义一个把字符串映射到整数的函数 ，这个 称为是 Hash 函数。我们希望这个函数 可以方便地帮我们判断两个字符串是否相等。

### Hash 的思想:

Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。
![image-20220928225227966](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928225227966.png)

![image-20220928225247200](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928225247200.png)


![image-20220928225310995](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928225310995.png)


```
// C++ Version
using std::string;

const int M = 1e9 + 7;
const int B = 233;

typedef long long ll;

int get_hash(const string& s) {
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    res = (ll)(res * B + s[i]) % M;
  }
  return res;
}

bool cmp(const string& s, const string& t) {
  return get_hash(s) == get_hash(t);
}
```

![image-20220928225348697](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220928225348697.png)


```
char s[N]; //输入的字符串
int f[N]; //f[i] = S[1] * 127 + s[2] * qpow(127,2) + ... + s[i] * qpow(127,i); 快速幂
bool Judge(int l1,int r1,int l2,int r2){//判断l1 ~ r1 和 l2 ~ r2的关系 其中 l2 > l1 r2 > r1
	if(l1 - r1 != l2 - r2) return false;
	if(((f[r1] - f[l1 - 1]) % mod + mod) % mod * qpow(127,r1 - l1) == ((f[r2] - f[l2 - 1]) % mod + mod) % mod) return true;
	return false;
}
```

## KMP

### 前缀函数

#### 定义

给定一个长度为 $n$ 的字符串 $s$，其 **前缀函数** 被定义为一个长度为 $n$ 的数组 $\pi$。
其中 $\pi[i]$ 的定义是：

1. 如果子串 $s[0\dots i]$ 有一对相等的真前缀与真后缀：$s[0\dots k-1]$ 和 $s[i - (k - 1) \dots i]$，那么 $\pi[i]$ 就是这个相等的真前缀（或者真后缀，因为它们相等：)）的长度，也就是 $\pi[i]=k$；
2. 如果不止有一对相等的，那么 $\pi[i]$ 就是其中最长的那一对的长度；
3. 如果没有相等的，那么 $\pi[i]=0$。

简单来说 $\pi[i]$ 就是，子串 $s[0\dots i]$ 最长的相等的真前缀与真后缀的长度。

用数学语言描述如下：

$$
\pi[i] = \max_{k = 0 \dots i}\{k: s[0 \dots k - 1] = s[i - (k - 1) \dots i]\}
$$

特别地，规定 $\pi[0]=0$。

### 过程

举例来说，对于字符串 `abcabcd`，

$\pi[0]=0$，因为 `a` 没有真前缀和真后缀，根据规定为 0

$\pi[1]=0$，因为 `ab` 无相等的真前缀和真后缀

$\pi[2]=0$，因为 `abc` 无相等的真前缀和真后缀

$\pi[3]=1$，因为 `abca` 只有一对相等的真前缀和真后缀：`a`，长度为 1

$\pi[4]=2$，因为 `abcab` 相等的真前缀和真后缀只有 `ab`，长度为 2

$\pi[5]=3$，因为 `abcabc` 相等的真前缀和真后缀只有 `abc`，长度为 3

$\pi[6]=0$，因为 `abcabcd` 无相等的真前缀和真后缀

同理可以计算字符串 `aabaaab` 的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$。

### 计算前缀函数的朴素算法

#### 过程

一个直接按照定义计算前缀函数的算法流程：

- 在一个循环中以 $i = 1\to n - 1$ 的顺序计算前缀函数 $\pi[i]$ 的值（$\pi[0]$ 被赋值为 $0$）。

- 为了计算当前的前缀函数值 $\pi[i]$，我们令变量 $j$ 从最大的真前缀长度 $i$ 开始尝试。

- 如果当前长度下真前缀和真后缀相等，则此时长度为 $\pi[i]$，否则令 $j$ 自减 1，继续匹配，直到 $j=0$。

- 如果 $j = 0$ 并且仍没有任何一次匹配，则置 $\pi[i] = 0$ 并移至下一个下标 $i + 1$。

  具体实现如下：

```
  vector<int> prefix_function(string s) {
          int n = (int)s.length();
          vector<int> pi(n);
          for (int i = 1; i < n; i++)
            for (int j = i; j >= 0; j--)
              if (s.substr(0, j) == s.substr(i - j + 1, j)) {
                pi[i] = j;
                break;
              }
          return pi;
        }
```

  

显见该算法的时间复杂度为 $O(n^3)$，具有很大的改进空间。

### 计算前缀函数的高效算法

#### 第一个优化

第一个重要的观察是 **相邻的前缀函数值至多增加 $1$**。

参照下图所示，只需如此考虑：当取一个尽可能大的 $\pi[i+1]$ 时，必然要求新增的 $s[i+1]$ 也与之对应的字符匹配，即 $s[i+1]=s[\pi[i]]$, 此时 $\pi[i+1] = \pi[i]+1$。

$$
\underbrace{\overbrace{s_0 ~ s_1 ~ s_2}^{\pi[i] = 3} ~ s_3}_{\pi[i+1] = 4} ~ \dots ~ \underbrace{\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\pi[i] = 3} ~ s_{i+1}}_{\pi[i+1] = 4}
$$

所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。
此时的改进的算法为：

    vector<int> prefix_function(string s) {
          int n = (int)s.length();
          vector<int> pi(n);
          for (int i = 1; i < n; i++)
            for (int j = pi[i - 1] + 1; j >= 0; j--)  // improved: j=i => j=pi[i-1]+1
              if (s.substr(0, j) == s.substr(i - j + 1, j)) {
                pi[i] = j;
                break;
              }
          return pi;
        }

在这个初步改进的算法中，在计算每个 $\pi[i]$ 时，最好的情况是第一次字符串比较就完成了匹配，也就是说基础的字符串比较次数是 `n-1` 次。

而由于存在 `j = pi[i-1]+1`（`pi[0]=0`）对于最大字符串比较次数的限制，可以看出每次只有在最好情况才会为字符串比较次数的上限积累 1，而每次超过一次的字符串比较消耗的是之后次数的增长空间。

由此我们可以得出字符串比较次数最多的一种情况：至少 `1` 次字符串比较次数的消耗和最多 `n-2` 次比较次数的积累，此时字符串比较次数为 `n-1 + n-2 = 2n-3`。

可见经过此次优化，计算前缀函数只需要进行 $O(n)$ 次字符串比较，总复杂度降为了 $O(n^2)$。

### 第二个优化

在第一个优化中，我们讨论了计算 $\pi[i+1]$ 时的最好情况：$s[i+1]=s[\pi[i]]$，此时 $\pi[i+1] = \pi[i]+1$。现在让我们沿着这个思路走得更远一点：讨论当 $s[i+1] \neq s[\pi[i]]$ 时如何跳转。

失配时，我们希望找到对于子串 $s[0\dots i]$，仅次于 $\pi[i]$ 的第二长度 $j$，使得在位置 $i$ 的前缀性质仍得以保持，也即 $s[0 \dots j - 1] = s[i - j + 1 \dots i]$：

$$
\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_j}^{\pi[i]} ~ s_{i+1}
$$

如果我们找到了这样的长度 $j$，那么仅需要再次比较 $s[i + 1]$ 和 $s[j]$。如果它们相等，那么就有 $\pi[i + 1] = j + 1$。否则，我们需要找到子串 $s[0\dots i]$ 仅次于 $j$ 的第二长度 $j^{(2)}$，使得前缀性质得以保持，如此反复，直到 $j = 0$。如果 $s[i + 1] \neq s[0]$，则 $\pi[i + 1] = 0$。

观察上图可以发现，因为 $s[0\dots \pi[i]-1] = s[i-\pi[i]+1\dots i]$，所以对于 $s[0\dots i]$ 的第二长度 $j$，有这样的性质：

$$
s[0 \dots j - 1] = s[i - j + 1 \dots i]= s[\pi[i]-j\dots \pi[i]-1]
$$

也就是说 $j$ 等价于子串 $s[\pi[i]-1]$ 的前缀函数值，即 $j=\pi[\pi[i]-1]$。同理，次于 $j$ 的第二长度等价于 $s[j-1]$ 的前缀函数值，$j^{(2)}=\pi[j-1]$

显然我们可以得到一个关于 $j$ 的状态转移方程：$j^{(n)}=\pi[j^{(n-1)}-1], \ \ (j^{(n-1)}>0)$

### 最终算法

所以最终我们可以构建一个不需要进行任何字符串比较，并且只进行 $O(n)$ 次操作的算法。

而且该算法的实现出人意料的短且直观：

    vector<int> prefix_function(string s) {
          int n = (int)s.length();
          vector<int> pi(n);
          for (int i = 1; i < n; i++) {
            int j = pi[i - 1];
            while (j > 0 && s[i] != s[j]) j = pi[j - 1];
            if (s[i] == s[j]) j++;
            pi[i] = j;
          }
          return pi;
        }

这是一个 **在线** 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 $M$，那么我们仅需要存储该字符串的前 $M + 1$ 个字符以及对应的前缀函数值。

## 应用

### 在字符串中查找子串：Knuth-Morris-Pratt 算法

该算法由 Knuth、Pratt 和 Morris 在 1977 年共同发布

该任务是前缀函数的一个典型应用。

#### 过程

给定一个文本 $t$ 和一个字符串 $s$，我们尝试找到并展示 $s$ 在 $t$ 中的所有出现（occurrence）。

为了简便起见，我们用 $n$ 表示字符串 $s$ 的长度，用 $m$ 表示文本 $t$ 的长度。

我们构造一个字符串 $s + \# + t$，其中 $\#$ 为一个既不出现在 $s$ 中也不出现在 $t$ 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 $n + 1$ 个值（即属于字符串 $s$ 和分隔符的函数值）后其余函数值的意义。根据定义，$\pi[i]$ 为右端点在 $i$ 且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与 $s$ 的前缀相同且右端点位于 $i$ 的最长子串的长度。由于分隔符的存在，该长度不可能超过 $n$。而如果等式 $\pi[i] = n$ 成立，则意味着 $s$ 完整出现在该位置（即其右端点位于位置 $i$）。注意该位置的下标是对字符串 $s + \# + t$ 而言的。

因此如果在某一位置 $i$ 有 $\pi[i] = n$ 成立，则字符串 $s$ 在字符串 $t$ 的 $i - (n - 1) - (n + 1) = i - 2n$ 处出现。

正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 $s + \#$ 以及相应的前缀函数值即可。我们可以一次读入字符串 $t$ 的一个字符并计算当前位置的前缀函数值。

因此 Knuth-Morris-Pratt 算法（简称 KMP 算法）用 $O(n + m)$ 的时间以及 $O(n)$ 的内存解决了该问题。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230111101833064.png" alt="image-20230111101833064" style="zoom: 67%;" />

```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
int a[N],pi[N];
int main(){
	int t;
	cin >> t;
	while(t--){
		int n,m;
		cin >> n >> m;
		for(int i = 1; i <= n; i++){
			scanf("%d",&a[m + 1 + i]);
		}
		a[m + 1] = 100000000;
		for(int i = 1; i <= m; i++){
			scanf("%d",&a[i]);
		}
		pi[0] = 0;
		pi[1] = 0;
		for(int i = 2; i <= n + m + 1; i++){
			int j = pi[i - 1];
			while(j != 0 && a[j + 1] != a[i]){
				j = pi[j];
			}
			if(a[j + 1] == a[i]) pi[i] = j + 1;
			else pi[i] = 0;
		}
		
		int id = -1;
		for(int i = m + 2; i <= n + m + 1; i++){
			if(pi[i] == m){
				id = i - (m + 1) - (m - 1);
				break;
			}
		}
		printf("%d\n",id);
	}
	return 0;
}
```

### 字符串的周期

对字符串 $s$ 和 $0 < p \le |s|$，若 $s[i] = s[i+p]$ 对所有 $i \in [0, |s| - p - 1]$ 成立，则称 $p$ 是 $s$ 的周期。

对字符串 $s$ 和 $0 \le r < |s|$，若 $s$ 长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，就称 $s$ 长度为 $r$ 的前缀是 $s$ 的 border。

由 $s$ 有长度为 $r$ 的 border 可以推导出 $|s|-r$ 是 $s$ 的周期。

根据前缀函数的定义，可以得到 $s$ 所有的 border 长度，即 $\pi[n-1],\pi[\pi[n-1]-1], \ldots$。

所以根据前缀函数可以在 $O(n)$ 的时间内计算出 $s$ 所有的周期。其中，由于 $\pi[n-1]$ 是 $s$ 最长 border 的长度，所以 $n - \pi[n-1]$ 是 $s$ 的最小周期。

### 统计每个前缀的出现次数

在该节我们将同时讨论两个问题。给定一个长度为 $n$ 的字符串 $s$，在问题的第一个变种中我们希望统计每个前缀 $s[0 \dots i]$ 在同一个字符串的出现次数，在问题的第二个变种中我们希望统计每个前缀 $s[0 \dots i]$ 在另一个给定字符串 $t$ 中的出现次数。

首先让我们来解决第一个问题。考虑位置 $i$ 的前缀函数值 $\pi[i]$。根据定义，其意味着字符串 $s$ 一个长度为 $\pi[i]$ 的前缀在位置 $i$ 出现并以 $i$ 为右端点，同时不存在一个更长的前缀满足前述定义。与此同时，更短的前缀可能以该位置为右端点。容易看出，我们遇到了在计算前缀函数时已经回答过的问题：给定一个长度为 $j$ 的前缀，同时其也是一个右端点位于 $i$ 的后缀，下一个更小的前缀长度 $k < j$ 是多少？该长度的前缀需同时也是一个右端点为 $i$ 的后缀。因此以位置 $i$ 为右端点，有长度为 $\pi[i]$ 的前缀，有长度为 $\pi[\pi[i] - 1]$ 的前缀，有长度为 $\pi[\pi[\pi[i] - 1] - 1]$ 的前缀，等等，直到长度变为 $0$。故而我们可以通过下述方式计算答案。

    vector<int> ans(n + 1);
    for (int i = 0; i < n; i++) ans[pi[i]]++;
    for (int i = n - 1; i > 0; i--) ans[pi[i - 1]] += ans[i];
    for (int i = 0; i <= n; i++) ans[i]++;

#### 解释

在上述代码中我们首先统计每个前缀函数值在数组 $\pi$ 中出现了多少次，然后再计算最后答案：如果我们知道长度为 $i$ 的前缀出现了恰好 $\text{ans}[i]$ 次，那么该值必须被叠加至其最长的既是后缀也是前缀的子串的出现次数中。在最后，为了统计原始的前缀，我们对每个结果加 $1$。

现在考虑第二个问题。我们应用来自 Knuth-Morris-Pratt 的技巧：构造一个字符串 $s + \# + t$ 并计算其前缀函数。与第一个问题唯一的不同之处在于，我们只关心与字符串 $t$ 相关的前缀函数值，即 $i \ge n + 1$ 的 $\pi[i]$。有了这些值之后，我们可以同样应用在第一个问题中的算法来解决该问题。

### 一个字符串中本质不同子串的数目

给定一个长度为 $n$ 的字符串 $s$，我们希望计算其本质不同子串的数目。

我们将迭代的解决该问题。换句话说，在知道了当前的本质不同子串的数目的情况下，我们要找出一种在 $s$ 末尾添加一个字符后重新计算该数目的方法。

令 $k$ 为当前 $s$ 的本质不同子串数量。我们添加一个新的字符 $c$ 至 $s$。显然，会有一些新的子串以字符 $c$ 结尾。我们希望对这些以该字符结尾且我们之前未曾遇到的子串计数。

构造字符串 $t = s + c$ 并将其反转得到字符串 $t^{\sim}$。现在我们的任务变为计算有多少 $t^{\sim}$ 的前缀未在 $t^{\sim}$ 的其余任何地方出现。如果我们计算了 $t^{\sim}$ 的前缀函数最大值 $\pi_{\max}$，那么最长的出现在 $s$ 中的前缀其长度为 $\pi_{\max}$。自然的，所有更短的前缀也出现了。

因此，当添加了一个新字符后新出现的子串数目为 $|s| + 1 - \pi_{\max}$。

所以对于每个添加的字符，我们可以在 $O(n)$ 的时间内计算新子串的数目，故最终复杂度为 $O(n^2)$。

值得注意的是，我们也可以重新计算在头部添加一个字符，或者从尾或者头移除一个字符时的本质不同子串数目。

### 字符串压缩

给定一个长度为 $n$ 的字符串 $s$，我们希望找到其最短的“压缩”表示，也即我们希望寻找一个最短的字符串 $t$，使得 $s$ 可以被 $t$ 的一份或多份拷贝的拼接表示。

显然，我们只需要找到 $t$ 的长度即可。知道了该长度，该问题的答案即为长度为该值的 $s$ 的前缀。

让我们计算 $s$ 的前缀函数。通过使用该函数的最后一个值 $\pi[n - 1]$，我们定义值 $k = n - \pi[n - 1]$。我们将证明，如果 $k$ 整除 $n$，那么 $k$ 就是答案，否则不存在一个有效的压缩，故答案为 $n$。

假定 $n$ 可被 $k$ 整除。那么字符串可被划分为长度为 $k$ 的若干块。根据前缀函数的定义，该字符串长度为 $n - k$ 的前缀等于其后缀。但是这意味着最后一个块同倒数第二个块相等，并且倒数第二个块同倒数第三个块相等，等等。作为其结果，所有块都是相等的，因此我们可以将字符串 $s$ 压缩至长度 $k$。

#### 证明

诚然，我们仍需证明该值为最优解。实际上，如果有一个比 $k$ 更小的压缩表示，那么前缀函数的最后一个值 $\pi[n - 1]$ 必定比 $n - k$ 要大。因此 $k$ 就是答案。

现在假设 $n$ 不可以被 $k$ 整除，我们将通过反证法证明这意味着答案为 $n$[^1]。假设其最小压缩表示 $r$ 的长度为 $p$（$p$ 整除 $n$），字符串 $s$ 被划分为 $n / p \ge 2$ 块。那么前缀函数的最后一个值 $\pi[n - 1]$ 必定大于 $n - p$（如果相等则$p = k$则 $n$ 可被 $k$ 整除），也即其所表示的后缀将部分的覆盖第一个块。现在考虑字符串的第二个块。该块有两种解释：第一种为 $r_0 r_1 \dots r_{p - 1}$，另一种为 $r_{p - k} r_{p - k + 1} \dots r_{p - 1} r_0 r_1 \dots r_{p - k - 1}$。由于两种解释对应同一个字符串，因此可得到 $p$ 个方程组成的方程组，该方程组可简写为 $r_{(i + k) \bmod p} = r_{i \bmod p}$，其中 $\cdot \bmod p$ 表示模 $p$ 意义下的最小非负剩余。
$$
\begin{gathered}
\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ \overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 r_5}^p \\
r_0 ~ r_1 ~ r_2 ~ r_3 ~ \underbrace{\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ r_0 ~ r_1}_{\pi[11] = 8}
\end{gathered}
$$
根据扩展欧几里得算法我们可以得到一组 $x$ 和 $y$ 使得 $xk + yp = \gcd(k, p)$。通过与等式 $pk - kp = 0$ 适当叠加我们可以得到一组 $x' > 0$ 和 $y' < 0$ 使得 $x'k + y'p = \gcd(k, p)$。这意味着通过不断应用前述方程组中的方程我们可以得到新的方程组 $r_{(i + \gcd(k, p)) \bmod p} = r_{i \bmod p}$。

由于 $\gcd(k, p)$ 整除 $p$，这意味着 $\gcd(k, p)$ 是 $r$ 的一个周期。又因为 $\pi[n - 1] > n - p$，故有 $n - \pi[n - 1] = k < p$，所以 $\gcd(k, p)$ 是一个比 $p$ 更小的 $r$ 的周期。因此字符串 $s$ 有一个长度为 $\gcd(k, p) < p$ 的压缩表示，同 $p$ 的最小性矛盾。

综上所述，不存在一个长度小于 $k$ 的压缩表示，因此答案为 $k$。

# STL模板

## 分类

![img](https://oi-wiki.org/lang/csl/images/container1.png)

### 序列式容器

- **向量**(`vector`) 后端可高效增加元素的顺序表。
- **数组**(`array`)**C++11**，定长的顺序表，C 风格数组的简单包装。
- **双端队列**(`deque`) 双端都可高效增加元素的顺序表。
- **列表**(`list`) 可以沿双向遍历的链表。
- **单向列表**(`forward_list`) 只能沿一个方向遍历的链表。

### 关联式容器

- **集合**(`set`) 用以有序地存储 **互异** 元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。
- **多重集合**(`multiset`) 用以有序地存储元素的容器。允许存在相等的元素。
- **映射**(`map`) 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。
- **多重映射**(`multimap`) 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。

**注意：**谓词就是返回值为真或者假的函数。STL 容器中经常会使用到谓词，用于模板参数。

### 无序（关联式）容器

- **无序（多重）集合**(`unordered_set`/`unordered_multiset`)**C++11**，与 `set`/`multiset` 的区别在与元素无序，只关心”元素是否存在“，使用哈希实现。
- **无序（多重）映射**(`unordered_map`/`unordered_multimap`)**C++11**，与 `map`/`multimap` 的区别在与键 (key) 无序，只关心 "键与值的对应关系"，使用哈希实现。

### 容器适配器

容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 `clear()` 函数……）。

> ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。

- **栈**(`stack`) 后进先出 (LIFO) 的容器，默认是对双端队列（`deque`) 的包装。
- **队列**(`queue`) 先进先出 (FIFO) 的容器，默认是对双端队列（`deque`) 的包装。
- **优先队列**(`priority_queue`) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（`vector`) 的包装。

## 共同点

### 容器声明

都是 `containerName<typeName,...> name` 的形式，但模板参数（`<>` 内的参数）的个数、形式会根据具体容器而变。

本质原因：STL 就是“标准模板库”，所以容器都是模板类。

### 迭代器

在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。类似的概念在其他很多高级语言中都存在，如 Python 的 `__iter__` 函数，C# 的 `IEnumerator`。

#### 基础使用

迭代器听起来比较晦涩，其实迭代器本身可以看作一个数据指针。迭代器主要支持两个运算符：自增 (`++`) 和解引用（单目 `*` 运算符），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。

指向某个 [STL 容器](./container.md)  `container` 中元素的迭代器的类型一般为 `container::iterator`。

迭代器可以用来遍历容器，例如，下面两个 for 循环的效果是一样的：

```cpp
vector<int> data(10);

for (int i = 0; i < data.size(); i++)
  cout << data[i] << endl;  // 使用下标访问元素

for (vector<int>::iterator iter = data.begin(); iter != data.end(); iter++)
  cout << *iter << endl;  // 使用迭代器访问元素
// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码
```

### 分类

在 STL 的定义中，迭代器根据其支持的操作依次分为以下几类：

- InputIterator（输入迭代器）：只要求支持拷贝、自增和解引访问。
- OutputIterator（输出迭代器）：只要求支持拷贝、自增和解引赋值。
- ForwardIterator（向前迭代器）：同时满足 InputIterator 和 OutputIterator 的要求。
- BidirectionalIterator（双向迭代器）：在 ForwardIterator 的基础上支持自减（即反向访问）。
- RandomAccessIterator（随机访问迭代器）：在 BidirectionalIterator 的基础上支持加减运算和比较运算（即随机访问）。

### 相关函数

很多 [STL 函数](./algorithm.md) 都使用迭代器作为参数。

可以使用 `std::advance(it, n)` 将迭代器 `it` 向后移动 `n` 步；若 `n` 为负数，则对应向前移动。迭代器必须满足双向迭代器，否则行为未定义。

在 C++11 以后可以使用 `std::next(it)` 获得向前迭代器 `it` 的后继（此时迭代器 `it` 不变），`std::next(it, n)` 获得向前迭代器 `it` 的第 `n` 个后继。

在 C++11 以后可以使用 `std::prev(it)` 获得双向迭代器 `it` 的前驱（此时迭代器 `it` 不变），`std::prev(it, n)` 获得双向迭代器 `it` 的第 `n` 个前驱。

[STL 容器](./container.md) 一般支持从一端或两端开始的访问，以及对 [const 修饰符](../const.md) 的支持。例如容器的 `begin()` 函数可以获得指向容器第一个元素的迭代器，`rbegin()` 函数可以获得指向容器最后一个元素的反向迭代器，`cbegin()` 函数可以获得指向容器第一个元素的 const 迭代器，`end()` 函数可以获得指向容器尾端（“尾端”并不是最后一个元素，可以看作是最后一个元素的后继；“尾端”的前驱是容器里的最后一个元素，其本身不指向任何一个元素）的迭代器。

### 共有函数

`=`：有赋值运算符以及复制构造函数。

`begin()`：返回指向开头元素的迭代器。

`end()`：返回指向末尾的下一个元素的迭代器。`end()` 不指向某个元素，但它是末尾元素的后继。

`size()`：返回容器内的元素个数。

`max_size()`：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。

`empty()`：返回容器是否为空。

`swap()`：交换两个容器。

`clear()`：清空容器。

`==`/`!=`/`<`/`>`/`<=`/`>=`：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >`，无序容器不支持 `<`/`>`/`<=`/`>=`。）

## 关联式容器

### `set`

`set` 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。`set` 内部通常采用红黑树实现。平衡二叉树的特性使得 `set` 非常适合处理需要同时兼顾查找、插入与删除的情况。

和数学中的集合相似，`set` 中不会出现值相同的元素。如果需要有相同元素的集合，需要使用 `multiset`。`multiset` 的使用方法与 `set` 的使用方法基本相同。

#### 插入与删除操作

- `insert(x)` 当容器中没有等价元素的时候，将元素 x 插入到 `set` 中。

- `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。

- `erase(pos)` 删除迭代器为 pos 的元素，要求迭代器必须合法。

- `erase(first,last)` 删除迭代器在 $[first,last)$ 范围内的所有元素。

- `clear()` 清空 `set`。

  insert 函数的返回值类型为 `pair<iterator, bool>`，其中 iterator 是一个指向所插入元素（或者是指向等于所插入值的原本就在容器中的元素）的迭代器，而 bool 则代表元素是否插入成功，由于 `set` 中的元素具有唯一性质，所以如果在 `set` 中已有等值元素，则插入会失败，返回 false，否则插入成功，返回 true；`map` 中的 insert 也是如此。

`set` 中的`insert`和`erase`复杂度是$O(nlogn)$

#### 迭代器

`set` 提供了以下几种迭代器：

1.  `begin()/cbegin()`   
    返回指向首元素的迭代器，其中 `*begin = front`。
2.  `end()/cend()`   
    返回指向数组尾端占位符的迭代器，注意是没有元素的。
3.  `rbegin()/crbegin()`   
    返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。
4.  `rend()/crend()`   
    返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。

以上列出的迭代器中，含有字符 `c` 的为只读迭代器，你不能通过只读迭代器去修改 `set` 中的元素的值。如果一个 `set` 本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自 C++11 开始支持。

#### 查找操作

- `count(x)` 返回 `set` 内键为 x 的元素数量。
- `find(x)` 在 `set` 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 `end()`。
- `lower_bound(x)` 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 `end()`。
- `upper_bound(x)` 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 `end()`。
- `empty()` 返回容器是否为空。
- `size()` 返回容器内元素个数。

 `set` 自带的 `lower_bound` 和 `upper_bound` 的时间复杂度为 $O(\log n)$。

但使用 `algorithm` 库中的 `lower_bound` 和 `upper_bound` 函数对 `set` 中的元素进行查询，时间复杂度为 $O(n)$。

#### 使用样例

`set` 在贪心中的使用

在贪心算法中经常会需要出现类似 **找出并删除最小的大于等于某个值的元素**。这种操作能轻松地通过 `set` 来完成。

```cpp
// 现存可用的元素
set<int> available;
// 需要大于等于的值
int x;

// 查找最小的大于等于x的元素
set<int>::iterator it = available.lower_bound(x);
if (it == available.end()) {
  // 不存在这样的元素，则进行相应操作……
} else {
  // 找到了这样的元素，将其从现存可用元素中移除
  available.erase(it);
  // 进行相应操作……
}
```

### `map`

`map` 是有序键值对容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。`map` 通常实现为红黑树。

你可能需要存储一些键值对，例如存储学生姓名对应的分数：`Tom 0`，`Bob 100`，`Alan 100`。但是由于数组下标只能为非负整数，所以无法用姓名作为下标来存储，这个时候最简单的办法就是使用 STL 中的 `map` 了！

`map` 重载了 `operator[]`，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key`，也就是索引）：

```cpp
map<Key, T> yourMap;
```

其中，`Key` 是键的类型，`T` 是值的类型，下面是使用 `map` 的实例：

```cpp
map<string, int> mp;
```

`map` 中不会存在键相同的元素，`multimap` 中允许多个元素拥有同一键。`multimap` 的使用方法与 `map` 的使用方法基本相同。
正是因为 `multimap` 允许多个元素拥有同一键的特点，`multimap` 并没有提供给出键访问其对应值的方法。

#### 插入与删除操作

- 可以直接通过下标访问来进行查询或插入操作。例如 `mp["Alan"]=100`。
- 通过向 `map` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>("Alan",100));`；
- `erase(key)` 函数会删除键为 `key` 的 **所有** 元素。返回值为删除元素的数量。
- `erase(pos)`: 删除迭代器为 pos 的元素，要求迭代器必须合法。
- `erase(first,last)`: 删除迭代器在 $[first,last)$ 范围内的所有元素。
- `clear()` 函数会清空整个容器。

在利用下标访问 `map` 中的某个元素时，如果 `map` 中不存在相应键的元素，会自动在 `map` 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）。当下标访问操作过于频繁时，容器中会出现大量无意义元素，影响 `map` 的效率。因此一般情况下推荐使用 `find()` 函数来寻找特定键的元素。

#### 查询操作

- `count(x)`: 返回容器内键为 x 的元素数量。复杂度为 $O(\log(size)+ans)$（关于容器大小对数复杂度，加上匹配个数）。
- `find(x)`: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 `end()`。
- `lower_bound(x)`: 返回指向首个不小于给定键的元素的迭代器。
- `upper_bound(x)`: 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()`。
- `empty()`: 返回容器是否为空。
- `size()`: 返回容器内元素个数。

#### 使用样例

##### `map` 用于存储复杂状态

在搜索中，我们有时需要存储一些较为复杂的状态（如坐标，无法离散化的数值，字符串等）以及与之有关的答案（如到达此状态的最小步数）。`map` 可以用来实现此功能。其中的键是状态，而值是与之相关的答案。下面的示例展示了如何使用 `map` 存储以 `string` 表示的状态。

```cpp
// 存储状态与对应的答案
map<string, int> record;

// 新搜索到的状态与对应答案
string status;
int ans;
// 查找对应的状态是否出现过
map<string, int>::iterator it = record.find(status);
if (it == record.end()) {
  // 尚未搜索过该状态，将其加入状态记录中
  record[status] = ans;
  // 进行相应操作……
} else {
  // 已经搜索过该状态，进行相应操作……
}
```

#### 遍历容器

可以利用迭代器来遍历关联式容器的所有元素。

```cpp
set<int> s;
typedef set<int>::iterator si;
for (si it = s.begin(); it != s.end(); it++) cout << *it << endl;
```

需要注意的是，对 `map` 的迭代器解引用后，得到的是类型为 `pair<Key, T>` 的键值对。

在 C++11 中，使用范围 for 循环会让代码简洁很多：

```cpp
set<int> s;
for (auto x : s) cout << x << endl;
```

对于任意关联式容器，使用迭代器遍历容器的时间复杂度均为 $O(n)$。

#### 自定义比较方式

`set` 在默认情况下的比较函数为 `<`（如果是非内置类型需要 [重载 `<` 运算符](../op-overload.md#compare)）。然而在某些特殊情况下，我们希望能自定义 `set` 内部的比较方式。

这时候可以通过传入自定义比较器来解决问题。

具体来说，我们需要定义一个类，并在这个类中 [重载 `()` 运算符](../op-overload.md#function)。

例如，我们想要维护一个存储整数，且较大值靠前的 `set`，可以这样实现：

```cpp
struct cmp {
  bool operator()(int a, int b) { return a > b; }
};

set<int, cmp> s;
```

对于其他关联式容器，可以用类似的方式实现自定义比较，这里不再赘述。

## 无序（关联式）容器

它们与相应的关联式容器在功能，函数等方面有诸多共同点，而最大的不同点则体现在普通的关联式容器一般采用红黑树实现，内部元素按特定顺序进行排序；而这几种无序关联式容器则采用哈希方式存储元素，内部元素不以任何特定顺序进行排序，所以访问无序关联式容器中的元素时，访问顺序也没有任何保证。

采用哈希存储的特点使得所器里面不能存储多个相同元素，自动去重，当值少的时候是插入，查找，删除都是 $O(1)$，当值多的时候冲突产生，时间复杂度逐渐演变为$O(n)$

## 容器适配器

### 优先队列

内部源码就是堆

#### 头文件

```cpp
#include <queue>
```

#### 定义

```cpp
std::priority_queue<TypeName> q;             // 数据类型为 TypeName
std::priority_queue<TypeName, Container> q;  // 使用 Container 作为底层容器
std::priority_queue<TypeName, Container, Compare> q;
// 使用 Container 作为底层容器，使用 Compare 作为比较类型

// 默认使用底层容器 vector
// 比较类型 less<TypeName>（此时为它的 top() 返回为最大值）
// 若希望 top() 返回最小值，可令比较类型为 greater<TypeName>
// 注意：不可跳过 Container 直接传入 Compare

// 从 C++11 开始，如果使用 lambda 函数自定义 Compare
// 则需要将其作为构造函数的参数代入，如：
auto cmp = [](const std::pair<int, int> &l, const std::pair<int, int> &r) {
  return l.second < r.second;
};
std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >,
                    decltype(cmp)>
    pq(cmp);
```

#### 成员函数

##### 以下所有函数均为常数复杂度

- `top()` 访问堆顶元素（此时优先队列不能为空）
- `empty()` 询问容器是否为空
- `size()` 查询容器中的元素数量

##### 以下所有函数均为对数复杂度

- `push(x)` 插入元素，并对底层容器排序
- `pop()` 删除堆顶元素（此时优先队列不能为空）

#### 简单示例

```cpp
std::priority_queue<int> q1;
std::priority_queue<int, std::vector<int> > q2;
// C++11 后空格可省略
std::priority_queue<int, std::deque<int>, std::greater<int> > q3;
// q3 为小根堆
for (int i = 1; i <= 5; i++) q1.push(i);
// q1 中元素 :  [1, 2, 3, 4, 5]
std::cout << q1.top() << std::endl;
// 输出结果 : 5
q1.pop();
// 堆中元素 : [1, 2, 3, 4]
std::cout << q1.size() << std::endl;
// 输出结果 ：4
for (int i = 1; i <= 5; i++) q3.push(i);
// q3 中元素 :  [1, 2, 3, 4, 5]
std::cout << q3.top() << std::endl;
// 输出结果 : 1
```

# RMQ问题

**RMQ就是一个查询区间最大最小值的问题，使用的是dp的思想**
**RMQ：RMQ（Range Minimum/Maximum Query），即区间最值查询，是指这样一个问题：对于长度为n的数列A，
回答若干询问RMQ（A,i,j）(i,j<=n)，返回数列A中下标在i，j之间的最小/大值。**
本节介绍了一种比较高效的在线算法（ST算法）解决这个问题。所谓在线算法，是指用户每输入一个查询便马上处理一个查询。该算法一般用较长的时间做预处理，待信息充足以后便可以用较少的时间回答每个查询。ST（Sparse Table）算法是一个非常有名的在线处理[RMQ](https://so.csdn.net/so/search?q=RMQ&spm=1001.2101.3001.7020)问题的算法

## 引入

题目大意：给定 $n$ 个数，有 $m$ 个询问，对于每个询问，你需要回答区间 $[l,r]$ 中的最大值。

考虑暴力做法。每次都对区间 $[l,r]$ 扫描一遍，求出最大值。

显然，这个算法会超时。

## ST 表

ST 表基于 [倍增](../basic/binary-lifting.md) 思想，可以做到 $\Theta(n\log n)$ 预处理，$\Theta(1)$ 回答每个询问。但是不支持修改操作。

### 倍增法

首先我们先谈谈什么是倍增：倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。对于一个区间问题，例如要我们去查询区间 1 ~ 6，我们可以把这个区间分解成 1 ~ 4，5 ~ 6两个区间，也就是说我们把区间分成了很多个2的倍数大小的区间，设我们已经知道这些2的倍数大小的区间，我们就可以在 $O(logn)$的时间复杂度内求出这个区间。那么倍增法就是帮助我们去求出这些区间。设数组$f[i][j]$表示以$i$为首位置后$2^{j}$个位置的和，那么对于$f[i][0] = a[i]$这些是已知的，那么对于未知的$f[i][j]$，我们发现可以由两个已知的小区间$f[i][j - 1],f[i + (1 << j - 1)][j]$来得到，那么我们就可以通过未知来推导出已知，这就是所谓的倍增法。 

#### 例题

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230130184402622.png" alt="image-20230130184402622" style="zoom:67%;" />

```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N],f[N][20];
int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        f[i][0] = a[i];
    }
    for(int i = 1; i <= 20; i++){
        for(int j = 1; j <= n; j++){
            if(j + (1 << (i - 1)) <= n){
                f[j][i] = f[j][i - 1] + f[j + (1 << (i - 1))][i - 1];
            }
        }
    }
    int l,r;
    for(int i = 1; i <= m; i++){
        scanf("%d %d",&l,&r);
        int x = r - l + 1;
        int d = 0,sum = 0;
        while(x){
            if(x & 1) sum += f[l][d],l += 1 << d;
            d++;
            x >>= 1;
        }
        printf("%d\n",sum);
    }
}
```

ST表是用来求出区间最值问题的，同样的区间$l,r$的最大值，我们也可以求二进制下的好几个区间中最大值的最大值，时间复杂度是$O(nlogn)$。

![image-20230130190310494](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230130190310494.png)


```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int v[N],w[N],a[N],f[N][20],f2[N][20];
int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        f[i][0] = a[i];
        f2[i][0] = a[i];
    }
    for(int i = 1; i <= 20; i++){
        for(int j = 1; j <= n; j++){
            if(j + (1 << (i - 1)) <= n){
                f[j][i] = max(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);
                f2[j][i] = min(f2[j][i - 1] , f2[j + (1 << (i - 1))][i - 1]);
            }
        }
    }
    int l,r;
    for(int i = 1; i <= m; i++){
        scanf("%d %d",&l,&r);
        int x = r - l + 1;
        int d = 0,sum1 = 0,sum2 = 1e9;
        while(x){
            if(x & 1) sum1 = max(sum1,f[l][d]),sum2 = min(sum2,f2[l][d]),l += 1 << d;
            d++;
            x >>= 1;
        }
        printf("%d\n",sum1 - sum2);
    }
}
```

不过在我们区间最值方面我们对于查询有所优化，可以优化为$O(1)$

我们看一段区间$[l,r]$。倘若我们要求和，我们必须做到不重不漏，但是如果是求最大值，对于同样的一个数字重复取最大值是没有影响的。

所以我们要求和的时候使用二进制最优。但是我们对于最大值可以如下操作：

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230130191226344.png" alt="image-20230130191226344" style="zoom:67%;" />
我们可以取A区间和B区间的最大值，这样的话时间复杂度就降为$O(1)$了，这就是我们ST表的思想。

那么对于一段区间的最值，我们给他分为两个小区间的最值，只要两个小区间相交即可。

想要相交很简单，前区间超过中间的一半，后区间也超过中间的一半即可。

那么我们知道二进制的一个性质就是 $2^x$ = $2^{x - 1} + 2^{x - 2} + ... + 2^{0} + 1$，所以我们只需要我们的值超过最高位即可

假设一个数字的最高位为$s$那么我们只需要求出$max(f[l][s],f[r - (1 << s) + 1][s])$即可。

我们都知道对数是次幂的逆运算，也就是$log_{x}x^y$ = y，那么$log_22^y = y$。

讨论$log_2T$，若$T$是2的整数倍，那么得到的答案就是最高位，满足条件。

如果$T$不是2的整数倍，那么得到的答案一定是 > 最高位，此时我们只需要向下取整得到的答案是 >= 最高位，也满足条件。

综上所述我们只需要求出$max(f[l][log2(r - l + 1)],f[r - 1<<(log2(r - l + 1) + 1)][log2(r - l + 1)])$

## 模板代码

[ST 表模板题](https://www.luogu.com.cn/problem/P3865)

### C 风格模板

```cpp
--8<-- "docs/ds/code/sparse-table/sparse-table_1.cpp"
```

### C++ 风格模板

```cpp
--8<-- "docs/ds/code/sparse-table/sparse-table_2.hpp"
```

## 注意点

1. 输入输出数据一般很多，建议开启输入输出优化。

2. 每次用 [std::log](https://en.cppreference.com/w/cpp/numeric/math/log) 重新计算 log 函数值并不值得，建议进行如下的预处理：

$$
\left\{\begin{aligned}
Logn[1] &=0, \\
Logn\left[i\right] &=Logn[\frac{i}{2}] + 1.
\end{aligned}\right.
$$

## ST 表维护其他信息

除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。

需要注意的是，对于“区间 GCD”，ST 表的查询复杂度并没有比线段树更优（令值域为 $w$，ST 表的查询复杂度为 $\Theta(\log w)$，而线段树为 $\Theta(\log n+\log w)$，且值域一般是大于 $n$ 的），但是 ST 表的预处理复杂度也没有比线段树更劣，而编程复杂度方面 ST 表比线段树简单很多。

如果分析一下，“可重复贡献问题”一般都带有某种类似 RMQ 的成分。例如“区间按位与”就是每一位取最小值，而“区间 GCD”则是每一个质因数的指数取最小值。

## 总结

ST 表能较好的维护“可重复贡献”的区间信息（同时也应满足结合律），时间复杂度较低，代码量相对其他算法很小。但是，ST 表能维护的信息非常有限，不能较好地扩展，并且不支持修改操作。

## 练习

[RMQ 模板题](https://www.luogu.com.cn/problem/P3865)

[「SCOI2007」降雨量](https://loj.ac/problem/2279)

[\[USACO07JAN\]平衡的阵容 Balanced Lineup](https://www.luogu.com.cn/problem/P2880)

## 附录：ST 表求区间 GCD 的时间复杂度分析

在算法运行的时候，可能要经过 $\Theta(\log n)$ 次迭代。每一次迭代都可能会使用 GCD 函数进行递归，令值域为 $w$，GCD 函数的时间复杂度最高是 $\Omega(\log w)$ 的，所以总时间复杂度看似有 $O(n\log n\log w)$。

但是，在 GCD 的过程中，每一次递归（除最后一次递归之外）都会使数列中的某个数至少减半，而数列中的数最多减半的次数为 $\log_2 (w^n)=\Theta(n\log w)$，所以，GCD 的递归部分最多只会运行 $O(n\log w)$ 次。再加上循环部分（以及最后一层递归）的 $\Theta(n\log n)$，最终时间复杂度则是 $O(n(\log w+\log x))$，由于可以构造数据使得时间复杂度为 $\Omega(n(\log w+\log x))$，所以最终的时间复杂度即为 $\Theta(n(\log w+\log x))$。

而查询部分的时间复杂度很好分析，考虑最劣情况，即每次询问都询问最劣的一对数，时间复杂度为 $\Theta(\log w)$。因此，ST 表维护“区间 GCD”的时间复杂度为预处理 $\Theta(n(\log n+\log w))$，单次查询 $\Theta(\log w)$。

线段树的相应操作是预处理 $\Theta(n\log x)$，查询 $\Theta(n(\log n+\log x))$。

这并不是一个严谨的数学论证，更为严谨的附在下方：

??? note "更严谨的证明"
    理解本段，可能需要具备 [时间复杂度](../basic/complexity.md) 的关于“势能分析法”的知识。
    

    先分析预处理部分的时间复杂度：
    
    设“待考虑数列”为在预处理 ST 表的时候当前层循环的数列。例如，第零层的数列就是原数列，第一层的数列就是第零层的数列经过一次迭代之后的数列，即 `st[1..n][1]`，我们将其记为 $A$。
    
    而势能函数就定义为“待考虑数列”中所有数的累乘的以二为底的对数。即：$\Phi(A)=\log_2\left(\prod\limits_{i=1}^n A_i\right)$。
    
    在一次迭代中，所花费的时间相当于迭代循环所花费的时间与 GCD 所花费的时间之和。其中，GCD 花费的时间有长有短。最短可能只有两次甚至一次递归，而最长可能有 $O(\log w)$ 次递归。但是，GCD 过程中，除最开头一层与最末一层以外，每次递归都会使“待考虑数列”中的某个结果至少减半。即，$\Phi(A)$ 会减少至少 $1$，该层递归所用的时间可以被势能函数均摊。
    
    同时，我们可以看到，$\Phi(A)$ 的初值最大为 $\log_2 (w^n)=\Theta(n\log w)$，而 $\Phi(A)$ 不增。所以，ST 表预处理部分的时间复杂度为 $O(n(\log w+\log n))$。

# 进阶前缀和和差分练习

# 进阶递推与递归练习

# 进阶二分练习

# 进阶图论

## 图论知识

### 二分图

### 欧拉图

### 有向无环图

### 连通图

### 强连通图

### 重连通图

## 拓扑排序

## 单源最短路之bellman - ford

## 单源最短路之spfa

## 单源最短路之Dijkstra

## 多源最短路的建边方式

## 多源最短路之Floyd



## 最小生成树Prim

## 最小生成树Kruskal

## 二分图

## 二分图匹配

# 搜索

## 多源BFS

## DFS之连通性

## DFS之搜索顺序

## DFS之剪枝与优化

## 迭代加深

## 双向DFS

# 进阶数论

## 欧拉定理和欧拉函数

## 费马小定理

## 扩展欧几里得算法

## 威尔逊定理

## 裴蜀定理

## 中国剩余定理

## 容斥定理

# 线性代数

# 进阶动态规划

## 数字三角模型

## 最长上升子序列模型

## 记忆化搜索

## 背包模型

## 状态压缩dp

## 树形dp

# 组合数学

# 更进阶数据结构

## 进阶并查集

### 权值并查集

顾名思义，通过权值来设置特殊性质的并查集。

![image-20221014194415215](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221014194415215.png)

咋们通过以上题目来进行讲解。
我们思考A -> B B-> C 的话 一定是能推出 C->A，所以ABC在一个集合里面，我们只需要知道其中两个的关系，就能推导第三个。

![image-20221014205230052](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221014205230052.png)

我们假设这是一些动物的关系，我们可以通过图片看出来，A被B,D,E吃，C,F被A吃，G是A的同类。

那么我们发现，若我们当前动物层数是X，那么与我们为同类的即为，X + 3 * n层，吃我们的是 X + 1 + 3 * n层，被我们吃的是 X + 2 + 3 * n层
对于3取模的话就只剩3种情况，0，1，2。所以最后，我们只需要维护每个点到他祖宗的深度就可以了。
那么主要难点的话还是合并，我们该怎么合并呢？
![image-20221014205311823](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221014205311823.png)

假设C，D同类我们现在要合并他们的祖宗节点A，C
由于 AB + AC == BD + CD 所以    AC + AB $\equiv $ BD (mod 3)
也就是说 (AC + AB - BD) mod 3 == 0
所以AB = BD - AC

```
//这是求深度的关键代码
int find(int x){
    if (p[x] != x){
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }
    return p[x];
}
```

总体食物链代码

```
#include <iostream>

using namespace std;

const int N = 50010;

int n, m;
int p[N], d[N];

int find(int x){
    if (p[x] != x){
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }
    return p[x];
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    int res = 0;
    while (m -- ){
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);
        if (x > n || y > n) res ++ ;
        else{
            int px = find(x), py = find(y);
            if (t == 1){
                if (px == py && (d[x] - d[y]) % 3) res ++ ;
                else if (px != py){
                    p[px] = py;
                    d[px] = d[y] - d[x];
                }
            }else{
                if (px == py && (d[x] - d[y] - 1) % 3) res ++ ;
                else if (px != py){
                    p[px] = py;
                    d[px] = d[y] + 1 - d[x];
                }
            }
        }
    }
    printf("%d\n", res);
    return 0;
}
```



## 树状数组

## 线段树

# 更进阶图论

## 单源最短路的建边方式

1. **1对1**

![image-20221111214734195](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111214734195.png)


2. **1对多**

![image-20221111214910149](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111214910149.png)


3. **多对多**
   ![image-20221111215039748](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111215039748.png)
   4**.反向建图**
   ![image-20221111215220264](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111215220264.png)

   5.建立虚拟原点，减少边的数量
   ![image-20221111215647154](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111215647154.png)

   6.适量的增加复杂度来换取正确答案（枚举）
   ![image-20221111215842794](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20221111215842794.png)

## 单源最短路的综合应用

## 单源最短路的扩展应用

## 负环问题

## Floyd算法的应用

## 最小生成树进阶

## 最小生成树的扩展应用

## 差分约束算法

## 最近公共祖先算法

## 拓扑排序的进阶应用

## 欧拉回路和欧拉路径

# 更进阶数论

## 筛法的使用

## 快速幂

## 约数进阶

## 欧拉函数进阶

## 同余进阶

# 进阶线性代数

## 矩阵乘法

## 高斯消元

# 组合数学进阶

## 鸽巢原理

## 卡特兰数

## 容斥原理进阶

## 错排

# 更进阶动态规划

## 状态机模型

## 数位dp

## 单调队列优化dp

# 更更进阶图论

## 前置知识

## 求强连通分量算法

## 强连通分量的缩点算法

## 求割点割边

# 更更进阶数据结构

## 二叉平衡树之treap

## 二叉平衡树之splay

## 基环树